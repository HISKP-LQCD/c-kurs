\section{Variablen}
Die Ausgangs und Eingangsparameter eines Funkcions sind Variablen.
Ein Variable ist ein Konzept, der eine Name im Quelltext, und eine Addresse im Speicher deiner Maschine hat. 
Im Quelltext das Variable ist identifiziert bei ihrem Name. In \ref{typ_1} das int vor dem Name der eingangsparameter
ist ihre Typ. Hier unter siehst du unsere erste Variable definition. In der dritten Reihe wir haben einen Variable
nennt $n$ als ein int (ganze Zahl) definiert. 
\begin{lstlisting}{Erste Variable definition}
#include<stido.h>
int main( int argc, char *argv[]){
   int n=4;
   printf("Wir werden n zahlen sortieren:\n");
}
\end{lstlisting}

Wir verstehen unter definiert, das wir haben Speicher zugewiesen. Für das Typ int wir brauchen $4$ byte Speichern.
Natürlich alle Variable haben ihre eigenen Sichtbarkeitsbereit und Lebensdauer. Mann kann nicht anderen Variablen mit dem gleichen Namen 
im derseblen Blocken definieren. Wenn du eine Variable mit dem gleichen namen deklarierts in einem Block, denn der Andere wird nicht
sichtbar in der inneren Block. Variable, das wir in einem Funckion definiert haben, lebt in diesem Funkcion. Man kann diesen Variablen als 
Lokalen bezeichnet. Wenn mann die Werte diesen Variablen außer der Funkcion haben will, mann macht ein Fehler. In diesem Fall 
muss mann sie außerhalb der Funkcionen definieren. Deise Variablen kann man bezeichnet als global. 
Ihren Wert ist erreichbar für allen Funkcion im Quelltext. Es gibt zwei verschiedene möglichkeiten zum definiering
eine globale Variable.
\begin{enumerate}
\item Stichwort static: In diesem Fall mann kann nutzten die Variable in ganzen File, wo es definiert war. Anderen
Files in unserem Code kann natürlich nutzten eine andere Variable mit dem gleichen Name.
\item Stichwort extern: In diesem Fall mann kann nutzten die Variable in dem ganzen Programm. Aber das
variable muss deklariert werden in allen Files, wo wir ihn nutzten wollen.
\end{enumerate} die für alle
Wir haben die Sichtbarkeitbereich der Variablen 
in der Abbildung  \ref{sicht} zusammen gefasst.  Das bedeutet, das wir können Variablen mit 
gleichen Namen in verschiedenen Funkcionen nutzten, wenn wir definieren sie als lokalen Variablen. 

% Generated with LaTeXDraw 2.0.8
% Tue Feb 21 10:59:44 CET 2017
% \usepackage[usenames,dvipsnames]{pstricks}
% \usepackage{epsfig}
% \usepackage{pst-grad} % For gradients
% \usepackage{pst-plot} % For axes
%\scalebox{0.5} % Change this value to rescale the drawing.
%{
\begin{figure}[!ht]
\centering
\scalebox{0.5}
{
\begin{pspicture}(2,-9.1)(17.3,9.12)
\psframe[linewidth=0.04,dimen=outer](12.6,9.1)(2.0,-9.1)
%\usefont{T1}{ptm}{m}{n}
\rput(3.6692188,8.61){Source code}
\psline[linewidth=0.04](5.2,9.1)(5.2,8.1)(2.0,8.1)
%\usefont{T1}{ptm}{m}{it}
\rput(7.8229685,-7.565){globalen Variablen: Deklarierten mit dem Stichwort: extern}
\psframe[linewidth=0.04,dimen=outer](11.6,7.1)(3.2,0.1)
\psframe[linewidth=0.04,dimen=outer](11.6,-0.5)(3.2,-7.1)
%\usefont{T1}{ptm}{m}{n}
\rput(4.0503125,6.81){File 1}
%\usefont{T1}{ptm}{m}{n}
\rput(4.0489063,-0.79){File 2}
\psline[linewidth=0.04](5.0,7.1)(5.0,6.5)(3.2,6.5)(3.2,6.5)
\psline[linewidth=0.04](4.8,-0.5)(4.8,-1.1)(3.2,-1.1)
%\usefont{T1}{ptm}{m}{n}
\rput(6.7009373,0.81){variable mit static Stichwort}
%\usefont{T1}{ptm}{m}{n}
\rput(6.9809375,-6.59){variablen mit static stichwort}
\psframe[linewidth=0.04,dimen=outer](6.8,5.7)(3.8,2.7)
\psframe[linewidth=0.04,dimen=outer](11.0,5.5)(8.0,2.7)
\psframe[linewidth=0.04,dimen=outer](7.0,-1.7)(3.6,-5.1)
\psframe[linewidth=0.04,dimen=outer](11.2,-1.9)(8.0,-5.3)
%\usefont{T1}{ptm}{m}{n}
\rput(4.9203124,5.41){Funkcion 1}
%\usefont{T1}{ptm}{m}{n}
\rput(9.3189063,5.21){Funkcion 2}
%\usefont{T1}{ptm}{m}{n}
\rput(4.9203124,-1.99){Funkcion 1}
%\usefont{T1}{ptm}{m}{n}
\rput(9.3189063,-2.19){Funkcion 2}
%\usefont{T1}{ptm}{m}{n}
\rput(4.7434375,4.61){Lokale }
%\usefnt{T1}{ptm}{m}{n}
\rput(5.4034376,4.21){variablen}
%\usefont{T1}{ptm}{m}{n}
\rput(9.3434377,4.41){Lokale}
%\usefont{T1}{ptm}{m}{n}
\rput(9.8173437,4.01){Variablen}
%\usefont{T1}{ptm}{m}{n}
\rput(4.7434375,-3.39){Lokale}
%\usefont{T1}{ptm}{m}{n}
\rput(5.2034376,-3.79){variablen}
%\usefont{T1}{ptm}{m}{n}
\rput(9.3434377,-3.39){Lokale}
%\usefont{T1}{ptm}{m}{n}
\rput(9.8034377,-3.79){variablen}
\end{pspicture}
}
\caption{\label{sicht} Sichtbarkeitbereich der Variablen}
\end{figure}

Die Variablen haben Wert und Typ. Das Typ der Variable ist sehr wichtig. Es hängt vom Typ ab, was für ein Wert eine Variable haben
kann. Das Typ entscheid also die Grösse des Arbeitspeicher zu deine Variable. Mann kann nun solche Funkcionen und Operatoren nutzen, das
genanue Datentype hat. Es gibt elementare data Typen mit dem wir spielen können. Wir haben im Tabellen \ref{tabelle1} alle elementare
Datatypen gelistet.


\begin{table}[h]
\caption{Elementare Daten Typen\label{tabelle1}}  % title name of the table
\centering
  % centering table
\begin{tabular}{|l c c rrr|}
  % creating 10 columns
\hline
Name & & Varianten & Größe in Byte & Minimal Wert & Maximal Wert
  % inserting double-line Audio &Audibility & Decision & \multicolumn{7}{c}{Sum of Extracted Bits} 
\\[0.5ex]   
\hline % inserts single-line % Entering 1 st row
                       & & int &4 & $-2,147,483,648$ & $2,147,483,647$ \\[-0.0ex]
                       & & short & 2 & $-32,768$ & $32,767$ \\[-0.0ex]
\raisebox{1ex}{int}  & & unsigned short& 2 & $0$ & $65535$ \\[-0.0ex]
                       & &unsigned& 4 & $0$ & $ +4,294,967,295$ \\[1ex]
                       & &long& 4 &  $-2,147,483,648$ & $2,147,483,647$ \\
\hline
% Entering 2nd row
                            & &signed & 1 & $-128$ & $127$ \\[-1ex]
\raisebox{1.5ex}{Char} &    & unsigned &1 & $0$ & $255$  \\[1ex]
\hline
% Entering 3rd row
float & & & 4 &  &  \\
double& & & 8 &  &  \\
long double& & &8 &  &  \\[1ex]

% [1ex] adds vertical space
\hline                          % inserts single-line
\end{tabular}
\label{tab:PPer}
\end{table}

Wir habe unseren ersten Variable im Bespiel als $n$ genennt. Es gibt einige Regeln, wie mann das Variable nennen kann. Zum Beispiel
wir dürfen nicht das Name mit einem Zahl beginnen. Wir dürfen Kapital und Klein Buchstabe nutzten. Wir dürfen auch Zahlen nutzten, aber
nicht als der erste Charakter. Das Unterstricht ist also erlaubt, aber wir nutzten sie nur für grösse Programmen.

Im Beispiel wir haben ein Wert (4) zum $n$ zugewiesen. Das ist sehr wichtig, weil das Complier standardmäßig unsere Variablen nicht
initializiert. Das ist eine der häufigste Fehler, das ein Programmierer machen kann. Im unter wir zeigen einige Richtige und Fals 
Variable definitionen:

\begin{lstlisting}
int main(int argc, char *argv[]){
   int m1=4, n1=5, l1=6; /* Richtig */
   int m2=4, char n2='a', float m2=4. /*Falsch */
   char m3='a'; double n3=18.9;/*Richtig*/
   float 4m=1.; /*Falsh */
}
\end{lstlisting} 

Wir können mehrere Variablen definierin in einer Anweisung, wenn die Variablen das gleiche Typ haben. Du kannst das sehen in dem zweiten Linie oben.
Eine Anweisung muss mit mit dem Character ';' beenden. Nach jedem ';' beginnt eine neue Anweisung. Das Character ',' bedeutet Auflistung, was in 
einem Anweisung mehrweise erscheinen darf. Wir illustrieren das falsche Weg in  dem dritten Linie, und das Rechte Weg zeigen wir in dem vierten Linie.
Im fünften Linie illustrieren wir, dass das Name der Variable nicht mit einem Zahl beginnin darf. Eine practical Beratung ist initializerien
alle Variables recht im Definition. Das Name der Variablen kann auch uns helfen, um das Programm verstehen zu können. Zum Beispiel im 
Einfügesortieren es ist ratsam die Array als sortiert und unsortiert nennen.

Jetzt werden wir sehen, was wir mit unseren Variablen machen kann. Wir können aus Variables mit Operatoren neue Werte herstellen.
Wir können Expressions formen, die eine neue Wert ausdrücken. Es hängt vom typ ab, welche operatoren in der Expressions wir nutzten können.
Es gibt drei verschieden Expressiontyp:
\begin{itemize}
\item Infix: Das operator steht zwischen den Variablen. Zum Bespiel: $a+b$. Diese Expression nimmt den Wert von $a$ und $b$, summ es und gibt das Ergebnis zurück.
\item Präfix: Das operator steht vor dem Variable: Zum Bespiel: $++a$. Diese Expression zuerst inkrementiert $a$, und danach gibt das Wert vom $a$ zurück.
\item Postfix: Das operator steht nach dem Variable: Zum Beispiel: $a--$. Diese Expression dekrementiert $a$, aber gibt das originale Wert vom $a$ zurück.
\end{itemize}
\begin{lstlisting}
#include<stdio.h>
int main(){
    int a=2;
    printf("%d\n", a++);
    printf("%d\n", a);
    printf("%d\n", ++a);
    printf("%d\n", a);
}
\end{lstlisting}
Im obenen Beispiel zuerst wir definieren eine Variable mit dem Anfangswert zwei. Danach drücken wir die wirkung des Postfix operators ($++$) auf $a$ aus 
in der vierten Reihe. Das Ergebnis wird auch zwei sein, weil wir das Postfix operator genutzten haben. Aber wenn wir gleich danach im fünften Reihe
das Wert von $a$ ausdrücken, das Ergebnis wird drei sein. In der sechsten Reihe wir drücken die wirkung des Präfix operators ($++$) auf $a$ aus, und 
das Ergebnis wird vier sein, und als Nebeneffect, das Variable $a$ wird inkrementiert.

Wir haben also drei Vershieden Operator Typen:
\begin{itemize}
\item binärer: Das operator hat zwei Argumente
\item unärer: Das operator hat nur ein Argumente
\item ternärer; Nur eine, der drei Argumente hat: $?:$
\end{itemize} 

Die operatoren könnten bitwise, oder logicalische sein. Die bitwise operator sind binäre operatoren. Sie ausführen die operation mit jedem bits der Arguments.
Die Logical operatoren geben zurück Logical Wert: nein, oder falsh. In dem unteren Tabelle wir fassen zusammen die Wichtige operatoren der Sprache.

\begin{table}
\caption{Arithmetic operatoren \label{oper}}
\centering
\begin{tabular}{|l c c|}
\hline
Operator & Expression & Wert der Expression \\
\hline
Zuweisung & $a$ = $b$ & Werte von $b$ \\
Addition & $a$ + $b$ & Summe von $a$ und $b$ \\
Subraktion & $a$ - $b$ & Differenz von $a$ und $b$ \\
Multiplikation & $a$ * $b$ & Produkt von $a$ und $b$ \\
Division & $a$ / $b$ & Quotient von $a$ und $b$ \\
Modulo & $a$ \% $b$ & Rest eine Ganzzahldivision von $a$ durch $b$ \\
Inckrement & $++a$,$a++$ & Präfix: $a$+1, Postfix: $a$ \\
Dekrement & $--a$, $a--$ & Präfix: $a$-1, Postfix: $a$ \\
Positiver Vorzeichenoperator & $+a$ & Wert von $a$ \\
Negativer Vorzeichenoperator & $-a$ & Wert von $a$ aber mit umgekehrte Vorzeichen \\
\hline
\end{tabular}
\end{table}

\begin{table}
\caption{Vergleichs operatoren \label{vergoper}}
\centering
\begin{tabular}{|l c|}
\hline
Operator & Expression \\
\hline
Prüfen auf Gleichheit & $a == b$  \\
Prüfen auf Ungleichheit & $a != b$ \\
Prüfen, ob $a$ echt größer als $b$ ist & $a>b$ \\
Prüfen, ob $a$ echt kleiner als $b$ ist & $a<b$ \\
Prüfen, ob $a$ größer oder gleich $b$ ist & $a>=b$ \\
Prüfen, ob $a$ kleiner oder gleich $b$ ist & $a<=b$ \\
\hline
\end{tabular}
\end{table}

\begin{table}
\caption{Logischen operatoren \label{vergoper}}
\centering
\begin{tabular}{|l c c|}
\hline
Operator & Expression & Wert \\
\hline
                                                &                                &   Wenn $a$ und $b$ beide waren wahr, \\
                                                &                                &   dann der Rückgabe ist wahr,  \\
\raisebox{1.5ex}{Operator für das Logische UND} & \raisebox{1.5ex}{$a \&\& b$ }  &   in jeden anderen Fallen falsch \\
\hline
                                                &                                &   Wenn $a$ oder $b$ war wahr, \\
                                                &                                &   dann der Rückgabe ist wahr, \\
\raisebox{1.5ex}{Opatoren für das logische ODER}& \raisebox{1.5ex}{$a ||    b$}  &   in den anderen Fall  falsch \\
\hline
                                                &                                &   Wenn $a$ ist falsch, die Rückgabe is wahr, \\
\raisebox{1.5ex}{Negationsopeator}              & \raisebox{1.5ex}{$!a$}         &   und umgekehrt \\
\hline
\end{tabular}
\end{table}
