\documentclass{article}[12pt]
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

\usepackage[dvipsnames]{xcolor}
\usepackage{lipsum}

\usepackage{amsfonts}
\usepackage[intlimits]{amsmath}
\usepackage{cite}
\usepackage{epsfig}

\usepackage[usenames,dvipsnames]{pstricks}
\usepackage{pstricks-add}
\usepackage{epsfig}
\usepackage{pst-grad} % For gradients
\usepackage{pst-plot} % For axes

\addtolength{\hoffset}{-1.5cm}
\addtolength{\textwidth}{3cm}
\usepackage{listings}
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\PassOptionsToPackage{svgnames}{xcolor}
\usepackage{tcolorbox}
\usepackage{lipsum}
\tcbuselibrary{skins,breakable}
\usetikzlibrary{shadings,shadows}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=C,                      % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}


\newenvironment{myexampleblock}[1]{%
    \tcolorbox[beamer,%
    noparskip,breakable,
    colback=White,colframe=ForestGreen,%
    colbacklower=LimeGreen!75!White,%
    title=#1]}%
    {\endtcolorbox}

\newenvironment{myalertblock}[1]{%
    \tcolorbox[beamer,%
    noparskip,breakable,
    colback=White,colframe=Bittersweet,%
    colbacklower=Peach!75!White,%
    title=#1]}%
    {\endtcolorbox}

\newenvironment{myblock}[1]{%
    \tcolorbox[beamer,%
    noparskip,breakable,
    colback=White,colframe=RoyalBlue,%
    colbacklower=TealBlue!75!White,%
    title=#1]}%
    {\endtcolorbox}

\newenvironment{myexampleprogram}[1]{%
    \tcolorbox[beamer,%
    noparskip,breakable,
    colback=White,colframe=Goldenrod,%
    colbacklower=Yellow!75!White,%
    title=#1]}%
    {\endtcolorbox}
%--------
%\usepackage[magyar]{babel}
\title{C Programmierkurs}
\begin{document}
\maketitle
\include{intro}
%In einem sch\"onen Programm wir nutzten das wenigstens Speicher. In diesem Punkt wir werden lernen,
%wie die Speicherverwaltung behandelt wird.

%Im ersten Teil des Kurses wir haben die elemetare datatypen kennen gelernt. In diesem Punkt wir
%werden lernen, wie mann eigenes Daten Structure herstellen kann. Überhaupt, Warum and Wenn müssen wir neue Structure herstellen.
%Unser Programm mit eigenen Daten strukturen wird leichter lesen zu können. Das ist sehr wichtig. Typischer fehler der Angefangenen Programmern
%ist, dass ihr Code ist sehr schwer zu lesen auch für Sie, und nach einem Monat Sie müssen die ganze Programm
%wieder schreiben. Zum beispiel muss mann eigenes Datenstrukture nutzen, wenn man ein operations sehr often erledigen muss.
%Zum bespiel in der Sorierung eines List, man kann die Daten in einem binären Suchbaum einschließen um die suchen schneller zu lassen.
\include{speichernausdrucken}
\include{variablen}
\include{kontrollstrukturen}
\include{pointersarrays}
\include{einfuegesortieren}
\include{dynamischespeicherverwaltung}
\include{complexdatatypen}
\section{Datein verarbeiten}
In Unix wir identifizieren ein Datein mit seinem Name. Wir können Funktionen aus dem Standardbibliothek verwenden, um
detallierte Informationen zu erhalten. In diesem Fall die $C$ Sprache bietet uns den $stat$ Funktion und ihren Rückgabewert,
ein $stat$ Strukture. 
\begin{myexampleblock}{Definition: \texttt{struct stat}}
\begin{lstlisting}
struct tm{
  _dev_t st_dev:  /*Laufwerksnummer*/
  _ino_t st_ino;  /*Inode: eine grundlegende Datenstruktur zur Verwaltung von Dateisystemen mit unixartigen Betriebssystemen. */
  unsigned short st_mode; /*Modus, Berechtigungen*/
  short st_nlink; /**/
  short st_uid;   /*USER-ID*/
  short st_gid;   /*GROUP-ID*/
  _dev_t st_rdev: /*Laufwerksnummer*/
  _off_t st_size; /*Dateigroesse in Bytes */
  time_t st_atime; /*Datum des letzten Zugriffes*/
  time_t st_mtime; /*Datum des letzten Aenderung*/
  time_t st_ctime; /*Erstelldatum*/
}
\end{lstlisting}
\vspace{-0.4cm}
Das Definition befindet sich im Standardbibliothek sys/stat.h.
\end{myexampleblock}
\begin{myexampleblock}{Definition: \texttt{struct passwd}}
\begin{lstlisting}
struct passwd {
 char *pw_name; /*Anwaenders login Name*/
 uid_t pw_uid; /* UID id*/
 gid_t pw_gid; /* GID id*/
 char *pw_dir; /*Login Direktory*/
 ...
}; 
\end{lstlisting}
\vspace{-0.4cm}
Das Definition befindet sich im Standardbibliothek passwd.h
\end{myexampleblock}
\begin{myexampleblock}{Definition: \texttt{struct group}}
\begin{lstlisting}
struct group {
  char *gr_name;
  gid_t gr_gid;
  char **gr_mem;
  ...
};
\end{lstlisting}
\vspace{-0.4cm}
Das Definition befindet sich im grp.h
\end{myexampleblock}
\begin{myexampleblock}{Funktion: \texttt{stat}}
\begin{lstlisting}
int stat(char * path, struct stat * buf);
\end{lstlisting}
\vspace{-.4cm}
Information erhalten über das Datein bennant als $path$. Die Informations werden im $buf$ gespeichert.
Der Rückgabewert ist 0, wenn alles geklappt hat, und -1 bei einem Fehler.
\end{myexampleblock}
Bevor wir mit einem Datein arbeiten, müssen wir sicher sein, ob wir die entsprechende Rechte haben, um ihn zu 
erstellen oder einlesen. Die Felden uid und gid in der stat Strukture geben Informationen über die Besitzer des Dateins.
Der Supervisor hat immer $(0.0)$ als ($uid,gid$). Normalweise der erste Anwänder hat 1000 uid.
Für die weitere Anwänders das uid wird um eins erhöht. 
Wir können auch das uid mit einem Anwänder's Name verbunden. Dafür gibt es zum Bespiel der $getpwuid$ Funktion 
im Standardbibliothek. Die Anwänders in den unixartigen Betriebsystemen haben außerdem ihre login Name auch eine
Group Name. Wenn in einem Computer mehrere Programmierer arbeiten, Sie werden in Gruppen verteilen, um ihre
Arbeit leicht zu teilen. Wir können das $GID$ mit einem Name mithilfe des $getgrgid$ Funktions verbunden.
Es kann nötig sein zu prüfen, ob die Datein beschädigt ist, oder nicht. 
zum Bespiel, wir können überprüfen ihre Größe. Nehmen wir an, dass wir die folgende Datei (example.txt) haben
\begin{lstlisting}{example.txt}
Hello world
\end{lstlisting}
Wir haben die folgende C Code geschrieben, um Informationen über diesen Datei erhalten:
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <pwd.h>
#include <grp.h>
#include <sys/stat.h>
int main(int argc, char *argv[])
{
   struct stat *sb;
   struct passwd *pwuser;
   struct group *grpnam;
   int i;
   if (argc < 2)
   {
       printf("Usage: %s: file ...\n", argv[0]);
       exit(EXIT_FAILURE);
   }
   sb= (struct stat *)malloc(sizeof(struct stat));
   for ( i = 1; i < argc; i++){
      if (stat(argv[i], sb) == -1){
          exit(EXIT_FAILURE);
      }
      if ( (pwuser = getpwuid(sb->st_uid)) == NULL )
      {
          exit(EXIT_FAILURE);
      }
      if ( (grpnam = getgrgid(sb->st_gid)) == NULL )
      {
          exit(EXIT_FAILURE);
      }
      printf("%s:\n", argv[i]);
      printf("\tinode: %u\n", (int)sb->st_ino);
      printf("\towner: %u (%s)\n", sb->st_uid, pwuser->pw_name);
      printf("\tgroup: %u (%s)\n", sb->st_gid, grpnam->gr_name);
      printf("\tperms: %o\n", sb->st_mode & (S_IRWXU | S_IRWXG | S_IRWXO));
      printf("\tsize: %ld\n", sb->st_size);
      printf("\tatime: %s", ctime(&(sb->st_atime)));
      printf("\tmtime: %s", ctime(&(sb->st_mtime)));
      printf("\tctime: %s", ctime(&(sb->st_ctime)));
      printf("\n");
   }
   free(sb);
   return 0;
}
\end{lstlisting}
Diesen Beispiel gibt es viele Neueigkeiten für uns. Zum ersten Mal wir verwenden die Eingabeparameters unseres 
Programms. Zur Erinnerung, der Wert vom $argc$ erhaltet die Anzahl der Parameter, und im $argv$ (Array von Pointers auf
char Typ) sind die Parameter gespeichert. Standardmäßig das erste Parameter ist das Name des Programms, dann kommen
die Parameter, die wir hinzufügen haben. In der 13-ten Zeile prüfen wir die Anzahl der eingegebenen Parameter. Wenn
wir keinen Parameter eingegeben habe, beenden wir das Programm mit einer Gebrauchanweisung. Außerdem interpretieren 
jeden Parameter als Dateiname und erhalten ihre Eigenschaften mithilfe des stat Funktion. Es ist wichtig in der 18-ten
Zeile Speicher für sb reservieren. Der Funktion $stat$ geht davon aus, dass die Adresse, die sie bekommen habe, ist
schon reserviert. In diesem Beispiel wir verwenden auch der $getpwuid$ Funktion, mit dem wir die UID mit einem login 
Name verbunden. In unix Betriebsystemen wir können verschiedene Rechten für Anwänder, Gruppe von Anwändern, und für die
Anderen. Für einem Datein gibt es Rechte für schreiben, lesen und Ausführen. Die drei können wir darstellen mit 3 bits.
In dem 35 Zeile wir ziehen der Wert von diesen bits für der Anwänder, die Gruppe des Anwänders und für die Anderen heraus.
Die Ausgabe unseres Programms ist die folgende:
\begin{lstlisting}
./a.out example.txt
example.txt:
  inode: 11931732
  owner: 1000 (pittler)
  group: 1000 (pittler)
  perms: 664
  size: 12
  atime: Fri Mar  3 12:57:38 2017
  mtime: Fri Mar  3 12:57:31 2017
  ctime: Fri Mar  3 12:57:31 2017
\end{lstlisting}
Die Größe vom Datein kann überraschend sein, weil es nur aus 11 Zeichen besteht. Aber jeden Datein enthält die 
$EOF$(Ende des Dateins) Zeichen. Mit diesem Byte die Größe des Dateins stimmt.
\subsection{Das Stream Konzept}

Obwohl die Sprache keine eingebaute Methode für Ein und Ausgabe hat, in der Standardbibliothek befindet sich
mehrere wertvollen Ein und Ausgabe Funktionen. Ein wichtiges Konzept ist das $stream$. Das $stream$ ist ein Kanal, die
eine Verbindung zwischen die Datein und deine Programm macht. Beispielweise hier Datein kann  Tastatur, 
Monitor, oder Datein auf einem Kasetten bezeichnet. In jedem Fall wir haben das gleiche Kanal.
Diese Universalität macht Ein und Ausgabe einfach zu handhaben. Zu jeden Kanalen gehören ein Pointer von FILE Typ,
mit dem wir Sie verwenden können. Der Laufzeitsystem stellt automatisch für uns drei Kanale
\begin{enumerate}
\item stdin : Standard für Eingabe 
\item stdout : Standard für Ausgabe
\item stderr : Standard für Fehler
\end{enumerate} zur Verfügung. Wir haben schon das Standard Ein und Ausgabe kennengelernt. Zur errinerung hier gibt es
eine weitere Übung:
\begin{myexampleprogram}{Programme: \texttt{Eingabe nach Ausgabe Kopieren}}
\begin{lstlisting}
#include<stdio.h>
#include<stdlib.h>
int main(){
  char c;
  while( (c=getchar()) !=EOF)
   putchar(c);
}
\end{lstlisting}
\end{myexampleprogram}
\begin{myexampleblock}{Funktion: \texttt{getchar}}
\begin{lstlisting}
int getchar ( void );
\end{lstlisting}
\vspace{-0.4cm}
Lest ein Zeichen von der Standard Eingabe. Rückgabewert ist das eingelesene Zeichen, wenn die Einlesung erfolgreich war, außerdem
EOF.
\end{myexampleblock}
\begin{myexampleblock}{Funktion: \texttt{putchar}}
\begin{lstlisting}
int putchar (char c);
\end{lstlisting}
\vspace{-0.4cm}
Drückt den Zeichen $c$ aus. Der Rückgabewert ist ein int Wert, der von unsigned char konvertiert wurde.
\end{myexampleblock}
In diesem einfachen Beispiel wir lesen die Zeichen ein bis zum Ende des Dateins in der fünften Zeile.
Im Schleifenkern wir habe nur eine Anweisung, die der eingelesene Zeichen ausdrückt. Aber in diesem Beispiel
bei der Ausführung wir müssen den Datein mit dem $<$ Operator zur Standard Eingabe ziehen. Um direkt aus
einem Datein lesen zu können, wir müssen ein Kanal zum Datein eröffnen.
\begin{myexampleblock}{Funktion: \texttt{fopen}}
\begin{lstlisting}
FILE *fopen( const char *filename, char mode);
\end{lstlisting}
\vspace{-0.4cm}
Eröffnet ein Kanal zum Datein für Verarbeitung.
\begin{itemize} 
\itemsep0.5ex
\item "w": Datei zum Schreiben erzeugen, wenn es schon existiert, wird sie überschreiben
\item "r": Öffnen einer Datei ausschließlich zum Lesen
\item "{}a": Öffnen einer Datein zum Anfügen. Wenn is nicht existiert, wird sie erzeugen.
\item "w+" Öffnen zum Schreiben und Lesen, wenn es schon existiert, wird sie überschreiben.
\item "r+" Öffnen einer Datei zum Schreiben und Lesen.
\item "{}a+" Öffnen einer Datei zum Lesen und Anfügen.
\end{itemize}
\end{myexampleblock}  
In diesem Fall können wir das $fopen$ Funktion verwenden um einer Kanal zu eröffnen. Vordem
wir mit einem Datei das Arbeit anfangen, müssen wir wissen ob es ein Binärdatei oder ein Asciidatei
ist. Ein Asciidatei ist ein Sequenz von Zeichen beenden mit $EOF$. In einem Binärdatei, wir müssen vorhand
die Strukture des Inhalts von Datei wissen. Kann mann fragen, Warum wir bei allen Binärdateien verwenden?
Das Antwort liegt in der Genauigkeit und im Speicherplatz. Wenn wir eine 8 byte größe Fließkommazahl in 
ASCII speichern würde, brauchen wir $~40$-mal mehr speichern um die gleiche Genauigkeit zu erreichen. Zuerst 
werden wir einlesen aus Einfache Asciidatei.
\begin{myexampleblock}{Funktion: \texttt{fscanf}}
\begin{lstlisting}
int fscanf(FILE *kanal,char *formattierungtext, ....);
\end{lstlisting}
Formattierte Einlesung von einer Asciidatei, interpretiert von dem formattierungtext. Der Rückgabewert ist der
Anzahl der Elemente von Argumentliste erfolgreich gefüllt. Als Arguments, wir müssen nicht der Wert der Variable geben
sondern auch ihre Adresse. Mit dem formattierungtext können wir im einzelnen Wiese einlesen.
Die White-Space zeichen im Kanal wurden nicht gelesen (Zum Beispiel: Neue Zeile, Raumtaste, Tabulatorzeichen).

Die eingelesene Datei wurden nach den Folgenden Regeln Speichern. Die generelle Form ist:
$$\%Spezificierungszeichen$$

Die eingelesene Datei wurden nach den Folgenden Regeln Speichern. 

\begin{center}
\begin{tabular}{|cc|}
\hline
Specifizierungzeichen & Bedeutung \\\hline
$\%d$	&  Einlesen ein ganze Zahl in einer $in$ Variable \\
$\%ld$  &  Einlesen ein ganze Zahl in einer $long~int$ Variable \\
$\%f,\%e$   & Einlesen ein Fließkommazahl in einer $float$ Variable \\
$\%lf,\%le$  & Einlesen ein Fließkommazahl in einer $double$ Variable \\
$\%c$  & Einlesen ein Zeichen in einer $char$ Variable \\
$\%s$  & Einlesen eine Zeichenkette in einem Charakterarray.\\
\hline
\end{tabular}
\end{center}

Die anderen Zeichen im formattierungtext wurden eingelesen, aber nicht gespeichert. 
\end{myexampleblock}
Zum Beispiel wir möchten die Zahlen von diesem Asciidatei einlesen.
\begin{lstlisting}
1212
        1222
999             12212
888
\end{lstlisting}
Wir müssen nicht achten auf die ``white space'' Zeichen, wir können Sie einfach vergessen.
Im unteren Quelltext wir zeigen, wie es funkzioinert in der Praxis.
\begin{lstlisting}
#include<stdio.h>
#include<stdlib.h>
#include<errno.h>
int main(int argc, char *argv[]){
  FILE *in;
  int d;
  if (argc>2){
   fprintf(stderr,"Useage: ./read_int_ascii filename\n");
   exit(1);
  }
  in=fopen(argv[1], "r");
  if (in == NULL){
   fprintf(stderr, "Error opening the file %d\n", errno);
   exit(1);
  }
  while( fscanf(in, "%d", &d) == 1 ){
    printf("%d\n");
  }
  fclose(in);
}
\end{lstlisting}
Zuerst wir öffnen ein Kanal für einlesen mit dem $fopen$ Fuktion in der 11-ten Zeile. Wir müssen 
der Rückgabewert vom $fopen$ überprüfen um Fehler zu vermeiden. Wenn die Rückgabewert ist das 
$NULL$ Pointer wir haben irgendeine Fehler. Hier verwenden wir das $errno$ Systemumgebungsvariable.
Wenn die Standardbibliothek Funktionen Fehler zurückgeben, sie auch weisen den Typ des Fehlers aus mithilfe
der $errno$ Variable. Es gibt Tabellen, die für jede Wert von $errno$ Variable den Fehler zeigen.
Nachdem wir den Datei erfolgreich geöffnet haben, fangen wir das Einlesen an. Wir lesen 
ganze Zahlen bis zum Ende des Datein (Zeile 16). Nachdem Einlesen wir brauchen den Kanal nicht mehr. 
Zum ende muss die Kanal freigegeben werden (Zeile 19). Die Ausgabe nachhdem Ausführung siehst du unter.
\begin{lstlisting}
1212
1222
999
12212
 88
\end{lstlisting}
Das beweist, dass das Ergebnis unabhänging von den ``white space'' Zeichen ist. Jetzt wir können Einlesen, 
wir möchten auch neuen Datein erzeugen. Formattierte Ausgabe in einem Datei ist wie die Eingabe. Wir können 
der $fprintf$ Fuktion aus dem Standardbibliothek verwenden.
\begin{myexampleblock}{Funktion: \texttt{fprintf}}
\begin{lstlisting}
int fprintf(FILE *kanal,char *formattierungtext, ....);
\end{lstlisting}
Formattierte Ausgabe in einer Asciidatei, interpretiert von dem formattierungtext. Der Rückgabewert ist der
Anzahl der ausgegebenen Zeichen. Als Arguments, wir müssen der Wert der Variable geben
nicht ihre Adresse. Mit dem formattierungtext können wir im einzelnen Wiese ausdrücken.

Die ausgebende Datei wurden ähnlich wie im $fscanf$ verarbeiten. Die generelle Form ist:
$$\%Spezificierungszeichen$$
{
\begin{center}
\begin{tabular}{|cc|}
\hline
Specifizierungzeichen & Bedeutung \\\hline
$\%d$   &  Ausgeben ein ganze Zahl \\
$\%f,\%e$   & Ausgeben ein Fließkommazahl  \\
$\%c$  & Ausgeben ein Zeichen  \\
$\%s$  & Ausgeben eine Zeichenkette\\
\hline
\end{tabular}
\end{center}
}
Im $fprintf$ wir können mit $\%f$ entweder der Wert von einem $float$ oder $double$ Fließkommazahl
ausdrücken.
\end{myexampleblock}
Beispielweise, drücken wir das Quadrat der Zahlen von 0 bis 100 immer, sodass alle Zeilen werden
aus 6 Zeichen bestehen.
\begin{lstlisting}
#include<stdio.h>
#include<stdlib.h>
#include<errno.h>
int main(){
  FILE *out;
  int i;
  out=fopen("quadrats.txt", "w");
  if (out == NULL){
   fprintf(stderr, "Error opening the file %d\n", errno);
   exit(1);
  }
  for (i=1;i<=100;++i){
    fprintf(out,"%.6d\n",i*i);
  }
  fclose(out);
}
\end{lstlisting}
In diesem Fall wir öffnen der Datei zum Schreiben (Zeile 7). Wir drücken 
die Quadrats mit dem $fprintf$ Fuktion zum Kanal aus. In der C Sprache wir 
können einstellen, wieviele Ziechen wir in der Ausdrückung verwenden möchten. 
Mit der Anweisung $\%x.yd$ die Ausdrückung beginnt im $x$-ten Zeichen, und 
verwendet mindesten $y$ zeichen. Mit dem $\%.6d$ jede Quadrat wird ergänzt mit $0$
um 6 Zeichen zuverwenden. Die ersten Zeilen des Ergebnis befindest du unter:
\begin{lstlisting}
000001
000004
000009
000016
000025
000036
000049
000064
000081
\end{lstlisting}
Es macht sinn in einem Großen Projekt die Parameters in einem Asciidatei ausdrücken, aber
das Ergebnis muss in Binärdatei gespeichert werden. Dafür stellen wir hier vor, wie 
mann binäredatei in C handeln kann. Das großte Unterschied zwischen Binäre and Asciidatei
ist, dass wir der Binäredatei mit einem einfachen Editor nicht anschauen können. Wir müssen uns
errinern in welchen Form wieviele Datei wir in einem Binärdatei geschrieben haben. Für ein einfaches 
Einlesen oder Ausgaben wir können die Funktionen ($fread$ und $fwrite$) verwenden. Wenn wir nicht nur
Schreiben sondern auch Einlesen möchten, müssen wir der Kanal auch positionieren.  Beispielweise
wir möchten die Festpalette als Memory verwenden: zuerst schreiben wir etwas aus, danach möchten
wir diese Datei verwenden. In diesem Fall wir können der Kanal mit dem $rewind()$ oder $fseek()$ Funktion
positionieren.
\begin{myexampleblock}{Funktion: \texttt{fread}}
\begin{lstlisting}
size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );
\end{lstlisting}
\vspace{-0.4cm}
Lest aus einem Binärdatei. Der Rückgabewert ist die Größe der eingelesene Datei.\\
Die Parameters:
\begin{enumerate}
\item $ptr$: Anfangadresse, wo die eingelesene Datei gespeichert wird
\item $size$: Größe einer eingelesenen Einheit
\item $count$: Anzahl der eingelesenen Einheiten
\item $stream$: Pointer zum Kanal
\end{enumerate}
\end{myexampleblock}
\begin{myexampleblock}{Funktion: \texttt{fwrite}}
\begin{lstlisting}
size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream );
\end{lstlisting}
\vspace{-0.4cm}
Schreibt in einem Binärdatei. Rückgabewert ist die Größe, der ausgeschrienen
Datei.\\ Die Parameters:
\begin{itemize}
\item Quelladresse von den ausschreibenden Datei 
\item Größe einer ausschreibenden Einheit
\item Anzahl der ausschreibenden Einheiten
\item Pointer Zum Kanal
\end{itemize}
\end{myexampleblock}
\begin{myexampleblock}{Funktion: \texttt{rewind}}
\begin{lstlisting}
void rewind(FILE *stream)
\end{lstlisting}
\vspace{-0.4cm}
Positioniert der Kanal auf dem Anfang des Binärdateis.
\end{myexampleblock}
\begin{myexampleblock}{Funktion: \texttt{fseek}}
\begin{lstlisting}
int fseek(FILE *stream, long int offset, int whence)
\end{lstlisting}
\vspace{-0.4cm}
Positioniert der Kanal auf einem specific Position in dem 
Binärdatei. Rückgabewert ist 0, wenn die Positionierung erfolgreich war.
\begin{enumerate}
\item stream: Der Kanal
\item offset: Versatz
\item whence: Die Position, zur die Versatz hinzufügen wird
\end{enumerate}
\end{myexampleblock}
Unter wir geben ein Beispiel für die Verwendung der Funktions $fread$ und $fwrite$.
\begin{lstlisting}
#include<stdio.h>
#include<stdlib.h>
int main(){
   FILE *kanal;
   int *squares;
   int i;
   int n=100;
   kanal=fopen("temporarystorage", "w+");
   if (kanal == NULL){
     fprintf(stderr, "Error in opening the file\n");
     exit(1);
   }
   squares=(int *)malloc(sizeof(int)*n);
   if (squares == NULL){
     fprintf(stderr, "Error in allocating memory\n");
     exit(1);
   }
   for (i=0; i<n; ++i)
     squares[i]=(i+1)*(i+1);
   fwrite(squares, sizeof(int), n, kanal);
   for (i=0; i<n; ++i)
     squares[i]=0;
   rewind(kanal); 
   fread (squares, sizeof(int), n, kanal);
   for (i=0; i<n; ++i)
    printf("%d\n", squares[i]);
   fclose(kanal);
}   
\end{lstlisting}
Wir öffnen der Kanal nicht nur für Einlesen, sondern auch für Schreiben (Zeile 8). Achtung, wenn $temporarystorage$ 
Datei schon exisitiert, dann ihre Inhalt wird gelöscht. Wir reservieren Speicherzellen für 100 Variable von $int$ Typ (Zeile 13).
Danach wir speichern die Quadrats von den ersten hundert ganze Zahlen in diesem Array, und schreiben wir in den 
Binärdatei. Denn wir postionieren den Kanal wieder auf das Anfang des Datein um  die gespeichert Date einzulesen (Ziele 24).
In diesem Fall müssen wir Auch der Kanal freigeben.
\section{Verketette Liste, der Kellerspeicher und die Warteschlange}
Wir haben gelernt, wie wir die Memoryverwaltung verwenden können. Aber was passiert, wenn wir ein Element löschen wollten, oder
wir nochein zwischen zwei schon existiert Elementen hinzufügen möchten. In anderen Worten, wir möchten ein Dateistrukture, das
dynamisch erhöht, oder schrumpft. Das können wir ausführen mit einer Strukture, die die Adresse des nächsten Elements enthält.
Beispielweise in der C Sprache ein Struktureelement kann auch ein Pointer auf den nächsten Element sein.
\begin{lstlisting}
struct list{
  int element;
  struct list *nachste;
}
\end{lstlisting}
\begin{figure}[!ht]
% Generated with LaTeXDraw 2.0.8
% Sun Mar 05 19:02:52 CET 2017
% \usepackage[usenames,dvipsnames]{pstricks}
% \usepackage{epsfig}
% \usepackage{pst-grad} % For gradients
% \usepackage{pst-plot} % For axes
\scalebox{1} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,0.)(16.0,4.)
\psframe[linewidth=0.04,dimen=outer](3.,1)(0.0,3.0)
\rput(1.2, 2.5){element: 4}
\rput(1.2, 2.0){nachste:} 
\rput(1.2, 1.5){0x1b464c0}
\rput(1.5, 0.5){Adresse: 0x1b464a0} 

\psline[linewidth=0.04cm](3.5,2.)(4.5,2.)
\psline[linewidth=0.04cm](4.25,2.5)(4.5,2)
\psline[linewidth=0.04cm](4.25,1.5)(4.5,2)
\psframe[linewidth=0.04,dimen=outer](8.,1)(5.0,3.0)
\rput(6.2, 2.5){element: 6}
\rput(6.2, 2.0){nachste:}
\rput(6.2, 1.5){0x1b46480}
\rput(6.2, 0.5){0x1b464c0}
\psline[linewidth=0.04cm](8.5,2.)(9.5,2.)
\psline[linewidth=0.04cm](9.25,2.5)(9.5,2)
\psline[linewidth=0.04cm](9.25,1.5)(9.5,2)

\psframe[linewidth=0.04,dimen=outer](13.,1)(10.0,3.0)
\rput(11.2, 2.5){element: 6}
\rput(11.2, 2.0){nachste:}
\rput(11.2, 1.5){NULL}
\rput(11.2, 0.5){0x1b46480}
\psline[linewidth=0.04cm](13.,2.)(14.,2.)
\psline[linewidth=0.04cm](13.75,2.5)(14.,2)
\psline[linewidth=0.04cm](13.75,1.5)(14.,2)
\rput(15, 2.){\LARGE NULL}
\end{pspicture} 
}
\caption{Einmal Verketette Liste\label{verklist}}
\end{figure}
In der Abbildung \ref{verklist} wir zeigen, wie es in der Praxis
funkzioniert. Wir werden den NULL pointer für das Ende der verketetten
Liste verwenden. Viele wichtigen Datenstukturen können mit 
verketetten Listen darstellen. Beispielweise den Stapelspeicher.
In Assembly Programmiersprache beim Funktionanrufen die Parameters werden 
zum Stapelspeicher gestellt. Wenn wir kommen von einem Funktion zurück, 
wir nehmen ein Element vom Stapelspeicher aus. Das Grundprinzip im
Stapelspeicher ist: Den zuletzt gespeicherten Element werden wir zuerst
zurückgeben. Wir zeigen es in der Abbildung \ref{stapspeicher}.
\begin{figure}[!ht]
\begin{center}
% Generated with LaTeXDraw 2.0.8
% Sun Mar 05 20:17:29 CET 2017
% \usepackage[usenames,dvipsnames]{pstricks}
% \usepackage{epsfig}
% \usepackage{pst-grad} % For gradients
% \usepackage{pst-plot} % For axes
\scalebox{0.7} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-3)(12.0,3)
\psframe[linewidth=0.04,dimen=outer](3,3)(0.0,2)
\psframe[linewidth=0.04,dimen=outer](11.0,3)(8,2)
\pscustom[linewidth=0.04]
{
\newpath
\moveto(3.1,2.5)
%\lineto(7.5,1.5)
\curveto(3.3,2.5)(3.5,2.4)(4.5,1.7)
}
\rput(3.7, 2.8){\LARGE push}
\psline[linewidth=0.04cm](4.55,1.9)(4.5,1.7)
\psline[linewidth=0.04cm](4.4,1.6)(4.5,1.7)


\pscustom[linewidth=0.04]
{
\newpath
\moveto(7.5,2.5)
%\lineto(7.5,1.5)
\curveto(7.5,2.5)(6.8,2.5)(6.5,1.6)
}
\rput(6.7, 2.8){\LARGE pop}
\psline[linewidth=0.04cm](7.4,2.7)(7.5,2.5)
\psline[linewidth=0.04cm](7.4,2.3)(7.5,2.5)


\psframe[linewidth=0.04,dimen=outer](7,1.5)(4,0.5)
\psframe[linewidth=0.04,dimen=outer](7,0.2)(4,-0.8)
\psframe[linewidth=0.04,dimen=outer](7,-1.1)(4,-2.1)
\end{pspicture} 
}
\caption{Der Stapelspeicher\label{stapspeicher}}
\end{center}
\end{figure}

Wir werden jetzt implementieren diesen wichtigen Datenstruktur mit 
den verketetten Listen. Zuerst stellen wir der Datenstruktur, den wir verwenden
vor:
\begin{lstlisting}
typedef struct list {
   struct list* next;
   int data;
} list;
\end{lstlisting}
Das ist natürlich eine verketette Liste. Aber wir haben hier diesen Typ also definiert
mit dem Strichwort $typedef$.
\begin{myexampleblock}{Strichwort: \texttt{typedef}}
\begin{lstlisting}
typedef neuename altename;
\end{lstlisting}
\vspace{-0.4cm}
Stellt ein neues Name ($neuename$) für den Typ von $altename$ her.
\end{myexampleblock}
Der größte Vorteil in diesem Fall ist, dass wir den Strichwort $struct$ 
vor allen Variable definition verwenden müssen. Der Quelltext wird durchsichtiger
sein. Jetzt wir haben das Definition der Datenstrukture, wir können die Implementierung
anfangen. Zuerst besprechen wir, wie können wir eine neue Stapelelement herstellen.
Wie können wir eine neue Variable von Typ $list$ herstellen.
\begin{lstlisting}
list * get_a_list( int x ){
   list *q=(list *)malloc(sizeof(list));
   if (q == NULL){
     fprintf(stderr, "Error in Memory allocation\n");
     exit(1);
   }
   q->data=x;
   q->next=NULL;
   return q;
}
\end{lstlisting}
Der obene Codeteil gib eine $list$ Element zurück und hat die
speichernde ganze Zahl als Eingabeparameter. Dieser Teil ist ganz einfach.
Wir reservieren Speicherzellen für den neuen Listelement und zuweisen
den Eingabewert. Zum Ende wir müssen die nächste Element als ein NULL 
Pointer festlegen. Die nächste Teil ist das push() Funktion. Speichern 
ein Element im Stapelspeicher.
\begin{lstlisting}
void push( int x, list ** first){
   if ((*first) == NULL){
       (*first)=get_a_list(x);
       return;
   }
   list *temp=get_a_list(x);
   temp->next=(*first);
   (*first)=temp;
}
\end{lstlisting}
Wir müssen die Adresse von dem Pointer auf den Anfang des Speichers  und den speichernde 
Element abgeben. Wenn den List leer ist, wir legen die Anfangsadresse mit der adresse 
des  neuen Elements fest. In anderem Fall wir legen den next Pointer von dem neuen Element 
mit dem originalle Anfangsadresse und die neue Anfangsadresse wird die Adresse vom neuen Element 
sein. Darum müssen wir nicht die Anfangsadresse als Parameter abgeben, sondern ihre Adresse,
weil wir den Wert von ihm im Funktion ändern wollen. Den logischen nächsten Schritt
ist die implementierung des $pop$ Funktions. Der Rückgabewert muss den letzten gespeicherte
Element sein. Der Eingabeparameter muss den Anfangsadresse den Stapelspeicher sein.
\begin{lstlisting}
int pop( list **first){
   list *temp;
   int ret;
   if ((*first) == NULL){
     printf("Es gibt kein Element im Speicher\n");
     return 0;
   }
   ret=(*first)->data;
   temp=(*first)->next;
   free(*first);
   (*first)=temp;
   return ret;
}
\end{lstlisting}
Wenn das Stapelspeicher leer war, wir werden eine Nachricht ausdrücken. 
Im anderen Fall wir legen den Rückgabewert mit dem Wert von dem ersten 
Element fest. Wir müssen auch die ersten Element freigeben, und die neue
Anfangsadresse mit dem nächste der originalen festlegen.

Wir können auch prüfen die aktuellen Inhalt des Speichers. 
Dafür müssen wir einer Funktion, der dursch die Listelementen geht
schreiben.
\begin{lstlisting}
void print_list( list *first){
   list *temp=(first);
   if (temp == NULL)
      return;
   for (;;){
      printf("%d\t", temp->data);
      temp=temp->next;
      if (temp == NULL)
        break;
   }
   printf("\n");
}
\end{lstlisting}
Dieser Funktion zuerst prüft ob der Speicher leer ist. Wenn der
Speicher nicht leer ist, wir machen eine Schleife um durch die
Listelementen gehen. In jeden iteration wir springer zur 
nächsten Element (Zeile 7). Wenn wir am Ende des Speichers
sind, beenden wir die Schleife.

Es fehlt jetzt nur noch ein Gebrauchanweisung für unseren Stapelspeichern.
Dies wird der $main$ Funktion.
\begin{lstlisting}
int main(){
   list *erste=NULL;
   push(2, &erste);  print_list(erste);
   push(4, &erste);  print_list(erste);
   push(6, &erste);  print_list(erste);
   pop( &erste );    print_list(erste);
   push(8, &erste);  print_list(erste);
   pop( &erste );    print_list(erste);
}
\end{lstlisting}
Wir definieren zuerst einer Pointer um die 
Anfangsadresse des Speichers zu speichern (Zeile 2). Dann wir machen eine
Folgen aus push und pop Anweisungen, und im jeden Schritt wir drücken
den aktuellen Zustand des Speichers aus. Die Ausgebe siehst du unter.
\begin{lstlisting}
2	
4	2	
6	4	2	
4	2	
8	4	2	
4	2	
\end{lstlisting}
Wie du siehst, wenn wir die erste $pop$ Anweisung ausführen, wurde die letzte 
eingegebene Wert (6) aus dem Speicher gelöst. 

\include{endprojekt}

%as Körper, das C code kannst du oben sehen. Alle C programm besteht aus Funkcionen. Wir nennen function ein part of the code, was eine
%estimmte aufgabe erledigt.
%u wirst es gleich finden, dass du muss zuerst lernenDu musst zuerst den einladen, was jemanden
%eschrieben hat. Zum beispiel, zu computer printen du sollst stdio.h einladen. Sie
%ehören nicht zu den sprache . Danach kommt deine arbeite. Zuerst du sollst andenken was für ein ergebnis deine aufgabe haben soll und
%ie viele eingangsparameter deine programm hat. Du sollst denen es variablen deklarieren. Jetzt kommt die wichtigsten Teil des Program, die
%unktionen. Diese teil rechnet aus den eingangsparameter deine Ergebnis. Es gibt ein specielle function was jeden programm haben
%oll. Das nahme of diese funcktion ist main. Von diesem Punkt beginnt die Ausführung. Wir werden mehr um funckcionen später lernen. 

%Im fünften Linie illustrieren wir, dass das Name der Variable nicht mit einem Zahl beginnin darf. Eine practical Beratung ist initializerien
%alle Variables recht im Definition. 
%enn zwei operatoren gleichem Prioriät haben, dann zum ersten mal der linkste wird verarbeitet, and danach 
%on links nach rechts\footnote{Hier gibt es ausnahme, wenn die Reihenfolge ist umgekehrt. Siehst denn letzten Spalte im Tablellen \ref{priortab}}. 


%\begin{lstlisting}{Einf\"ugesortieren in C: Körper }
%#include<stdio.h>
%void read_in_data( int n, int sort[], int unsort[], int argc, char *argv[]){
%statements a1;
%statements b1;
%...
%}
%void einfugesortieren( int n, int sort[], int unsort[]){
%statements a2;
%statements b2;
%...
%}
%void print_out_data( int n, sortiert){
%statements a3;
%statements b3;
%...
%}
%int main( int argc, char *argv[])
%{
%  int n=4;
%  int sortiert[n];
%  int unsortiert[n];
%  read_in_data(n, sortiert, unsortier, argc, argv);
%  einfugesortieren(n,  sortiert, unsortiert);
%  print_out_data( n, sortiert);
%
%}
%\end{lstlisting}
%Das Körper, das C code kannst du oben sehen. Alle C programm besteht aus Funkcionen. Wir nennen function ein part of the code, was eine
%bestimmte aufgabe erledigt. 
%Du wirst es gleich finden, dass du muss zuerst lernenDu musst zuerst den einladen, was jemanden
%geschrieben hat. Zum beispiel, zu computer printen du sollst stdio.h einladen. Sie
%gehören nicht zu den sprache. Danach kommt deine arbeite. Zuerst du sollst andenken was für ein ergebnis deine aufgabe haben soll und
%wie viele eingangsparameter deine programm hat. Du sollst denen es variablen deklarieren. Jetzt kommt die wichtigsten Teil des Program, die
%Funktionen. Diese teil rechnet aus den eingangsparameter deine Ergebnis. Es gibt ein specielle function was jeden programm haben
%soll. Das nahme of diese funcktion ist main. Von diesem Punkt beginnt die Ausführung. Wir werden mehr um funckcionen später lernen.
 

%Zum beispiel in C sieht die obene Auflistung so aus:
%\begin{lstlisting}{Einf\"ugesortieren in C}{
%1: int n=4;
%   int unsortiert[n],  sortiert[n];
%2; sortiert[0]=2;
%3; unsortiert[0]=9; 
%   unsortiert[1]=5;
%   unsortiert[2]=7;
%4; for (int i=1; i<n-1;++i){
%      sortiert[length]=unsortiert[i]
%5-6;   for (int j=length-1; j>0; --j){
%         if (sortiert[j+1]<sortiert[j]){
%            int tmp=sortiert[j];
%            sortiert[j]=sortiert[j+1];
%            sortiert[j+1]=tmp;
%         }
%         else{
%          break;
%         }
%      }
%      length++;
%   }
%}
%\end{lstlisting}
%''for`` steht f\"ur Schleife und wir nutzten das "A" array 
%Warum solltest du C programmier sprache lernen? Es gibt viele Antwort auf diese Frage. Zum Beispiel:
%\begin{itemize}
%\item C ist nicht kompliziert
%\item C ist sehr effizient
%\item C hat high level konstrukte
%\end{itemize}
%Aber M\"oglicherweise das beste Antwort ist das C Kenntnisse ist unbedingt in Forschungsrechnungen. Die meisten Programme,
%der zum Stand der Technik geh\"oren sind C programme. In diesem Kurz wir werden diese Sprache kennenlernen. Zuerst 
%wir zusammenfasseen was in der Sprache inbegriffen ist. Du wirst dich verwundern, das die einfachste funktion, was
%nur etwas auf deinem Monitor zeigt, geh\"ort nicht zu der Sprache. Wir vorstellen das k\"orper einem durchschnittlichen
%C program und erkl\"aren sein Teilen. 

%Danach z\"ahlen wir die Komponenten der Sprache auf. Das wird beginnen mit der data Typen und Operationen, in denen wir 
%die Typen nutzen k\"onnen. Wir werden alle elementare Data type lernen. Mit Variablen aus diesen Typen k\"onnen wir Operationen machen, 
%die unsere Ergebnisse herstellen werden. Dann werden wir elementare Statements und Expressions einf\"uhren, mit denen 
%wir kleinen Aufgaben l\"osen k\"onnen. 
  
%Es is sehr wichtig, dass unsere Programm Parameter erhalten zu k\"onnen. Wir k\"onnen das erreichen durch Funkcionen.
%Die Funkcionen arbeiten wie schwarze K\"asten. Sie stellen von den Eingangsparameter ein neues Wert her. Wir zeigen, 
%wie man die Standart Eingabe und Ausgabe Bibliothek nutzten kann. Nachdem wir diese F\"ahigkeiten verstehen, werden wir etwas
%komplizierte \"Ubungen schreiben.

%Often gibt es Situationen in den wir mehr als Ein ergebnisse von einem Funktionen wollen. Um das erreichen
%m\"ussen wir die Addressirung der Memorie kennen zu lernen. In diesem Punkt werden wir auch lernen, wie man 
%strings verwendet kann.
%
%In einem sch\"onen Programm wir nutzten das wenigstens Speicher. In diesem Punkt wir werden lernen, 
%wie die Speicherverwaltung behandelt wird.

%Im ersten Teil des Kurses wir haben die elemetare datatypen kennen gelernt. In diesem Punkt wir
%werden lernen, wie mann eigenes Daten Structure herstellen kann. Überhaupt, Warum and Wenn müssen wir neue Structure herstellen.
%Unser Programm mit eigenen Daten strukturen wird leichter lesen zu können. Das ist sehr wichtig. Typischer fehler der Angefangenen Programmern
%ist, dass ihr Code ist sehr schwer zu lesen auch für Sie, und nach einem Monat Sie müssen die ganze Programm
%wieder schreiben. Zum beispiel muss mann eigenes Datenstrukture nutzen, wenn man ein operations sehr often erledigen muss.
%Zum bespiel in der Sorierung eines List, man kann die Daten in einem binären Suchbaum einschließen um die suchen schneller zu lassen.

%\section{Der Körper des C programms}

%\begin{lstlisting}{caption= Do nothing}
%#include<stdio.h>
%int main( int argv, char *argv[])
%{
%/* do nothing */
%}
%\end{lstlisting}
%Welche Teile hat ein C programm. 
%Du wirst es gleich finden, dass du muss zuerst lernenDu musst zuerst den einladen, was jemanden 
%geschrieben hat. Zum beispiel, zu computer printen du sollst stdio.h einladen. Sie
%gehören nicht zu den sprache . Danach kommt deine arbeite. Zuerst du sollst andenken was für ein ergebnis deine aufgabe haben soll und
%wie viele eingangsparameter deine programm hat. Du sollst denen es variablen deklarieren. Jetzt kommt die wichtigsten Teil des Program, die
%Funktionen. Diese teil rechnet aus den eingangsparameter deine Ergebnis. Es gibt ein specielle function was jeden programm haben
%soll. Das nahme of diese funcktion ist main. Von diesem Punkt beginnt die Ausführung. Wir werden mehr um funckcionen später lernen.  
%\section{Was ist Programmieren}
%Es gibt ein Problem, Sie müssen die Lösung finden. What we call input variables? What are the output variables? Specific problem?
%\section{Definitionen, Statements}
%Die Variablen haben Wert und Typ. Warum ist das Typ der Variable wichtig? Es hängt vom Typ ab, was für ein Wert eine Variable haben
%kann. Das Typ entscheid also die Grösse des Arbeitspeicher zu deine Variable. Mann kann nun solche Funkcionen und Operatoren nutzen, das 
%genanue Datentype hat. Es gibt elementare data Typen mit dem wir spielen können. Sie sind
%\begin{itemize}
%\item char
%\item int
%\item float
%\item double
%\end{itemize}
%Im char können wir eine character speichern(die bereich?). Größe, im können wir ein Ganzzeil spiechern von wert 0 bis 2**32-1 größe. 
%Im fließkommazahl von bis speichern grösse.
%\subsection{Mein erstes C programm}
%von linein bis linien wir erklären Einfachste Programm der Welt "Hello World.c"
%Ein bisschen schwerer aufgabe, sie müssen ausrechnen die Würzel einer quadratische Gleichung. 
%\section{Aufgaben}
%\subsection{Zufallszahlgenerator}
%Zufällige nummer sind sehr wichtig für uns. In numerischen physik wir nutzten Zufallszahlen ganz often. Zum Beispiel 
%in die einfachsten method für integration of mehreren variablen Funkctions müssen wir Monte Carlo algorithm nutzten. Die
%enthalten statements, die vom Werte auf Zufällige variablen abhängt. In dieser Aufgabe wir müssen eine Zufallszahlgenerator
%schreiben. Es gibt mehrere methode dazu, aber alle stammt aus linear Kongruenzen:
%\begin{equation}
%I_{j+1}=a I_{j} \left( \mathrm{mod} m\right).
%\label{basics}
%\end{equation}
%Diesen Instruktion macht eine neue Zufallszahl ($I_{j+1}$)  aus einem original ($I_j$). Der qualität der Zufallszahl generator
%hängt von dem eingangsparameters (a,m) ab. Eine gute Zufallszahlgenerator hat große period, die Zeit zwischen den beiden gleichen
%Zufallszahl muss sehr groß sein. Park und Miller hat die folgenden parameter für a und m gewählt:
%\begin{equation}
%a=16807, m=2^{31}-1=2147483647. 
%\end{equation}
%Leider direkte implementation der Zufallszahlgenerator mit deisen parameters ist nicht möglich in C. Der grund ist
%wir können nicht speichern Zahlen grossen als $m$. Zum glück gibt es eine möglichkeit das Problem umzugehen. 
%Wir faktorizieren $m$:
%\begin{equation}
%m= aq + r; r= m \left(\mathrm{mod}a\right); q= \left[m/a\right]
%\end{equation}
%Damit können wir Gleichung \ref{basics} auch bewerten mit ($q,r$):
%\begin{equation}
%a I_j \left( \mathrm{mod} m\right)=  
%\left\{ \begin{array}{rc}
%a\left(I_j \mathrm{mod} q\right) -r \left[I_j/q\right] & \mathrm{wenn~es~}>0\mathrm{ist} \\ 
%a\left(I_j \mathrm{mod} q\right) -r \left[I_j/q\right] + m & \mathrm{andernfalls} \\ 
%\end{array}\right.
%\label{algo}
%\end{equation}
%wo $r=2836,q=127773$ ist. Implementieren Sie das Zufallszahlgenerator nach eq.\ref{algo}. Ändern Sie die Algorithm
%um die Zahlen zwischen 0 und 1 zu sein werden.
%Es ist wichtig zu test unser Ergebnis. Wir müssen kontrollieren die Verteilung (Distribution) der Zufallszahlgenerator.
%Wir möchten gleichmäßige vertailung zu erreichen. Wir werden eine Histogramms machen aus dem Zufallszahlen. Wir teilen 
%das Interval in $n$ Teilen und zahlen wie oft die Zufallszahl in jedem Interval sinkt. Machen Sie ein Histogramm aus 
%den Verfügbaren daten und prüfen wie gleichmäßig der Verteilung ist!
%\section{Elementare operatoren}
%\subsection{Binäre, Aritmethic operatoren}
%+,-,*,/, \%, ++, -- 
%\subsection{Gleichungen}
%==,!=, >,<, >=,<=
%\subsection{Bitwise}
%\&,|,\^, ~, >>,<<
%\subsection{Zuweisungsoperator}
%=,+=,-=,|=,\&=,\^=,\%=,<<|,>>|,
%\subsection{Aufgaben}
%Programm rechnet die Wurzel, der gleichung
%\section{statements}
%\subsection{Schleifen}
%Was ist wichtig, wenn wir ein Schleifen plan? Wir müssen nicht überschreiben eine existierte variable. Wir müssen keine
%statements haben, was nicht von der Schleifenzahlnummer abhängt.
%\subsection{If then else}
%\subsection{case}
%\subsection{Standard input, output}
%\subsection{Conways Spiel des Lebens}
%Wir habe eine quadrate Gitter. In alle Zell der Gitter eine zwei hältige variable. Es sagte uns, wenn der
%kleine microbe im Zell, lebt oder nicht.
%\section{Funkcionen}
%\section{Addressierung}
%\subsection{Stackel(LIFO)}
%\subsection{Fifo}
%\subsection{Umgekehrte Polnische Notation}
%\section{Dynamische speicherverwaltung}
%\section{Daten strukturen}
%\subsection{Ketten listen}
%\subsection{Bäumen}
%\subsection{Recursive functionen, Schnell sortieren}
\end{document}
