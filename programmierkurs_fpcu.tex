\documentclass{article}[12pt]
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

\usepackage[dvipsnames]{xcolor}
\usepackage{lipsum}

\usepackage{amsfonts}
\usepackage[intlimits]{amsmath}
\usepackage{cite}
\usepackage{epsfig}

\usepackage[usenames,dvipsnames]{pstricks}
\usepackage{pstricks-add}
\usepackage{epsfig}
\usepackage{pst-grad} % For gradients
\usepackage{pst-plot} % For axes

\addtolength{\hoffset}{-1.5cm}
\addtolength{\textwidth}{3cm}
\usepackage{listings}
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\PassOptionsToPackage{svgnames}{xcolor}
\usepackage{tcolorbox}
\usepackage{lipsum}
\tcbuselibrary{skins,breakable}
\usetikzlibrary{shadings,shadows}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=C,                      % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}


\newenvironment{myexampleblock}[1]{%
    \tcolorbox[beamer,%
    noparskip,breakable,
    colback=White,colframe=ForestGreen,%
    colbacklower=LimeGreen!75!White,%
    title=#1]}%
    {\endtcolorbox}

\newenvironment{myalertblock}[1]{%
    \tcolorbox[beamer,%
    noparskip,breakable,
    colback=White,colframe=Bittersweet,%
    colbacklower=Peach!75!White,%
    title=#1]}%
    {\endtcolorbox}

\newenvironment{myblock}[1]{%
    \tcolorbox[beamer,%
    noparskip,breakable,
    colback=White,colframe=RoyalBlue,%
    colbacklower=TealBlue!75!White,%
    title=#1]}%
    {\endtcolorbox}

\newenvironment{myexampleprogram}[1]{%
    \tcolorbox[beamer,%
    noparskip,breakable,
    colback=White,colframe=Goldenrod,%
    colbacklower=Yellow!75!White,%
    title=#1]}%
    {\endtcolorbox}
%--------
%\usepackage[magyar]{babel}
\title{C Programmierkurs}
\begin{document}
\maketitle
\include{intro}
%In einem sch\"onen Programm wir nutzten das wenigstens Speicher. In diesem Punkt wir werden lernen,
%wie die Speicherverwaltung behandelt wird.

%Im ersten Teil des Kurses wir haben die elemetare datatypen kennen gelernt. In diesem Punkt wir
%werden lernen, wie mann eigenes Daten Structure herstellen kann. Überhaupt, Warum and Wenn müssen wir neue Structure herstellen.
%Unser Programm mit eigenen Daten strukturen wird leichter lesen zu können. Das ist sehr wichtig. Typischer fehler der Angefangenen Programmern
%ist, dass ihr Code ist sehr schwer zu lesen auch für Sie, und nach einem Monat Sie müssen die ganze Programm
%wieder schreiben. Zum beispiel muss mann eigenes Datenstrukture nutzen, wenn man ein operations sehr often erledigen muss.
%Zum bespiel in der Sorierung eines List, man kann die Daten in einem binären Suchbaum einschließen um die suchen schneller zu lassen.
\include{speichernausdrucken}
\include{variablen}
\include{kontrollstrukturen}
\include{pointersarrays}
\include{einfuegesortieren}
\include{dynamischespeicherverwaltung}
\include{complexdatatypen}
\include{dateinverarbeitung}
\section{Verketette Liste, der Kellerspeicher und die Warteschlange}
Wir haben gelernt, wie wir die Memoryverwaltung verwenden können. Aber was passiert, wenn wir ein Element löschen wollten, oder
wir nochein zwischen zwei schon existiert Elementen hinzufügen möchten. In anderen Worten, wir möchten ein Dateistrukture, das
dynamisch erhöht, oder schrumpft. Das können wir ausführen mit einer Strukture, die die Adresse des nächsten Elements enthält.
Beispielweise in der C Sprache ein Struktureelement kann auch ein Pointer auf den nächsten Element sein.
\begin{lstlisting}
struct list{
  int element;
  struct list *nachste;
}
\end{lstlisting}
\begin{figure}[!ht]
% Generated with LaTeXDraw 2.0.8
% Sun Mar 05 19:02:52 CET 2017
% \usepackage[usenames,dvipsnames]{pstricks}
% \usepackage{epsfig}
% \usepackage{pst-grad} % For gradients
% \usepackage{pst-plot} % For axes
\scalebox{1} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,0.)(16.0,4.)
\psframe[linewidth=0.04,dimen=outer](3.,1)(0.0,3.0)
\rput(1.2, 2.5){element: 4}
\rput(1.2, 2.0){nachste:} 
\rput(1.2, 1.5){0x1b464c0}
\rput(1.5, 0.5){Adresse: 0x1b464a0} 

\psline[linewidth=0.04cm](3.5,2.)(4.5,2.)
\psline[linewidth=0.04cm](4.25,2.5)(4.5,2)
\psline[linewidth=0.04cm](4.25,1.5)(4.5,2)
\psframe[linewidth=0.04,dimen=outer](8.,1)(5.0,3.0)
\rput(6.2, 2.5){element: 6}
\rput(6.2, 2.0){nachste:}
\rput(6.2, 1.5){0x1b46480}
\rput(6.2, 0.5){0x1b464c0}
\psline[linewidth=0.04cm](8.5,2.)(9.5,2.)
\psline[linewidth=0.04cm](9.25,2.5)(9.5,2)
\psline[linewidth=0.04cm](9.25,1.5)(9.5,2)

\psframe[linewidth=0.04,dimen=outer](13.,1)(10.0,3.0)
\rput(11.2, 2.5){element: 6}
\rput(11.2, 2.0){nachste:}
\rput(11.2, 1.5){NULL}
\rput(11.2, 0.5){0x1b46480}
\psline[linewidth=0.04cm](13.,2.)(14.,2.)
\psline[linewidth=0.04cm](13.75,2.5)(14.,2)
\psline[linewidth=0.04cm](13.75,1.5)(14.,2)
\rput(15, 2.){\LARGE NULL}
\end{pspicture} 
}
\caption{Einmal Verketette Liste\label{verklist}}
\end{figure}
In der Abbildung \ref{verklist} wir zeigen, wie es in der Praxis
funkzioniert. Wir werden den NULL pointer für das Ende der verketetten
Liste verwenden. Viele wichtigen Datenstukturen können mit 
verketetten Listen darstellen. Beispielweise den Stapelspeicher.
In Assembly Programmiersprache beim Funktionanrufen die Parameters werden 
zum Stapelspeicher gestellt. Wenn wir kommen von einem Funktion zurück, 
wir nehmen ein Element vom Stapelspeicher aus. Das Grundprinzip im
Stapelspeicher ist: Den zuletzt gespeicherten Element werden wir zuerst
zurückgeben. Wir zeigen es in der Abbildung \ref{stapspeicher}.
\begin{figure}[!ht]
\begin{center}
% Generated with LaTeXDraw 2.0.8
% Sun Mar 05 20:17:29 CET 2017
% \usepackage[usenames,dvipsnames]{pstricks}
% \usepackage{epsfig}
% \usepackage{pst-grad} % For gradients
% \usepackage{pst-plot} % For axes
\scalebox{0.7} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-3)(12.0,3)
\psframe[linewidth=0.04,dimen=outer](3,3)(0.0,2)
\psframe[linewidth=0.04,dimen=outer](11.0,3)(8,2)
\pscustom[linewidth=0.04]
{
\newpath
\moveto(3.1,2.5)
%\lineto(7.5,1.5)
\curveto(3.3,2.5)(3.5,2.4)(4.5,1.7)
}
\rput(3.7, 2.8){\LARGE push}
\psline[linewidth=0.04cm](4.55,1.9)(4.5,1.7)
\psline[linewidth=0.04cm](4.4,1.6)(4.5,1.7)


\pscustom[linewidth=0.04]
{
\newpath
\moveto(7.5,2.5)
%\lineto(7.5,1.5)
\curveto(7.5,2.5)(6.8,2.5)(6.5,1.6)
}
\rput(6.7, 2.8){\LARGE pop}
\psline[linewidth=0.04cm](7.4,2.7)(7.5,2.5)
\psline[linewidth=0.04cm](7.4,2.3)(7.5,2.5)


\psframe[linewidth=0.04,dimen=outer](7,1.5)(4,0.5)
\psframe[linewidth=0.04,dimen=outer](7,0.2)(4,-0.8)
\psframe[linewidth=0.04,dimen=outer](7,-1.1)(4,-2.1)
\end{pspicture} 
}
\caption{Der Stapelspeicher\label{stapspeicher}}
\end{center}
\end{figure}

Wir werden jetzt implementieren diesen wichtigen Datenstruktur mit 
den verketetten Listen. Zuerst stellen wir der Datenstruktur, den wir verwenden
vor:
\begin{lstlisting}
typedef struct list {
   struct list* next;
   int data;
} list;
\end{lstlisting}
Das ist natürlich eine verketette Liste. Aber wir haben hier diesen Typ also definiert
mit dem Strichwort $typedef$.
\begin{myexampleblock}{Strichwort: \texttt{typedef}}
\begin{lstlisting}
typedef neuename altename;
\end{lstlisting}
\vspace{-0.4cm}
Stellt ein neues Name ($neuename$) für den Typ von $altename$ her.
\end{myexampleblock}
Der größte Vorteil in diesem Fall ist, dass wir den Strichwort $struct$ 
vor allen Variable definition verwenden müssen. Der Quelltext wird durchsichtiger
sein. Jetzt wir haben das Definition der Datenstrukture, wir können die Implementierung
anfangen. Zuerst besprechen wir, wie können wir eine neue Stapelelement herstellen.
Wie können wir eine neue Variable von Typ $list$ herstellen.
\begin{lstlisting}
list * get_a_list( int x ){
   list *q=(list *)malloc(sizeof(list));
   if (q == NULL){
     fprintf(stderr, "Error in Memory allocation\n");
     exit(1);
   }
   q->data=x;
   q->next=NULL;
   return q;
}
\end{lstlisting}
Der obene Codeteil gib eine $list$ Element zurück und hat die
speichernde ganze Zahl als Eingabeparameter. Dieser Teil ist ganz einfach.
Wir reservieren Speicherzellen für den neuen Listelement und zuweisen
den Eingabewert. Zum Ende wir müssen die nächste Element als ein NULL 
Pointer festlegen. Die nächste Teil ist das push() Funktion. Speichern 
ein Element im Stapelspeicher.
\begin{lstlisting}
void push( int x, list ** first){
   if ((*first) == NULL){
       (*first)=get_a_list(x);
       return;
   }
   list *temp=get_a_list(x);
   temp->next=(*first);
   (*first)=temp;
}
\end{lstlisting}
Wir müssen die Adresse von dem Pointer auf den Anfang des Speichers  und den speichernde 
Element abgeben. Wenn den List leer ist, wir legen die Anfangsadresse mit der adresse 
des  neuen Elements fest. In anderem Fall wir legen den next Pointer von dem neuen Element 
mit dem originalle Anfangsadresse und die neue Anfangsadresse wird die Adresse vom neuen Element 
sein. Darum müssen wir nicht die Anfangsadresse als Parameter abgeben, sondern ihre Adresse,
weil wir den Wert von ihm im Funktion ändern wollen. Den logischen nächsten Schritt
ist die implementierung des $pop$ Funktions. Der Rückgabewert muss den letzten gespeicherte
Element sein. Der Eingabeparameter muss den Anfangsadresse den Stapelspeicher sein.
\begin{lstlisting}
int pop( list **first){
   list *temp;
   int ret;
   if ((*first) == NULL){
     printf("Es gibt kein Element im Speicher\n");
     return 0;
   }
   ret=(*first)->data;
   temp=(*first)->next;
   free(*first);
   (*first)=temp;
   return ret;
}
\end{lstlisting}
Wenn das Stapelspeicher leer war, wir werden eine Nachricht ausdrücken. 
Im anderen Fall wir legen den Rückgabewert mit dem Wert von dem ersten 
Element fest. Wir müssen auch die ersten Element freigeben, und die neue
Anfangsadresse mit dem nächste der originalen festlegen.

Wir können auch prüfen die aktuellen Inhalt des Speichers. 
Dafür müssen wir einer Funktion, der dursch die Listelementen geht
schreiben.
\begin{lstlisting}
void print_list( list *first){
   list *temp=(first);
   if (temp == NULL)
      return;
   for (;;){
      printf("%d\t", temp->data);
      temp=temp->next;
      if (temp == NULL)
        break;
   }
   printf("\n");
}
\end{lstlisting}
Dieser Funktion zuerst prüft ob der Speicher leer ist. Wenn der
Speicher nicht leer ist, wir machen eine Schleife um durch die
Listelementen gehen. In jeden iteration wir springer zur 
nächsten Element (Zeile 7). Wenn wir am Ende des Speichers
sind, beenden wir die Schleife.

Es fehlt jetzt nur noch ein Gebrauchanweisung für unseren Stapelspeichern.
Dies wird der $main$ Funktion.
\begin{lstlisting}
int main(){
   list *erste=NULL;
   push(2, &erste);  print_list(erste);
   push(4, &erste);  print_list(erste);
   push(6, &erste);  print_list(erste);
   pop( &erste );    print_list(erste);
   push(8, &erste);  print_list(erste);
   pop( &erste );    print_list(erste);
}
\end{lstlisting}
Wir definieren zuerst einer Pointer um die 
Anfangsadresse des Speichers zu speichern (Zeile 2). Dann wir machen eine
Folgen aus push und pop Anweisungen, und im jeden Schritt wir drücken
den aktuellen Zustand des Speichers aus. Die Ausgebe siehst du unter.
\begin{lstlisting}
2	
4	2	
6	4	2	
4	2	
8	4	2	
4	2	
\end{lstlisting}
Wie du siehst, wenn wir die erste $pop$ Anweisung ausführen, wurde die letzte 
eingegebene Wert (6) aus dem Speicher gelöst. 

\include{endprojekt}

%as Körper, das C code kannst du oben sehen. Alle C programm besteht aus Funkcionen. Wir nennen function ein part of the code, was eine
%estimmte aufgabe erledigt.
%u wirst es gleich finden, dass du muss zuerst lernenDu musst zuerst den einladen, was jemanden
%eschrieben hat. Zum beispiel, zu computer printen du sollst stdio.h einladen. Sie
%ehören nicht zu den sprache . Danach kommt deine arbeite. Zuerst du sollst andenken was für ein ergebnis deine aufgabe haben soll und
%ie viele eingangsparameter deine programm hat. Du sollst denen es variablen deklarieren. Jetzt kommt die wichtigsten Teil des Program, die
%unktionen. Diese teil rechnet aus den eingangsparameter deine Ergebnis. Es gibt ein specielle function was jeden programm haben
%oll. Das nahme of diese funcktion ist main. Von diesem Punkt beginnt die Ausführung. Wir werden mehr um funckcionen später lernen. 

%Im fünften Linie illustrieren wir, dass das Name der Variable nicht mit einem Zahl beginnin darf. Eine practical Beratung ist initializerien
%alle Variables recht im Definition. 
%enn zwei operatoren gleichem Prioriät haben, dann zum ersten mal der linkste wird verarbeitet, and danach 
%on links nach rechts\footnote{Hier gibt es ausnahme, wenn die Reihenfolge ist umgekehrt. Siehst denn letzten Spalte im Tablellen \ref{priortab}}. 


%\begin{lstlisting}{Einf\"ugesortieren in C: Körper }
%#include<stdio.h>
%void read_in_data( int n, int sort[], int unsort[], int argc, char *argv[]){
%statements a1;
%statements b1;
%...
%}
%void einfugesortieren( int n, int sort[], int unsort[]){
%statements a2;
%statements b2;
%...
%}
%void print_out_data( int n, sortiert){
%statements a3;
%statements b3;
%...
%}
%int main( int argc, char *argv[])
%{
%  int n=4;
%  int sortiert[n];
%  int unsortiert[n];
%  read_in_data(n, sortiert, unsortier, argc, argv);
%  einfugesortieren(n,  sortiert, unsortiert);
%  print_out_data( n, sortiert);
%
%}
%\end{lstlisting}
%Das Körper, das C code kannst du oben sehen. Alle C programm besteht aus Funkcionen. Wir nennen function ein part of the code, was eine
%bestimmte aufgabe erledigt. 
%Du wirst es gleich finden, dass du muss zuerst lernenDu musst zuerst den einladen, was jemanden
%geschrieben hat. Zum beispiel, zu computer printen du sollst stdio.h einladen. Sie
%gehören nicht zu den sprache. Danach kommt deine arbeite. Zuerst du sollst andenken was für ein ergebnis deine aufgabe haben soll und
%wie viele eingangsparameter deine programm hat. Du sollst denen es variablen deklarieren. Jetzt kommt die wichtigsten Teil des Program, die
%Funktionen. Diese teil rechnet aus den eingangsparameter deine Ergebnis. Es gibt ein specielle function was jeden programm haben
%soll. Das nahme of diese funcktion ist main. Von diesem Punkt beginnt die Ausführung. Wir werden mehr um funckcionen später lernen.
 

%Zum beispiel in C sieht die obene Auflistung so aus:
%\begin{lstlisting}{Einf\"ugesortieren in C}{
%1: int n=4;
%   int unsortiert[n],  sortiert[n];
%2; sortiert[0]=2;
%3; unsortiert[0]=9; 
%   unsortiert[1]=5;
%   unsortiert[2]=7;
%4; for (int i=1; i<n-1;++i){
%      sortiert[length]=unsortiert[i]
%5-6;   for (int j=length-1; j>0; --j){
%         if (sortiert[j+1]<sortiert[j]){
%            int tmp=sortiert[j];
%            sortiert[j]=sortiert[j+1];
%            sortiert[j+1]=tmp;
%         }
%         else{
%          break;
%         }
%      }
%      length++;
%   }
%}
%\end{lstlisting}
%''for`` steht f\"ur Schleife und wir nutzten das "A" array 
%Warum solltest du C programmier sprache lernen? Es gibt viele Antwort auf diese Frage. Zum Beispiel:
%\begin{itemize}
%\item C ist nicht kompliziert
%\item C ist sehr effizient
%\item C hat high level konstrukte
%\end{itemize}
%Aber M\"oglicherweise das beste Antwort ist das C Kenntnisse ist unbedingt in Forschungsrechnungen. Die meisten Programme,
%der zum Stand der Technik geh\"oren sind C programme. In diesem Kurz wir werden diese Sprache kennenlernen. Zuerst 
%wir zusammenfasseen was in der Sprache inbegriffen ist. Du wirst dich verwundern, das die einfachste funktion, was
%nur etwas auf deinem Monitor zeigt, geh\"ort nicht zu der Sprache. Wir vorstellen das k\"orper einem durchschnittlichen
%C program und erkl\"aren sein Teilen. 

%Danach z\"ahlen wir die Komponenten der Sprache auf. Das wird beginnen mit der data Typen und Operationen, in denen wir 
%die Typen nutzen k\"onnen. Wir werden alle elementare Data type lernen. Mit Variablen aus diesen Typen k\"onnen wir Operationen machen, 
%die unsere Ergebnisse herstellen werden. Dann werden wir elementare Statements und Expressions einf\"uhren, mit denen 
%wir kleinen Aufgaben l\"osen k\"onnen. 
  
%Es is sehr wichtig, dass unsere Programm Parameter erhalten zu k\"onnen. Wir k\"onnen das erreichen durch Funkcionen.
%Die Funkcionen arbeiten wie schwarze K\"asten. Sie stellen von den Eingangsparameter ein neues Wert her. Wir zeigen, 
%wie man die Standart Eingabe und Ausgabe Bibliothek nutzten kann. Nachdem wir diese F\"ahigkeiten verstehen, werden wir etwas
%komplizierte \"Ubungen schreiben.

%Often gibt es Situationen in den wir mehr als Ein ergebnisse von einem Funktionen wollen. Um das erreichen
%m\"ussen wir die Addressirung der Memorie kennen zu lernen. In diesem Punkt werden wir auch lernen, wie man 
%strings verwendet kann.
%
%In einem sch\"onen Programm wir nutzten das wenigstens Speicher. In diesem Punkt wir werden lernen, 
%wie die Speicherverwaltung behandelt wird.

%Im ersten Teil des Kurses wir haben die elemetare datatypen kennen gelernt. In diesem Punkt wir
%werden lernen, wie mann eigenes Daten Structure herstellen kann. Überhaupt, Warum and Wenn müssen wir neue Structure herstellen.
%Unser Programm mit eigenen Daten strukturen wird leichter lesen zu können. Das ist sehr wichtig. Typischer fehler der Angefangenen Programmern
%ist, dass ihr Code ist sehr schwer zu lesen auch für Sie, und nach einem Monat Sie müssen die ganze Programm
%wieder schreiben. Zum beispiel muss mann eigenes Datenstrukture nutzen, wenn man ein operations sehr often erledigen muss.
%Zum bespiel in der Sorierung eines List, man kann die Daten in einem binären Suchbaum einschließen um die suchen schneller zu lassen.

%\section{Der Körper des C programms}

%\begin{lstlisting}{caption= Do nothing}
%#include<stdio.h>
%int main( int argv, char *argv[])
%{
%/* do nothing */
%}
%\end{lstlisting}
%Welche Teile hat ein C programm. 
%Du wirst es gleich finden, dass du muss zuerst lernenDu musst zuerst den einladen, was jemanden 
%geschrieben hat. Zum beispiel, zu computer printen du sollst stdio.h einladen. Sie
%gehören nicht zu den sprache . Danach kommt deine arbeite. Zuerst du sollst andenken was für ein ergebnis deine aufgabe haben soll und
%wie viele eingangsparameter deine programm hat. Du sollst denen es variablen deklarieren. Jetzt kommt die wichtigsten Teil des Program, die
%Funktionen. Diese teil rechnet aus den eingangsparameter deine Ergebnis. Es gibt ein specielle function was jeden programm haben
%soll. Das nahme of diese funcktion ist main. Von diesem Punkt beginnt die Ausführung. Wir werden mehr um funckcionen später lernen.  
%\section{Was ist Programmieren}
%Es gibt ein Problem, Sie müssen die Lösung finden. What we call input variables? What are the output variables? Specific problem?
%\section{Definitionen, Statements}
%Die Variablen haben Wert und Typ. Warum ist das Typ der Variable wichtig? Es hängt vom Typ ab, was für ein Wert eine Variable haben
%kann. Das Typ entscheid also die Grösse des Arbeitspeicher zu deine Variable. Mann kann nun solche Funkcionen und Operatoren nutzen, das 
%genanue Datentype hat. Es gibt elementare data Typen mit dem wir spielen können. Sie sind
%\begin{itemize}
%\item char
%\item int
%\item float
%\item double
%\end{itemize}
%Im char können wir eine character speichern(die bereich?). Größe, im können wir ein Ganzzeil spiechern von wert 0 bis 2**32-1 größe. 
%Im fließkommazahl von bis speichern grösse.
%\subsection{Mein erstes C programm}
%von linein bis linien wir erklären Einfachste Programm der Welt "Hello World.c"
%Ein bisschen schwerer aufgabe, sie müssen ausrechnen die Würzel einer quadratische Gleichung. 
%\section{Aufgaben}
%\subsection{Zufallszahlgenerator}
%Zufällige nummer sind sehr wichtig für uns. In numerischen physik wir nutzten Zufallszahlen ganz often. Zum Beispiel 
%in die einfachsten method für integration of mehreren variablen Funkctions müssen wir Monte Carlo algorithm nutzten. Die
%enthalten statements, die vom Werte auf Zufällige variablen abhängt. In dieser Aufgabe wir müssen eine Zufallszahlgenerator
%schreiben. Es gibt mehrere methode dazu, aber alle stammt aus linear Kongruenzen:
%\begin{equation}
%I_{j+1}=a I_{j} \left( \mathrm{mod} m\right).
%\label{basics}
%\end{equation}
%Diesen Instruktion macht eine neue Zufallszahl ($I_{j+1}$)  aus einem original ($I_j$). Der qualität der Zufallszahl generator
%hängt von dem eingangsparameters (a,m) ab. Eine gute Zufallszahlgenerator hat große period, die Zeit zwischen den beiden gleichen
%Zufallszahl muss sehr groß sein. Park und Miller hat die folgenden parameter für a und m gewählt:
%\begin{equation}
%a=16807, m=2^{31}-1=2147483647. 
%\end{equation}
%Leider direkte implementation der Zufallszahlgenerator mit deisen parameters ist nicht möglich in C. Der grund ist
%wir können nicht speichern Zahlen grossen als $m$. Zum glück gibt es eine möglichkeit das Problem umzugehen. 
%Wir faktorizieren $m$:
%\begin{equation}
%m= aq + r; r= m \left(\mathrm{mod}a\right); q= \left[m/a\right]
%\end{equation}
%Damit können wir Gleichung \ref{basics} auch bewerten mit ($q,r$):
%\begin{equation}
%a I_j \left( \mathrm{mod} m\right)=  
%\left\{ \begin{array}{rc}
%a\left(I_j \mathrm{mod} q\right) -r \left[I_j/q\right] & \mathrm{wenn~es~}>0\mathrm{ist} \\ 
%a\left(I_j \mathrm{mod} q\right) -r \left[I_j/q\right] + m & \mathrm{andernfalls} \\ 
%\end{array}\right.
%\label{algo}
%\end{equation}
%wo $r=2836,q=127773$ ist. Implementieren Sie das Zufallszahlgenerator nach eq.\ref{algo}. Ändern Sie die Algorithm
%um die Zahlen zwischen 0 und 1 zu sein werden.
%Es ist wichtig zu test unser Ergebnis. Wir müssen kontrollieren die Verteilung (Distribution) der Zufallszahlgenerator.
%Wir möchten gleichmäßige vertailung zu erreichen. Wir werden eine Histogramms machen aus dem Zufallszahlen. Wir teilen 
%das Interval in $n$ Teilen und zahlen wie oft die Zufallszahl in jedem Interval sinkt. Machen Sie ein Histogramm aus 
%den Verfügbaren daten und prüfen wie gleichmäßig der Verteilung ist!
%\section{Elementare operatoren}
%\subsection{Binäre, Aritmethic operatoren}
%+,-,*,/, \%, ++, -- 
%\subsection{Gleichungen}
%==,!=, >,<, >=,<=
%\subsection{Bitwise}
%\&,|,\^, ~, >>,<<
%\subsection{Zuweisungsoperator}
%=,+=,-=,|=,\&=,\^=,\%=,<<|,>>|,
%\subsection{Aufgaben}
%Programm rechnet die Wurzel, der gleichung
%\section{statements}
%\subsection{Schleifen}
%Was ist wichtig, wenn wir ein Schleifen plan? Wir müssen nicht überschreiben eine existierte variable. Wir müssen keine
%statements haben, was nicht von der Schleifenzahlnummer abhängt.
%\subsection{If then else}
%\subsection{case}
%\subsection{Standard input, output}
%\subsection{Conways Spiel des Lebens}
%Wir habe eine quadrate Gitter. In alle Zell der Gitter eine zwei hältige variable. Es sagte uns, wenn der
%kleine microbe im Zell, lebt oder nicht.
%\section{Funkcionen}
%\section{Addressierung}
%\subsection{Stackel(LIFO)}
%\subsection{Fifo}
%\subsection{Umgekehrte Polnische Notation}
%\section{Dynamische speicherverwaltung}
%\section{Daten strukturen}
%\subsection{Ketten listen}
%\subsection{Bäumen}
%\subsection{Recursive functionen, Schnell sortieren}
\end{document}
