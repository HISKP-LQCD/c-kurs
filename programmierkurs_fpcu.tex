\documentclass{article}[12pt]
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

\usepackage[dvipsnames]{xcolor}
\usepackage{lipsum}

\usepackage{amsfonts}
\usepackage[intlimits]{amsmath}
\usepackage{cite}
\usepackage{epsfig}

\usepackage[usenames,dvipsnames]{pstricks}
\usepackage{pstricks-add}
\usepackage{epsfig}
\usepackage{pst-grad} % For gradients
\usepackage{pst-plot} % For axes

\addtolength{\hoffset}{-1.5cm}
\addtolength{\textwidth}{3cm}
\usepackage{listings}
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\PassOptionsToPackage{svgnames}{xcolor}
\usepackage{tcolorbox}
\usepackage{lipsum}
\tcbuselibrary{skins,breakable}
\usetikzlibrary{shadings,shadows}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=C,                      % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}


\newenvironment{myexampleblock}[1]{%
    \tcolorbox[beamer,%
    noparskip,breakable,
    colback=White,colframe=ForestGreen,%
    colbacklower=LimeGreen!75!White,%
    title=#1]}%
    {\endtcolorbox}

\newenvironment{myalertblock}[1]{%
    \tcolorbox[beamer,%
    noparskip,breakable,
    colback=White,colframe=Bittersweet,%
    colbacklower=Peach!75!White,%
    title=#1]}%
    {\endtcolorbox}

\newenvironment{myblock}[1]{%
    \tcolorbox[beamer,%
    noparskip,breakable,
    colback=White,colframe=RoyalBlue,%
    colbacklower=TealBlue!75!White,%
    title=#1]}%
    {\endtcolorbox}
%--------
%\usepackage[magyar]{babel}
\title{C Programmierkurs}
\begin{document}
\maketitle
\section{Einführung}
In diesem Kurz wir werden die C Programmier sprache kennenlernen. Programmierung besteht aus Code schreiben und die übersetztung dieser Code in
ausführbaren Maschinecode.
Es gibt Programmier Sprache, die jede Befehle nacheinander übersetzt und ausführt. C ist anders, hier die ganze Code muss zuerst schreiben und
kompiliert werden,  danach kann diene Programm ausführen. Wir nutzten Compiler unser Code zu Maschinencode zu übersetzten. Für ersten Programmier Sprache C ist ideal 
von mehreren Gründen:
\begin{itemize}
\item C ist sehr effizient
\item C hat high level konstrukte.
\end{itemize}
Es ist effizient, weil es sehr gute Compiler gibt. Wir müssen nicht die Teile des CPU-s wissen um eine gute Code zu schreiben, 
weil es high level konstrukte hat. Aber M\"oglicherweise das beste Antwort ist das C Kenntnisse ist unbedingt in Forschungsrechnungen. Die meisten Programme,
der zum Stand der Technik geh\"oren sind C programme. 


Hier wir beschreiben kurz den Inhalt des Buches. In dem ersten Teil des Buches wir erklären, wie man eine einfache Aufgabe mithilfe der C
sprache erledigen kann. Wir werden die Grundelementen der Sprache durch einem Beispiel (Einfügesortieren) vorstellen. Zuerst wir fassen
zusammen was in der Sprache inbegriffen ist. Du wirst dich verwundern, das die einfachste funktion, was nur etwas auf deinem Monitor zeigt, 
geh\"ort nicht zu der Sprache. Wir fangen mit dem k\"orper eines durchschnittlichen C programm an  und erkl\"aren sein Teilen.
Um ein C programm zu verstehen, wir müssen Zwei wichtige Konzept wissen:
\begin{enumerate}
\item Data Typen
\item Funkcionen
\end{enumerate}

Zum Bespiel wenn wir die Zahlen sortieren wollen, wir müssen entscheiden ob wir ganze oder reelle Zahlen nutzten wollen. Zu jeden Data 
Typen gehören Operationen, in denen wir die nutzen k\"onnen. Wir werden alle elementare Data Type kennenlernen. Mit Variablen aus diesen 
Typen dann k\"onnen wir Operationen machen, die unsere Ergebnisse herstellen werden. Aber es kann sein, das unserer aktuelle Befehl hängt
von dem Ergebnis des vorherigen Befehl ab. In diesem Fall die Sprache bietet uns Statements und Expressions, mit denen wir kleinen Aufgaben 
lösen könnnen.

Die andere wichtige Konzept is die Funkcionen. Die Funkcionen arbeiten wie schwarze K\"asten aus der Sicht des Benutzers. Sie stellen von 
den Eingangsparameter ein neues Wert her. Auch wir können Parameters zu unserem Programm nur durch Funkcionen geben.  Zu genießen
die Fähigkeiten der Sprache, wir müssen zuerst verstehen, wie mann Funkcionen angerufen kann. Wir zeigen,
wie man die Standart Eingabe und Ausgabe Bibliothek nutzten kann. Nachdem wir diese F\"ahigkeiten verstehen, werden wir etwas
komplizierte \"Ubungen schreiben.

In dem zweiten Teil des Kurzes wir werden unsere Coden verbessern. Dafür gibt es zwei vershiedene
Richtungen:
\begin{enumerate}
\item Memorie verwaltung
\item Zusammengesetzte Datenstruktur
\end{enumerate}

Verstehen wie mann Memorie zuweisen, oder freien kann sehr hilfbereit sein, um eine reine Code schreiben zu können. 
Die Höchstwahrscheinlich auftretene Fehler der Anfängers ist Segmentation Fault. Du kannst diese Fehler vermeiden nur, wenn
du weisst wie addressierung funkcionert. Das wird eine der wichtigesten Teil der Buch. Auf nebenplatz, wir werden
vorstellen, wie man strings in C verwenden kann.

Die Andere Richtung führt uns zur Zusammesgesetzte Datenstrukturs. Zuerst werden wir lernen, wie mann eigenes Daten strukturen herstellen 
kann. Neue Datenstrukturen entdecken ist wichtig, weil sie können unsere Programme schneller machen. Zum Beispiel wenn mann nach
einem Field in einer List sucht, kann mann binarische Bäumen herstellen, um die Suchen schneller zu lassen. Um unseren Code
nach ein Jahr später auch verstehen zu können, es ist wichtig das Code verteilen zu können. Wir werden lernen wie man
von verschiedenen Files das Programm Aufbauen kann.

%In einem sch\"onen Programm wir nutzten das wenigstens Speicher. In diesem Punkt wir werden lernen,
%wie die Speicherverwaltung behandelt wird.

%Im ersten Teil des Kurses wir haben die elemetare datatypen kennen gelernt. In diesem Punkt wir
%werden lernen, wie mann eigenes Daten Structure herstellen kann. Überhaupt, Warum and Wenn müssen wir neue Structure herstellen.
%Unser Programm mit eigenen Daten strukturen wird leichter lesen zu können. Das ist sehr wichtig. Typischer fehler der Angefangenen Programmern
%ist, dass ihr Code ist sehr schwer zu lesen auch für Sie, und nach einem Monat Sie müssen die ganze Programm
%wieder schreiben. Zum beispiel muss mann eigenes Datenstrukture nutzen, wenn man ein operations sehr often erledigen muss.
%Zum bespiel in der Sorierung eines List, man kann die Daten in einem binären Suchbaum einschließen um die suchen schneller zu lassen.
\section{Mein Erste C Programm}
Dieses Buch (Kurz) handelt sich um eine programmier Sprache. Die programmier Sprache ist ein Werkzeug, mit dem wir unser
Gedanken zum Computer versenden können. Zum beispiel wir möchten $n$ Zahlen sortieren. Wir wissen im Kopf, 
wie wir es machen werden. Wir wissen der Algorithmus der Sortierungs. Die einfachste ist der Einfügesortieren. 
Wir fassen zusammen in
der unteren Auflistung:
\begin{lstlisting}{Einf\"ugesortieren}
1; Wir haben zwei Listen : 
     sortierte, unsortierte
2; Am Anfang die sortierte Liste besteht aus dem ersten Zahl 
3; Alle andere Zahlen gehoren zum unsortierten Liste
4; Wir machen eine Schleife uber allen Element der unsortierten Liste
5; Fur jeder Elemente in der ursortierten Liste wir suchen 
     fur die angemessene Position in der sortierten Liste.
6; Wir ziehen die Element um zu der sortierten Liste.
\end{lstlisting}
Das ist alles, aber das wird der Computer nicht verstehen. Wir müssen das übersetzten um der Computer
verstehen zu können. Jede sprache hat eigene Sprachkonstrukte um diese Übersetztung zu erledigen. 

\subsection{Speichern}
Wir handeln Zahlen im Computer mithilfe der Speichern. Die Größe der Speicher hängt von der Art von Zahlen 
ab. Zum Beispiel wir können Ganze Zahlen auf wenigen Platz speichern, als reelle Zahlen.
Als Speicher man kann Registers, Memory oder Festpaletten verwenden. 

Alle speichern bestehen aus elementare Speicherzellen (mann nennt sie es Byte-s). Mann nennt diese zellen Elementare, obwohl es 8 
Bauteile (mann nennt es  bit) hat. Mann kann sagen elementare Speicherzelle auch, weil einigen
bit kann nicht verändert werden. Ein Bit kann geladen or entladen werden, dabei hat es zwei zustände: 
0 (nein), 1 (ja). Auf diese Weise in einem Speicherzelle kann man 256 vershiedenen Zustände (verschiedenen Zahlen) 
speichern. Zu speichern mehreren Zustände es gibt verschiedene Möglichkeiten:
\begin{itemize}
\item Byte:  1Byte $2^{8 }$ zustände
\item Word:  2Byte $2^{16}$ zustände
\item Dword: 4Byte $2^{32}$ zustände
\item Qword: 8Byte $2^{64}$ zustände
\end{itemize}
Zum beispiel, wenn du schreibst deine Code in einem txt File, für alle geschriebene character nutzt man 1 Byte
speicher auf das Festpallette. Man speichers das ASCII charachter der Buchstabe.  

Die Speichers haben zwei wichtigen Eigenschaften: 
\begin{itemize}
\item Ihre Grösse 
\item Zeit zu erreichen eine Zelle
\end{itemize}
Diese Eigenschaften zusammen bestimmen die Speichern. Zum Beispiel die Memory ist umgefähr 10.000 mal
schneller zu erreichen als die  Festpalletten, aber 50 mal langsamer zu erreichen als die Registers. 
Aber die Registers besteht aus wenigen Kilobytes, das Memory aus wenigen Gbytes, und das Festpallette
aus wenigen TBytes. Glücklicherweise wir müssen nicht genau wissen, wie die verkehr zwischen haupt memory
und die Register behandeln wird, die Compiler macht diese Aufgabe. 

\subsection{Der Körper des C code für Einfügesortieren}
Die Computer programme besteht aus Variablen, mit dem wir operationen machen können und Funkcionen. In der letzten Punkt
wir haben gesehen, wie kann man Zahlen im Computer speichern. Hier wir werden einführen, wie mann Variablen
deklarieren, Wert geben oder auf dem Monitor ausdrücken kann.

\subsubsection{Ausdrücken}
\begin{lstlisting}{Erste C programm}
#include<stdio.h>
int main(int argc, char *argv[]){
   printf("Hello world\n");
}
\label{typ_1}
\end{lstlisting}

Zuerst werden wir nur eine Nachricht auf dem Monitor Zeigen: "Hello World". Du siehst die Code oben. Es hat nur 4 Reihe, und
macht die complex Aufgabe: drücken auf Monitor. Jede C programm hat zwei Teile. In den ersten Teil du sagst dem Computer, welchen 
Funkcionen die anderen geschrieben haben, willst du nutzten.  Das Funktion, ist eine Programmteil der macht ein Ausgang aus dem Eingang. 
Hier in der dritten Reihe wir nutzten die printf Funkcion, was zeigt ihrer Argumente auf dem Monitor. Der Compiler muss wissen
wieviele and welche parameter jede Funktion haben kann. Dieses Information ist zusammelt von der sogennanten ''header`` Files. 
Du siehst das in der ersten Reihe. Diese Reihe sagt dem Compiler zu beilagen das Inhalt des File "stdio.h". In diesem File
findet mann die deklaration des printf funktion. Mehr werden wir sagen über printf Funkcion gleich, aber hier wir also
haben unseren ersten Funkcion geschrieben. Das Name des Funkcions ist main. Jede C code muss ein Funkcio mit dem Namen main 
haben. Die Ausführung des Programms beginnt mit diesem Funkcion. Es hat zwei Eingangsparameter:
\begin{enumerate}
\item Variable argc. Seines Wert ist gleich der Anzahl der Parameter.
\item Variable argv. Es ethält die Parameter
\end{enumerate}
Das Funkcion Main also hat Ausgangs Parameter, der Null ist, wenn alles war gut, und unsere Program hat erfolgreich 
beendet.

\subsubsection{Variablen}
Die Ausgangs und Eingangsparameter eines Funkcions sind Variablen.
Ein Variable ist ein Konzept, der eine Name im Quelltext, und eine Addresse im Speicher deiner Maschine hat. 
Im Quelltext das Variable ist identifiziert bei ihrem Name. In \ref{typ_1} das int vor dem Name der eingangsparameter
ist ihre Typ. Hier unter siehst du unsere erste Variable definition. In der dritten Reihe wir haben einen Variable
nennt $n$ als ein int (ganze Zahl) definiert. 
\begin{lstlisting}{Erste Variable definition}
#include<stido.h>
int main( int argc, char *argv[]){
   int n=4;
   printf("Wir werden n zahlen sortieren:\n");
}
\end{lstlisting}

Wir verstehen unter definiert, das wir haben Speicher zugewiesen. Für das Typ int wir brauchen $4$ byte Speichern.
Natürlich alle Variable haben ihre eigenen Sichtbarkeitsbereit und Lebensdauer. Mann kann nicht anderen Variablen mit dem gleichen Namen 
im derseblen Blocken definieren. Wenn du eine Variable mit dem gleichen namen deklarierts in einem Block, denn der Andere wird nicht
sichtbar in der inneren Block. Variable, das wir in einem Funckion definiert haben, lebt in diesem Funkcion. Man kann diesen Variablen als 
Lokalen bezeichnet. Wenn mann die Werte diesen Variablen außer der Funkcion haben will, mann macht ein Fehler. In diesem Fall 
muss mann sie außerhalb der Funkcionen definieren. Deise Variablen kann man bezeichnet als global. 
Ihren Wert ist erreichbar für allen Funkcion im Quelltext. Es gibt zwei verschiedene möglichkeiten zum definiering
eine globale Variable.
\begin{enumerate}
\item Stichwort static: In diesem Fall mann kann nutzten die Variable in ganzen File, wo es definiert war. Anderen
Files in unserem Code kann natürlich nutzten eine andere Variable mit dem gleichen Name.
\item Stichwort extern: In diesem Fall mann kann nutzten die Variable in dem ganzen Programm. Aber das
variable muss deklariert werden in allen Files, wo wir ihn nutzten wollen.
\end{enumerate} die für alle
Wir haben die Sichtbarkeitbereich der Variablen 
in der Abbildung  \ref{sicht} zusammen gefasst.  Das bedeutet, das wir können Variablen mit 
gleichen Namen in verschiedenen Funkcionen nutzten, wenn wir definieren sie als lokalen Variablen. 

% Generated with LaTeXDraw 2.0.8
% Tue Feb 21 10:59:44 CET 2017
% \usepackage[usenames,dvipsnames]{pstricks}
% \usepackage{epsfig}
% \usepackage{pst-grad} % For gradients
% \usepackage{pst-plot} % For axes
%\scalebox{0.5} % Change this value to rescale the drawing.
%{
\begin{figure}[!ht]
\centering
\scalebox{0.5}
{
\begin{pspicture}(2,-9.1)(17.3,9.12)
\psframe[linewidth=0.04,dimen=outer](12.6,9.1)(2.0,-9.1)
%\usefont{T1}{ptm}{m}{n}
\rput(3.6692188,8.61){Source code}
\psline[linewidth=0.04](5.2,9.1)(5.2,8.1)(2.0,8.1)
%\usefont{T1}{ptm}{m}{it}
\rput(7.8229685,-7.565){globalen Variablen: Deklarierten mit dem Stichwort: extern}
\psframe[linewidth=0.04,dimen=outer](11.6,7.1)(3.2,0.1)
\psframe[linewidth=0.04,dimen=outer](11.6,-0.5)(3.2,-7.1)
%\usefont{T1}{ptm}{m}{n}
\rput(4.0503125,6.81){File 1}
%\usefont{T1}{ptm}{m}{n}
\rput(4.0489063,-0.79){File 2}
\psline[linewidth=0.04](5.0,7.1)(5.0,6.5)(3.2,6.5)(3.2,6.5)
\psline[linewidth=0.04](4.8,-0.5)(4.8,-1.1)(3.2,-1.1)
%\usefont{T1}{ptm}{m}{n}
\rput(6.7009373,0.81){variable mit static Stichwort}
%\usefont{T1}{ptm}{m}{n}
\rput(6.9809375,-6.59){variablen mit static stichwort}
\psframe[linewidth=0.04,dimen=outer](6.8,5.7)(3.8,2.7)
\psframe[linewidth=0.04,dimen=outer](11.0,5.5)(8.0,2.7)
\psframe[linewidth=0.04,dimen=outer](7.0,-1.7)(3.6,-5.1)
\psframe[linewidth=0.04,dimen=outer](11.2,-1.9)(8.0,-5.3)
%\usefont{T1}{ptm}{m}{n}
\rput(4.9203124,5.41){Funkcion 1}
%\usefont{T1}{ptm}{m}{n}
\rput(9.3189063,5.21){Funkcion 2}
%\usefont{T1}{ptm}{m}{n}
\rput(4.9203124,-1.99){Funkcion 1}
%\usefont{T1}{ptm}{m}{n}
\rput(9.3189063,-2.19){Funkcion 2}
%\usefont{T1}{ptm}{m}{n}
\rput(4.7434375,4.61){Lokale }
%\usefnt{T1}{ptm}{m}{n}
\rput(5.4034376,4.21){variablen}
%\usefont{T1}{ptm}{m}{n}
\rput(9.3434377,4.41){Lokale}
%\usefont{T1}{ptm}{m}{n}
\rput(9.8173437,4.01){Variablen}
%\usefont{T1}{ptm}{m}{n}
\rput(4.7434375,-3.39){Lokale}
%\usefont{T1}{ptm}{m}{n}
\rput(5.2034376,-3.79){variablen}
%\usefont{T1}{ptm}{m}{n}
\rput(9.3434377,-3.39){Lokale}
%\usefont{T1}{ptm}{m}{n}
\rput(9.8034377,-3.79){variablen}
\end{pspicture}
}
\caption{\label{sicht} Sichtbarkeitbereich der Variablen}
\end{figure}

Die Variablen haben Wert und Typ. Das Typ der Variable ist sehr wichtig. Es hängt vom Typ ab, was für ein Wert eine Variable haben
kann. Das Typ entscheid also die Grösse des Arbeitspeicher zu deine Variable. Mann kann nun solche Funkcionen und Operatoren nutzen, das
genanue Datentype hat. Es gibt elementare data Typen mit dem wir spielen können. Wir haben im Tabellen \ref{tabelle1} alle elementare
Datatypen gelistet.


\begin{table}[h]
\caption{Elementare Daten Typen\label{tabelle1}}  % title name of the table
\centering
  % centering table
\begin{tabular}{|l c c rrr|}
  % creating 10 columns
\hline
Name & & Varianten & Größe in Byte & Minimal Wert & Maximal Wert
  % inserting double-line Audio &Audibility & Decision & \multicolumn{7}{c}{Sum of Extracted Bits} 
\\[0.5ex]   
\hline % inserts single-line % Entering 1 st row
                       & & int &4 & $-2,147,483,648$ & $2,147,483,647$ \\[-0.0ex]
                       & & short & 2 & $-32,768$ & $32,767$ \\[-0.0ex]
\raisebox{1ex}{int}  & & unsigned short& 2 & $0$ & $65535$ \\[-0.0ex]
                       & &unsigned& 4 & $0$ & $ +4,294,967,295$ \\[1ex]
                       & &long& 4 &  $-2,147,483,648$ & $2,147,483,647$ \\
\hline
% Entering 2nd row
                            & &signed & 1 & $-128$ & $127$ \\[-1ex]
\raisebox{1.5ex}{Char} &    & unsigned &1 & $0$ & $255$  \\[1ex]
\hline
% Entering 3rd row
float & & & 4 &  &  \\
double& & & 8 &  &  \\
long double& & &8 &  &  \\[1ex]

% [1ex] adds vertical space
\hline                          % inserts single-line
\end{tabular}
\label{tab:PPer}
\end{table}

Wir habe unseren ersten Variable im Bespiel als $n$ genennt. Es gibt einige Regeln, wie mann das Variable nennen kann. Zum Beispiel
wir dürfen nicht das Name mit einem Zahl beginnen. Wir dürfen Kapital und Klein Buchstabe nutzten. Wir dürfen auch Zahlen nutzten, aber
nicht als der erste Charakter. Das Unterstricht ist also erlaubt, aber wir nutzten sie nur für grösse Programmen.

Im Beispiel wir haben ein Wert (4) zum $n$ zugewiesen. Das ist sehr wichtig, weil das Complier standardmäßig unsere Variablen nicht
initializiert. Das ist eine der häufigste Fehler, das ein Programmierer machen kann. Im unter wir zeigen einige Richtige und Fals 
Variable definitionen:

\begin{lstlisting}
int main(int argc, char *argv[]){
   int m1=4, n1=5, l1=6; /* Richtig */
   int m2=4, char n2='a', float m2=4. /*Falsch */
   char m3='a'; double n3=18.9;/*Richtig*/
   float 4m=1.; /*Falsh */
}
\end{lstlisting} 

Wir können mehrere Variablen definierin in einer Anweisung, wenn die Variablen das gleiche Typ haben. Du kannst das sehen in dem zweiten Linie oben.
Eine Anweisung muss mit mit dem Character ';' beenden. Nach jedem ';' beginnt eine neue Anweisung. Das Character ',' bedeutet Auflistung, was in 
einem Anweisung mehrweise erscheinen darf. Wir illustrieren das falsche Weg in  dem dritten Linie, und das Rechte Weg zeigen wir in dem vierten Linie.
Im fünften Linie illustrieren wir, dass das Name der Variable nicht mit einem Zahl beginnin darf. Eine practical Beratung ist initializerien
alle Variables recht im Definition. Das Name der Variablen kann auch uns helfen, um das Programm verstehen zu können. Zum Beispiel im 
Einfügesortieren es ist ratsam die Array als sortiert und unsortiert nennen.

Jetzt werden wir sehen, was wir mit unseren Variablen machen kann. Wir können aus Variables mit Operatoren neue Werte herstellen.
Wir können Expressions formen, die eine neue Wert ausdrücken. Es hängt vom typ ab, welche operatoren in der Expressions wir nutzten können.
Es gibt drei verschieden Expressiontyp:
\begin{itemize}
\item Infix: Das operator steht zwischen den Variablen. Zum Bespiel: $a+b$. Diese Expression nimmt den Wert von $a$ und $b$, summ es und gibt das Ergebnis zurück.
\item Präfix: Das operator steht vor dem Variable: Zum Bespiel: $++a$. Diese Expression zuerst inkrementiert $a$, und danach gibt das Wert vom $a$ zurück.
\item Postfix: Das operator steht nach dem Variable: Zum Beispiel: $a--$. Diese Expression dekrementiert $a$, aber gibt das originale Wert vom $a$ zurück.
\end{itemize}
\begin{lstlisting}
#include<stdio.h>
int main(){
    int a=2;
    printf("%d\n", a++);
    printf("%d\n", a);
    printf("%d\n", ++a);
    printf("%d\n", a);
}
\end{lstlisting}
Im obenen Beispiel zuerst wir definieren eine Variable mit dem Anfangswert zwei. Danach drücken wir die wirkung des Postfix operators ($++$) auf $a$ aus 
in der vierten Reihe. Das Ergebnis wird auch zwei sein, weil wir das Postfix operator genutzten haben. Aber wenn wir gleich danach im fünften Reihe
das Wert von $a$ ausdrücken, das Ergebnis wird drei sein. In der sechsten Reihe wir drücken die wirkung des Präfix operators ($++$) auf $a$ aus, und 
das Ergebnis wird vier sein, und als Nebeneffect, das Variable $a$ wird inkrementiert.

Wir haben also drei Vershieden Operator Typen:
\begin{itemize}
\item binärer: Das operator hat zwei Argumente
\item unärer: Das operator hat nur ein Argumente
\item ternärer; Nur eine, der drei Argumente hat: $?:$
\end{itemize} 

Die operatoren könnten bitwise, oder logicalische sein. Die bitwise operator sind binäre operatoren. Sie ausführen die operation mit jedem bits der Arguments.
Die Logical operatoren geben zurück Logical Wert: nein, oder falsh. In dem unteren Tabelle wir fassen zusammen die Wichtige operatoren der Sprache.

\begin{table}
\caption{Arithmetic operatoren \label{oper}}
\centering
\begin{tabular}{|l c c|}
\hline
Operator & Expression & Wert der Expression \\
\hline
Zuweisung & $a$ = $b$ & Werte von $b$ \\
Addition & $a$ + $b$ & Summe von $a$ und $b$ \\
Subraktion & $a$ - $b$ & Differenz von $a$ und $b$ \\
Multiplikation & $a$ * $b$ & Produkt von $a$ und $b$ \\
Division & $a$ / $b$ & Quotient von $a$ und $b$ \\
Modulo & $a$ \% $b$ & Rest eine Ganzzahldivision von $a$ durch $b$ \\
Inckrement & $++a$,$a++$ & Präfix: $a$+1, Postfix: $a$ \\
Dekrement & $--a$, $a--$ & Präfix: $a$-1, Postfix: $a$ \\
Positiver Vorzeichenoperator & $+a$ & Wert von $a$ \\
Negativer Vorzeichenoperator & $-a$ & Wert von $a$ aber mit umgekehrte Vorzeichen \\
\hline
\end{tabular}
\end{table}

\begin{table}
\caption{Vergleichs operatoren \label{vergoper}}
\centering
\begin{tabular}{|l c|}
\hline
Operator & Expression \\
\hline
Prüfen auf Gleichheit & $a == b$  \\
Prüfen auf Ungleichheit & $a != b$ \\
Prüfen, ob $a$ echt größer als $b$ ist & $a>b$ \\
Prüfen, ob $a$ echt kleiner als $b$ ist & $a<b$ \\
Prüfen, ob $a$ größer oder gleich $b$ ist & $a>=b$ \\
Prüfen, ob $a$ kleiner oder gleich $b$ ist & $a<=b$ \\
\hline
\end{tabular}
\end{table}

\begin{table}
\caption{Logischen operatoren \label{vergoper}}
\centering
\begin{tabular}{|l c c|}
\hline
Operator & Expression & Wert \\
\hline
                                                &                                &   Wenn $a$ und $b$ beide waren wahr, \\
                                                &                                &   dann der Rückgabe ist wahr,  \\
\raisebox{1.5ex}{Operator für das Logische UND} & \raisebox{1.5ex}{$a \&\& b$ }  &   in jeden anderen Fallen falsch \\
\hline
                                                &                                &   Wenn $a$ oder $b$ war wahr, \\
                                                &                                &   dann der Rückgabe ist wahr, \\
\raisebox{1.5ex}{Opatoren für das logische ODER}& \raisebox{1.5ex}{$a ||    b$}  &   in den anderen Fall  falsch \\
\hline
                                                &                                &   Wenn $a$ ist falsch, die Rückgabe is wahr, \\
\raisebox{1.5ex}{Negationsopeator}              & \raisebox{1.5ex}{$!a$}         &   und umgekehrt \\
\hline
\end{tabular}
\end{table}
Ein Ausdrück (Expression) kann aus mehreren operatoren bestehen. In diesem Fall es ist wichtig, das regel des Reihenfolges
zu wissen. Es muss festgelegt werden welche operator im Zweifelsfall Priorität hat. Für alle Operatoren wir haben die
Prioritäten im Tabelle \ref{priortab} zusammen gefasst. Wenn zwei operatoren gleichem Prioriät haben, dann zum ersten 
mal der linkste wird verarbeitet, and danach von links nach rechts\footnote{Hier gibt es ausnahme, wenn die Reihenfolge 
ist umgekehrt. Siehst denn letzten Spalte im Tablellen \ref{priortab}}. Zum Bespiel sehen wir die untere einfache Programm:
\begin{lstlisting}
#include<stdio.h>
int main(){
  int a=3;
  int b=4; 
  int c=5;
  printf( "%d\n", a -  b + c );
  printf( "%d\n", a - (b + c));
  printf( "%d\n", a + a++ ); /*Falsch*/
}
\end{lstlisting}
In diesem Programm wir haben drei Variablen mit Wert von ganzen Zahlen definiert. In der fünften Reihe wir möchten das
Ergebnis des Ausdrucks: $a-b+c$ ausdrücken. Das Subtraktion is linksassoziativ, darum wird die Ausdrücke von links nach
rechts ausgewertet. Das Ergebnis wird vier sein. In der sechsten Reihe wir haben eine Klammerung eingeschlossen. Das wird
wird die Reihenfolge ändern. Zuerst wird das Teil inner der Klammerung verarbeitet, and nur danach das Subtraktion. 
Das Ergebnis wird -6 sein. Es ist wichtig zu erwähnen, das die Reihenfolge der Ausführung von den Teilen ist nicht definiert.
Wir zeigen das in der siebten Linie. Hier wir wissen nicht voraus, ob $++a$ oder $a$ wird verarbeitet zuerst. Darum ist
diese Ausdrücke undefiniert.



\begin{table}
\caption{Priorität tabelle für operatoren in der C Sprache\label{priortab}}
\centering
\begin{tabular}{| l c c|}
\hline
Operator & Beschreibung    & Associativity  \\
\hline
( )      & Funktionsaufruf & links  \\
$[ ]$     & Array-Index     & links  \\
-> .     & Memberzugriff   & links \\
++ -- 	 & Postfix Inkrement, dekrement &rechts \\
\hline
++ --    & Präfix  Inkrement, dekrement &rechts \\
! ~      & Negation (logisch, bitwise)  &rechts \\
+ -      & Vorzeichen (unär)            &rechts \\
(Typename) & cast                       &rechts \\
* \&       & Dereferenzierung, Adresse  &rechts \\
\hline
* /        & Multiplikation, Division     &links \\
\%         & Modulo                       &links \\
\hline
+ -        & Summe, Differenz (binär)     &links \\  
\hline
<<, >>     & Bitweise schieben            &links\\
\hline
< <=       & Vergleich: kleiner, kleiner-gleich      &links\\
> >=       & Vergleich: Größer, größer-gleich        &links\\
\hline
== !=      &Gleichheit, Ungleichheit                 &links\\
\hline
\&         & Bitweises UND & links \\
\hline
\^{}         & bitweises Exlusives-ODER &links\\
\hline
|          & bitweises ODER           &links\\
\hline
\&\&       & logisches UND            &links\\
\hline
||         & logisches ODER           &links\\
\hline
?:         & Bedingte Ausertung       &rechts\\
\hline
=          & Wert Zuweisung           &rechts\\
\hline
-=, +=,*=,/=,   &                     &      \\
\&=,|=,\%=,\^{}=&                     &      \\
,<<=, >>=& \raisebox{1.5ex}{Kombinierte Zuweisungsoperator} & \raisebox{1.5ex}{rechts}\\
\hline
,                                   & Komma-operator                 & links \\
\hline
\end{tabular}
\end{table}

\subsubsection{Kontrollstrukturen}

Wir haben einfachste Anweisungen kennen gelernt, die nacheinander ausgeführen waren. In diesem Teil werden wir lernen wie mann die Reihenfolge 
der Ausführung ändern kann. Zum Bespiel wenn wir möchten das Absolutwert  eines Zahlen herausfinden, wir die Anweisung wird von dem Aktuellen Wert
der Variable abhängen. In diesem Fall wir können nutzten das sogennante $if~then~else$ Statement. Die korrekte Verwendung siehts du unter im
kleinen Quelltext:
\begin{lstlisting}
#include<stdio.h>
int main(){
  int a=4;
  int absolutevalue=0;
  if ( a >  0 )
  {
     absolutevalue= a;
  }
  else
  {
     absolutvalue= -a;
  }
}
\end{lstlisting}
In der dritten  Reihe wir haben Variable $a$ als eine ganze Zahl definiert mit Anfangswert vier. In der vierten Reihe wir haben eine
Variable für das Ergebnis definiert. In der fünften Reihe kommt das Selektion Anweisung mit dem Stichwort $if ()$. In dem 
Klammerung muss ein Logikalische Ausdrückung stehen. Wir sind schon bereit für die Verwendung der Vergleichs operatoren (Tabelle \ref{vergoper}). 
Die Größer operator steht zwischen zwei Ganzen Zahl: das Ergebnis der Ausführung von $a$ und $0$. Natürlich wissen wir das in diesem Fall das
Ergebnis in der Klammerung wird wahr sein, und die  Anweisungen  zwischen  der geschweiften Klammern von der der sechsten bis der
achten Reihe werden ausführen. In diesem Fall es gibt nur eine Anweisung, aber man kann mehrere Anweisungen haben. Wenn das
Wert der Variable $a$ Negativ gewesen wäre, wäre die Anweisungen in der Block nach $else$ durchgefahren. In der Bedingung
0 wird als Falsch erwertet, alle anderen Zahlen werden recht. Wenn wir möchten, wir
können die ganze else Block entfallen. Hier wir zeigen auch die Allgemeine Verwendung des if then else Statements.

\begin{lstlisting}{if then else Statement}
if ( logikalische Ausdruckung )
{
   Anweisungwahr1;
   Anweisungwahr2;
   ...;
}
else
{
   Anweisungfalsch1;
   Anweisungfalsch2;
   ...;
}
\end{lstlisting}
Wir können auch Gesschachtelte if und else Statements nutzten. Zum Beispiel Anweisungwahr1 kann auch if und else Statement sein.

Wenn mann mehrfache Alternativen haben will kann mann auch die Switch Anweisung nutzten. In diesem Fall wir müssen 
alle Möglichkeiten für der Bedingungen bei der Kompilierung wissen. Wir lesen zum Beispiel in dem unteren Quelltext eine
ganze Zahl von Standard Eingang, und machen einige Testen um ihre Wert.
\begin{lstlisting}
#include<stdio.h>
int main(){
  int n=0;
  scanf("%d",&n);
  switch ( n ) {
     case 0: 
         printf("Der Wert is 0\n");
         break;
     case 1:
         printf("Der Wert is 1\n");
     case 2:
         printf("Der Wert kann auch 1 oder 2 sein\n");
         break;
     case 3:
         printf("Der Wert is 3\n");
         break;
     default:
         printf("Ich weiss es nicht\n");
     
  }
}
\end{lstlisting}
In der vierten Reihe mit der scanf Funkcion, wir lesen ein Ganze Zahl vom Tastatur. Wir werden gleich mehr erzählen über die
scanf Funkcion. In der fünften Reihe beginnt der bedingte Anweisung. Jede Möglichkeiten beginnt mit dem Strichwort $case$.
Zum Beispiel wenn wir 0 typen, dann wird die siebten Reihe ausführen. In der achten Reihe der Strichwort $break$ bedeutet, dass
das Ausführung wird nachdem $switch$ Blocke fortsetzen. Wenn wir 1 typen, dann die Bedingung in der Reihe neun wird wahr sein, und
die Befehle in der zehnten und zwölften Reihen werden verarbeitet. Die Anweisungen werden verarbeitet bis den nächsten $break$ 
Strichwort. Wenn keine der Möglichkeiten passt, dann wird die Anweisungen nach $default$ verarbeitet.  Wir zeigen die allgemeine
Verwendung unter:

\begin{lstlisting}
  switch ( Variable mit Ganze Zahl Wert )
  {
     case Wert1:
         Anweisung1;
         .... ;
         break; /* Optionall */
     case Wert2:
         Anweisung2;
         ....; 
         break; /*Optional */
     ....
     default:
         Anweisung3;

  }
\end{lstlisting}

Es ist auch wichtig die gleiche Anweisung auf unterschiedlichen Data ausführen. Zum Beispiel wir wollen die Summe der ersten
$n$ ganzen Zahl kalkulieren. In diesem Fall müssen wir Schleifen verwenden. 
\begin{lstlisting}
#include<stdio.h>
int main(){
   int i,n;
   int summe;
   scanf("%d\n", &n);
   for (i=0; i<n; ++i){
     summe += i; 
   }
   printf("Summe von ersten %d ganze Zahlen ist %d\n", n, summe);
}
\end{lstlisting}
\begin{myalertblock}{For Kontrollstrukture}
\begin{lstlisting}
for ( Ausdruck_1; Ausdruck_2; Ausdruck_3) 
{
   Anweisungen;
}
\end{lstlisting}
\vspace{-1cm}
\begin{enumerate}
\item Zuerst Ausdruck\_1 wird ausführen.
\item Dann wird Ausdruck\_2 ausführen.
\item Wenn das Ergebnis im zweiten Punkt Wahr ist, die Anweisungen 
in dem Kern der Schleife werden Ausführen
\item Ausdruck\_3 wird ausführen
\item Die Ausführung wird weitermachen ab Punkt 2.
\end{enumerate}
\end{myalertblock}


Die Kontrollstrukture ist bezeichnet als $for$. Die Schleife besteht aus drei verschiedenen Schritte.
Initializierung die Schleifen Variable $i=0;$. Danach kommt die Ausführung der Schleifen Bedingung: $i<n$.
Danach der Kern der Schleife wird ausführen, außerdem wir 0 getippt haben. Am ende des Schleifen Kerns,
die Schleifenvariable ist ikrementiert und die Bedingung ($i<n$) wird testet nocheinmal und so weiter.
Zusammenfassend der Schleifen Kern wird $n$ mal verarbeitet, und endlich in der Sum Variable wir 
werden die Summe haben.

Wir dürfen auch alle Ausdrucke entfallen,  aber wir müssen beachten um die Schleife nur Endliche mal 
verarbeitet werden. Zum Beispiel die Initializierung kann auch vor der Schleife sein. Die Inkrementierung 
der Schleife variable kann auch im Schleifen Kern inbegriffen. Wir können auch der Strichwort $break$ nutzen 
in einem Selektion um die Schleife zu beenden. Wir zeigen unsere Beispiel mit diesen Änderungen unter:

\begin{lstlisting}
#include<stdio.h>
int main(){
  int n;
  int summe:
  int i;
  scanf("%d", &n);
  i=0;
  for (;;){
   if (i==n)
     break;
   summe += i;
   i++;
  }
  printf("Summe von ersten %d ganze Zahlen ist %d\n", n, summe);
}
\end{lstlisting}
C Sprache hat zwei anderen Kontrollstrukturen für die Schleife. Das sind $while;$ und $do; while$.
Natürlich die diesen Schleifen können auch mit for ersetzen, aber manchmal es ist gut sie zu wissen.
Sie werden often als vortester und nachtester Schleifen bezeichnet. Es gibt eine Große unterscied zwischen
$while$ und $do~while$. Im $do~while$ der Kern wird mindestens einmal verarbeitet. 

\begin{myalertblock}{While Kontrollstrukture}
\begin{lstlisting}
while ( Ausdruck_1 )
{
   Anweisungen;
}
\end{lstlisting}
\vspace{-0.5cm}
Bis der Wert von Ausdruck\_1 Wahr ist, die Anweisungen werden verarbeitet.
\end{myalertblock}

\begin{myalertblock}{Do While Kontrollstrukture}
\begin{lstlisting}
do
{
   Anweisungen;
}
while (Ausdruck_1)
\end{lstlisting}
\vspace{-0.5cm}
Die Anweisungen werden verarbeiten bis der Wert von Ausdruck\_1 Wahr ist.
\end{myalertblock}

\subsubsection{Arrays und Pointers}

Wir haben fast mit allem Operatoren im Tabelle \ref{prior} getroffen außer die Adresse und die Dereferenzierung.
Die Adresse Operator gib die Adresse die Variable von ihrem Rechte Seite. Um diese Wert speichern zu können in 
der linkste Seite muss ein Pointer stehen.  

\begin{myblock}{Definition \texttt{Pointer}}
Ist ein Variable, das Adresse von anderen Variablen speicher kann. Hat auch ein Typ.
Das Pointer kann nur von solchen Variable Adresse speichern, die die gleichen Typ haben.
\end{myblock}

Wir können für alle Variable Pointer definieren. Aber warum komplizieren wir unseren Leben mit Pointers.
Welche Vorteile werden wir haben, wenn wir ihnen verwenden können. Zum Beispiel, wir möchten 
eine Funktion schreiben, das ihre Eingabe Parameter inkrementiert. Nehmen wir an, das unsere
Funkcion zwei Parameter hat, und soll beide inkrementieren\footnote{Wenn du nur eine Parameter
inkrementieren willst, du könntest auch die Rückgabewert deines Funkcion verwenden.}.
Unsere erste Versuch für die Lösung kannst du unter sehen.

\begin{lstlisting}
#include<stdio.h>
int inc( int a, int b){
   a++;
   b++;
}
int main(){
  int a=2;
  int b=3;
  printf("Wert vor dem Funkcion a=%d, b=%d\n", a,b);
  inc( a, b);
  printf("Wert nach dem Funkcion a=%d, b=%d\n", a, b); 
}
\end{lstlisting}


\subsubsection{Formattierte Eingabe und Ausgabe}

\begin{myexampleblock}{Function definition \texttt{printf}}
int printf(char * formattierung\_text, $\cdots$);
\begin{itemize}
\item Rückgabe Wert: Der Anzahl der ausgedrückten Zeichen
\item Parameters:
\begin{enumerate}
\item formattierung\_text: Eine Zeichenkette, beendet mit dem \'{}\\0\'{} Zeichen, specifiziert wie mann die Daten
audrücken will
\end{enumerate}
\end{itemize}
\end{myexampleblock}


\pagebreak


%as Körper, das C code kannst du oben sehen. Alle C programm besteht aus Funkcionen. Wir nennen function ein part of the code, was eine
%estimmte aufgabe erledigt.
%u wirst es gleich finden, dass du muss zuerst lernenDu musst zuerst den einladen, was jemanden
%eschrieben hat. Zum beispiel, zu computer printen du sollst stdio.h einladen. Sie
%ehören nicht zu den sprache . Danach kommt deine arbeite. Zuerst du sollst andenken was für ein ergebnis deine aufgabe haben soll und
%ie viele eingangsparameter deine programm hat. Du sollst denen es variablen deklarieren. Jetzt kommt die wichtigsten Teil des Program, die
%unktionen. Diese teil rechnet aus den eingangsparameter deine Ergebnis. Es gibt ein specielle function was jeden programm haben
%oll. Das nahme of diese funcktion ist main. Von diesem Punkt beginnt die Ausführung. Wir werden mehr um funckcionen später lernen. 

%Im fünften Linie illustrieren wir, dass das Name der Variable nicht mit einem Zahl beginnin darf. Eine practical Beratung ist initializerien
%alle Variables recht im Definition. 
%enn zwei operatoren gleichem Prioriät haben, dann zum ersten mal der linkste wird verarbeitet, and danach 
%on links nach rechts\footnote{Hier gibt es ausnahme, wenn die Reihenfolge ist umgekehrt. Siehst denn letzten Spalte im Tablellen \ref{priortab}}. 


\begin{lstlisting}{Einf\"ugesortieren in C: Körper }
#include<stdio.h>
void read_in_data( int n, int sort[], int unsort[], int argc, char *argv[]){
statements a1;
statements b1;
...
}
void einfugesortieren( int n, int sort[], int unsort[]){
statements a2;
statements b2;
...
}
void print_out_data( int n, sortiert){
statements a3;
statements b3;
...
}
int main( int argc, char *argv[])
{
  int n=4;
  int sortiert[n];
  int unsortiert[n];
  read_in_data(n, sortiert, unsortier, argc, argv);
  einfugesortieren(n,  sortiert, unsortiert);
  print_out_data( n, sortiert);

}
\end{lstlisting}
Das Körper, das C code kannst du oben sehen. Alle C programm besteht aus Funkcionen. Wir nennen function ein part of the code, was eine
bestimmte aufgabe erledigt. 
Du wirst es gleich finden, dass du muss zuerst lernenDu musst zuerst den einladen, was jemanden
geschrieben hat. Zum beispiel, zu computer printen du sollst stdio.h einladen. Sie
gehören nicht zu den sprache. Danach kommt deine arbeite. Zuerst du sollst andenken was für ein ergebnis deine aufgabe haben soll und
wie viele eingangsparameter deine programm hat. Du sollst denen es variablen deklarieren. Jetzt kommt die wichtigsten Teil des Program, die
Funktionen. Diese teil rechnet aus den eingangsparameter deine Ergebnis. Es gibt ein specielle function was jeden programm haben
soll. Das nahme of diese funcktion ist main. Von diesem Punkt beginnt die Ausführung. Wir werden mehr um funckcionen später lernen.
 

Zum beispiel in C sieht die obene Auflistung so aus:
\begin{lstlisting}{Einf\"ugesortieren in C}{
1: int n=4;
   int unsortiert[n],  sortiert[n];
2; sortiert[0]=2;
3; unsortiert[0]=9; 
   unsortiert[1]=5;
   unsortiert[2]=7;
4; for (int i=1; i<n-1;++i){
      sortiert[length]=unsortiert[i]
5-6;   for (int j=length-1; j>0; --j){
         if (sortiert[j+1]<sortiert[j]){
            int tmp=sortiert[j];
            sortiert[j]=sortiert[j+1];
            sortiert[j+1]=tmp;
         }
         else{
          break;
         }
      }
      length++;
   }
}
\end{lstlisting}
''for`` steht f\"ur Schleife und wir nutzten das "A" array 
Warum solltest du C programmier sprache lernen? Es gibt viele Antwort auf diese Frage. Zum Beispiel:
\begin{itemize}
\item C ist nicht kompliziert
\item C ist sehr effizient
\item C hat high level konstrukte
\end{itemize}
Aber M\"oglicherweise das beste Antwort ist das C Kenntnisse ist unbedingt in Forschungsrechnungen. Die meisten Programme,
der zum Stand der Technik geh\"oren sind C programme. In diesem Kurz wir werden diese Sprache kennenlernen. Zuerst 
wir zusammenfasseen was in der Sprache inbegriffen ist. Du wirst dich verwundern, das die einfachste funktion, was
nur etwas auf deinem Monitor zeigt, geh\"ort nicht zu der Sprache. Wir vorstellen das k\"orper einem durchschnittlichen
C program und erkl\"aren sein Teilen. 

Danach z\"ahlen wir die Komponenten der Sprache auf. Das wird beginnen mit der data Typen und Operationen, in denen wir 
die Typen nutzen k\"onnen. Wir werden alle elementare Data type lernen. Mit Variablen aus diesen Typen k\"onnen wir Operationen machen, 
die unsere Ergebnisse herstellen werden. Dann werden wir elementare Statements und Expressions einf\"uhren, mit denen 
wir kleinen Aufgaben l\"osen k\"onnen. 
  
Es is sehr wichtig, dass unsere Programm Parameter erhalten zu k\"onnen. Wir k\"onnen das erreichen durch Funkcionen.
Die Funkcionen arbeiten wie schwarze K\"asten. Sie stellen von den Eingangsparameter ein neues Wert her. Wir zeigen, 
wie man die Standart Eingabe und Ausgabe Bibliothek nutzten kann. Nachdem wir diese F\"ahigkeiten verstehen, werden wir etwas
komplizierte \"Ubungen schreiben.

Often gibt es Situationen in den wir mehr als Ein ergebnisse von einem Funktionen wollen. Um das erreichen
m\"ussen wir die Addressirung der Memorie kennen zu lernen. In diesem Punkt werden wir auch lernen, wie man 
strings verwendet kann.

In einem sch\"onen Programm wir nutzten das wenigstens Speicher. In diesem Punkt wir werden lernen, 
wie die Speicherverwaltung behandelt wird.

Im ersten Teil des Kurses wir haben die elemetare datatypen kennen gelernt. In diesem Punkt wir
werden lernen, wie mann eigenes Daten Structure herstellen kann. Überhaupt, Warum and Wenn müssen wir neue Structure herstellen.
Unser Programm mit eigenen Daten strukturen wird leichter lesen zu können. Das ist sehr wichtig. Typischer fehler der Angefangenen Programmern
ist, dass ihr Code ist sehr schwer zu lesen auch für Sie, und nach einem Monat Sie müssen die ganze Programm
wieder schreiben. Zum beispiel muss mann eigenes Datenstrukture nutzen, wenn man ein operations sehr often erledigen muss.
Zum bespiel in der Sorierung eines List, man kann die Daten in einem binären Suchbaum einschließen um die suchen schneller zu lassen.

\section{Der Körper des C programms}

\begin{lstlisting}{caption= Do nothing}
#include<stdio.h>
int main( int argv, char *argv[])
{
/* do nothing */
}
\end{lstlisting}
Welche Teile hat ein C programm. 
Du wirst es gleich finden, dass du muss zuerst lernenDu musst zuerst den einladen, was jemanden 
geschrieben hat. Zum beispiel, zu computer printen du sollst stdio.h einladen. Sie
gehören nicht zu den sprache . Danach kommt deine arbeite. Zuerst du sollst andenken was für ein ergebnis deine aufgabe haben soll und
wie viele eingangsparameter deine programm hat. Du sollst denen es variablen deklarieren. Jetzt kommt die wichtigsten Teil des Program, die
Funktionen. Diese teil rechnet aus den eingangsparameter deine Ergebnis. Es gibt ein specielle function was jeden programm haben
soll. Das nahme of diese funcktion ist main. Von diesem Punkt beginnt die Ausführung. Wir werden mehr um funckcionen später lernen.  
%\section{Was ist Programmieren}
%Es gibt ein Problem, Sie müssen die Lösung finden. What we call input variables? What are the output variables? Specific problem?
\section{Definitionen, Statements}
Die Variablen haben Wert und Typ. Warum ist das Typ der Variable wichtig? Es hängt vom Typ ab, was für ein Wert eine Variable haben
kann. Das Typ entscheid also die Grösse des Arbeitspeicher zu deine Variable. Mann kann nun solche Funkcionen und Operatoren nutzen, das 
genanue Datentype hat. Es gibt elementare data Typen mit dem wir spielen können. Sie sind
\begin{itemize}
\item char
\item int
\item float
\item double
\end{itemize}
Im char können wir eine character speichern(die bereich?). Größe, im können wir ein Ganzzeil spiechern von wert 0 bis 2**32-1 größe. 
Im fließkommazahl von bis speichern grösse.
\subsection{Mein erstes C programm}
von linein bis linien wir erklären Einfachste Programm der Welt "Hello World.c"
Ein bisschen schwerer aufgabe, sie müssen ausrechnen die Würzel einer quadratische Gleichung. 
\section{Aufgaben}
\subsection{Zufallszahlgenerator}
Zufällige nummer sind sehr wichtig für uns. In numerischen physik wir nutzten Zufallszahlen ganz often. Zum Beispiel 
in die einfachsten method für integration of mehreren variablen Funkctions müssen wir Monte Carlo algorithm nutzten. Die
enthalten statements, die vom Werte auf Zufällige variablen abhängt. In dieser Aufgabe wir müssen eine Zufallszahlgenerator
schreiben. Es gibt mehrere methode dazu, aber alle stammt aus linear Kongruenzen:
\begin{equation}
I_{j+1}=a I_{j} \left( \mathrm{mod} m\right).
\label{basics}
\end{equation}
Diesen Instruktion macht eine neue Zufallszahl ($I_{j+1}$)  aus einem original ($I_j$). Der qualität der Zufallszahl generator
hängt von dem eingangsparameters (a,m) ab. Eine gute Zufallszahlgenerator hat große period, die Zeit zwischen den beiden gleichen
Zufallszahl muss sehr groß sein. Park und Miller hat die folgenden parameter für a und m gewählt:
\begin{equation}
a=16807, m=2^{31}-1=2147483647. 
\end{equation}
Leider direkte implementation der Zufallszahlgenerator mit deisen parameters ist nicht möglich in C. Der grund ist
wir können nicht speichern Zahlen grossen als $m$. Zum glück gibt es eine möglichkeit das Problem umzugehen. 
Wir faktorizieren $m$:
\begin{equation}
m= aq + r; r= m \left(\mathrm{mod}a\right); q= \left[m/a\right]
\end{equation}
Damit können wir Gleichung \ref{basics} auch bewerten mit ($q,r$):
\begin{equation}
a I_j \left( \mathrm{mod} m\right)=  
\left\{ \begin{array}{rc}
a\left(I_j \mathrm{mod} q\right) -r \left[I_j/q\right] & \mathrm{wenn~es~}>0\mathrm{ist} \\ 
a\left(I_j \mathrm{mod} q\right) -r \left[I_j/q\right] + m & \mathrm{andernfalls} \\ 
\end{array}\right.
\label{algo}
\end{equation}
wo $r=2836,q=127773$ ist. Implementieren Sie das Zufallszahlgenerator nach eq.\ref{algo}. Ändern Sie die Algorithm
um die Zahlen zwischen 0 und 1 zu sein werden.
Es ist wichtig zu test unser Ergebnis. Wir müssen kontrollieren die Verteilung (Distribution) der Zufallszahlgenerator.
Wir möchten gleichmäßige vertailung zu erreichen. Wir werden eine Histogramms machen aus dem Zufallszahlen. Wir teilen 
das Interval in $n$ Teilen und zahlen wie oft die Zufallszahl in jedem Interval sinkt. Machen Sie ein Histogramm aus 
den Verfügbaren daten und prüfen wie gleichmäßig der Verteilung ist!
\section{Elementare operatoren}
\subsection{Binäre, Aritmethic operatoren}
+,-,*,/, \%, ++, -- 
\subsection{Gleichungen}
==,!=, >,<, >=,<=
\subsection{Bitwise}
\&,|,\^, ~, >>,<<
\subsection{Zuweisungsoperator}
=,+=,-=,|=,\&=,\^=,\%=,<<|,>>|,
\subsection{Aufgaben}
Programm rechnet die Wurzel, der gleichung
\section{statements}
\subsection{Schleifen}
Was ist wichtig, wenn wir ein Schleifen plan? Wir müssen nicht überschreiben eine existierte variable. Wir müssen keine
statements haben, was nicht von der Schleifenzahlnummer abhängt.
\subsection{If then else}
\subsection{case}
\subsection{Standard input, output}
\subsection{Conways Spiel des Lebens}
Wir habe eine quadrate Gitter. In alle Zell der Gitter eine zwei hältige variable. Es sagte uns, wenn der
kleine microbe im Zell, lebt oder nicht.
\section{Funkcionen}
\section{Addressierung}
\subsection{Stackel(LIFO)}
\subsection{Fifo}
\subsection{Umgekehrte Polnische Notation}
\section{Dynamische speicherverwaltung}
\section{Daten strukturen}
\subsection{Ketten listen}
\subsection{Bäumen}
\subsection{Recursive functionen, Schnell sortieren}
\end{document}
