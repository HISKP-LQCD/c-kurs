\documentclass{article}[12pt]
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

\usepackage[dvipsnames]{xcolor}
\usepackage{lipsum}

\usepackage{amsfonts}
\usepackage[intlimits]{amsmath}
\usepackage{cite}
\usepackage{epsfig}

\usepackage[usenames,dvipsnames]{pstricks}
\usepackage{pstricks-add}
\usepackage{epsfig}
\usepackage{pst-grad} % For gradients
\usepackage{pst-plot} % For axes

\addtolength{\hoffset}{-1.5cm}
\addtolength{\textwidth}{3cm}
\usepackage{listings}
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\PassOptionsToPackage{svgnames}{xcolor}
\usepackage{tcolorbox}
\usepackage{lipsum}
\tcbuselibrary{skins,breakable}
\usetikzlibrary{shadings,shadows}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=C,                      % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}


\newenvironment{myexampleblock}[1]{%
    \tcolorbox[beamer,%
    noparskip,breakable,
    colback=White,colframe=ForestGreen,%
    colbacklower=LimeGreen!75!White,%
    title=#1]}%
    {\endtcolorbox}

\newenvironment{myalertblock}[1]{%
    \tcolorbox[beamer,%
    noparskip,breakable,
    colback=White,colframe=Bittersweet,%
    colbacklower=Peach!75!White,%
    title=#1]}%
    {\endtcolorbox}

\newenvironment{myblock}[1]{%
    \tcolorbox[beamer,%
    noparskip,breakable,
    colback=White,colframe=RoyalBlue,%
    colbacklower=TealBlue!75!White,%
    title=#1]}%
    {\endtcolorbox}

\newenvironment{myexampleprogram}[1]{%
    \tcolorbox[beamer,%
    noparskip,breakable,
    colback=White,colframe=Goldenrod,%
    colbacklower=Yellow!75!White,%
    title=#1]}%
    {\endtcolorbox}
%--------
%\usepackage[magyar]{babel}
\title{C Programmierkurs}
\begin{document}
\maketitle
\include{intro}
%In einem sch\"onen Programm wir nutzten das wenigstens Speicher. In diesem Punkt wir werden lernen,
%wie die Speicherverwaltung behandelt wird.

%Im ersten Teil des Kurses wir haben die elemetare datatypen kennen gelernt. In diesem Punkt wir
%werden lernen, wie mann eigenes Daten Structure herstellen kann. Überhaupt, Warum and Wenn müssen wir neue Structure herstellen.
%Unser Programm mit eigenen Daten strukturen wird leichter lesen zu können. Das ist sehr wichtig. Typischer fehler der Angefangenen Programmern
%ist, dass ihr Code ist sehr schwer zu lesen auch für Sie, und nach einem Monat Sie müssen die ganze Programm
%wieder schreiben. Zum beispiel muss mann eigenes Datenstrukture nutzen, wenn man ein operations sehr often erledigen muss.
%Zum bespiel in der Sorierung eines List, man kann die Daten in einem binären Suchbaum einschließen um die suchen schneller zu lassen.
\include{speichernausdrucken}
\include{variablen}
\include{kontrollstrukturen}
\include{pointersarrays}

\begin{myexampleprogram}{ Programme: \texttt{Einfügesortieren}}
%\begin{myexampleprogram}{ Programme: \texttt{Einfügesortieren}}
Für Zusammenfassung der ersten Teil des Buches wir werden eine komplizierten Aufgabe Zeile für Zeile lösen.
Wir werden ganzen Zahlen mit dem Algorithmus vom Einfügesortieren sortieren. Die Aufgabe ist die Folgende:
Wir müssen $int$ Zahlen aus einem File einlesen, und wir müssen ihnen sortieren. Es ist gut zu errinern, 
dass alle Teil des Problems, der gut getrennte Aufgabe hat, müssen wir als ein Funktion verwirklichen.
In diesem Beispiel müssen wir ein Funkcion für readin (Einlesen) und für Sort (sortieren) schreiben.
Danach müssen wir über die Eingabe und Rückgabeparameters der Funkcions entscheiden.
Das read Funktion wird das Nummer der Zahlen in dem File bestimmen und die Zahlen in einem Array
speichern. Dies kann mit einem int Rückgabewert (Nummer des eingelesenen Zahlens) und mit einem Array
(speicher für die Zahlen) Eingabeparamter erreichen.

Wir werden für Einlesen der $scanf()$ Funkcion verwenden. Wir haben auch diesen Funktion für 
Einlesen verwendet. Hier wir nutzen auch ihre Rückgabewert. Wenn diese Rückgabewert $EOF$ ist, 
das bedeutet, dass wir das Ende des Files erreicht haben. Der Wert von EOF ist im $stdio.h$ definiert, 
und es ist -1.
\begin{lstlisting}
#define MAXNUM 10000
int read( int array[] ){
  unsigned int i;
  for (i = 0; i < MAXNUM; i++){
    if ( scanf("%d\n", &array[i])== EOF )
    break;
  }
  if (i == MAXNUM)
  printf("Sorry, wir konnten leider nicht die ganze Datei einlesen.");
  return i;
}
\end{lstlisting} 
In der ersten Zeile wir haben eine Symbolische Konstante definiert um die maximale Größe des
Arrays feststellen. Wir haben eine lokale Variable $i$, das die Nummer vom eingelesenen Zahlen speichert.
Wenn die Rückgabewert von scanf EOF ist, wir beenden die Schleife, und geben der Wert von $i$ zurück.
Wenn wir unsere Grenze erreicht haben, drücken wir eine Nachricht aus.
Das war ganz einfach nur 9 Zeilen. Jetzt müssen wir der Funktion für Sortieren schreiben.
\begin{lstlisting}{}{
#define SWAP(x, y) do { typeof(x) swap = x; x = y; y = swap; } while (0)
void Sort( int unsortiert[], int n ){
   int sortiert[MAXNUM];
   int i,j;
   for (i=0; i<n; ++i){
     sortiert[i]=unsortiert[i];
     for (j=i; j>0; --j){
        if (sortiert[j] < sortiert[j-1] ){
           SWAP( sortiert[j], sortiert[j-1] );
        }
        else
           break;
     }
   }
   for (i=0; i<n; ++i)
     unsortiert[i]=sortiert[i];
}
\end{lstlisting}
Zuerst müssen wir erwähnen, dass unsere Sort Funktion hat zwei Eingabeparameter (das Array, das
wir sortieren möchten und ihre länge) und hat keine Rückgabewert. Nach dem Algorithmus 
wir haben am Anfang zwei Arrays, eine sortierte und eine unsortierte. Dann haben wir die Schleife für die 
Elementen des unsortierten Arrays. In jedem Schritt wir ziehen die aktuallen Elemente vom unsortierten Array
zur Ende des sortierten Arrays (Zeile 7) um. Danach suchen wir für ihre rechtige  Position.
Wir tauschen es mit dem Vorherigen aus bis es auf der richtigen Position ist. Wenn wir die richtige 
Position gefunden haben, beenden wir die Schleife mit $break$.
Wir haben ein Macro definiert um die Tauschen zu erledigen. das wir nützlich sein, weil wir es nicht nur
hier verwenden können. Im Macro wir haben zwei Eingabeparameter, die Zahlen (die Variablen), die wir tauschen 
wollen. Es hat auch eine do while Schleife, aber die Anweisungen in der Schleifenkern werden nur einmal Ausführen. 
Wir brauchen die Schleife weil wir eine lokale Variable von Namen $swap$ hergestellt haben. Die
Laufdauerzeit der swap Variable is nur diese drei Anweisung in dem Schleifenkern. Zum Ende 
wir kopieren die Werten aus dem sortierten Array zum unsortierten, weil der sortierte Array auch lokale ist.

\begin{lstlisting}
#include<stdio.h>
#define MAXNUM 10000
int read( int array[] ){
   int i;
   for (i=0;i<MAXNUM;i++){
     if ( scanf("%d\n", &array[i])== EOF )
      break;
   }
   if (i==MAXNUM)
     printf("Sorry, wir konnten leider
             nicht das ganze File gelesen.");
   return i;
}
#define SWAP(x, y) do { typeof(x) swap = x; x = y; y = swap; } while (0)
void Sort( int unsortiert[], int n ){
   int sortiert[MAXNUM];
   int i,j;
   for (i=0; i<n; ++i){
     sortiert[i]=unsortiert[i];
     for (j=i; j>0; --j){
        if (sortiert[j] < sortiert[j-1] ){
           SWAP( sortiert[j], sortiert[j-1] );
        }
        else
           break;
     }
   }
   for (i=0; i<n; ++i)
     unsortiert[i]=sortiert[i];
}
int main(){
   int array[MAXNUM];
   int i;
   int actual_legth=read(array);
   Sort(array, actual_length );
   for (i=0; i<length; ++i)
     printf("%d\n", array[i]); 
}
\end{lstlisting}
Jetzt grundsätzlich wir haben alles um das Programm vervollständigen.
Der main Funktion besteht aus nur 6 Zeile, mann kann es ganz einfach zu verstehen. Das
ist das größte Vorteil der modulierten Programmierung. Um unseren Quelltext verwenden zu können,
wir müssen zuerst es kompilieren.
\begin{lstlisting}
gcc myerste.c -o myerste
\end{lstlisting}
In diesem Fall das Name des ausführbaren Dateins ist $myerste$. Lasst uns annehmen, dass wir die folgende Datein unter dem Namen "Datequelle.txt" 
hergestellt haben:
\begin{lstlisting}
12
77
25
43
4
\end{lstlisting}
Dann wir können unsere Programm ausführen im Kommandoziele mit ihrem Name und das Quelle verwenden:
\begin{lstlisting}
./myerste < Datequelle.txt
\end{lstlisting}
Standardmäßig der $scanf$ Funktion lest aus dem Standardinput ein. Um aus dem Datein einlesen, wir müssen es
zum Standardinput richten  (Gleich werden wir lernen, wie können wir direkt aus einem File einlesen). Im bash 
wir können es mit dem "<" operator erledigen.
\end{myexampleprogram}

\subsection{Dynamische Speicherverwaltung}
Wir haben ein Sortieren geschrieben. Das ist Toll, aber wir können unsere Programme mindestens in drei Richtungen
verbessern:
\begin{enumerate}
\item In allen Fallen wir verwenden $MAXNUM$ int Variable von den Speichern. Es kann auch wenig sein (sieh unsere
Nachricht im read Funktion), aber es kann auch zu viel sein. Wenn wir zum Bespiel nur 100 Elementen haben, verschwenden
wir 99\% der erfordelichen Speicherzellen. Wir können dies überholen mit Hilfe der dynamische Speicherverwaltung.
\item
Obwohl der Algoritmus vom Einfügesortieren sehr einfach zu verstehen ist, es ist nicht der schnellste. Wenn wir 
$n$ Elementen sortieren wollen, die Zeit für die Sortierung skaliert quadratisch mit $n$. Wir können 
eigene Datentypen herstellen und damit besser Algorithmen implementieren, um unseres Programm schneller zu machen.
\item
Wir können auch das Input Teil verbessern. Zum Beispiel direkt aus einem Datein einlesen. Außerdem wir müssen
die logische zusammenhörende Teilen, die mehr als ~100 Zeilen haben, in eigenen Datein schreiben, und das Linker
verwenden in der Kompilirung verarbeiten.
\end{enumerate}
Zuerst werden wir kennenlernen, wie wir dynamische Speichern zugriffen können. Wir können das Memory in zwei Teile teilen:
\begin{enumerate}
\item Statische Memory. Dieses Part haben wir auch kennengelernt. Wenn wir eine Variable definieren, wir weisen zu ihr
Speicherzellen von diesem Platz. Es kann eigentlich mit ihrer Name zugegriffen werden. Ihre Lebensdauer und Sichtbarkeit 
hängt von ihrem Platz in dem Quelltext ab.
\item Dynamische Memory. Wir müssen das reservieren (es ist nicht automatisch, wie im Fall der Statishen Memory).
Dieses Memory wird zuverfügung stehen, bis wir sie explizit freigeben. Das bedeutet, das ihre Lebensdauer 
hängt nur von uns ab. Außerdem es ist sichtbar für alle Programmteil, die ihre Adresse haben. Dass
bedeutet, dass es kein eigene Name hat, und nur mit der Adresse zugegriffen werden kann.
\end{enumerate}
\begin{figure}[!ht]
% Generated with LaTeXDraw 2.0.8
% Tue Feb 28 11:46:41 CET 2017
% \usepackage[usenames,dvipsnames]{pstricks}
% \usepackage{epsfig}
% \usepackage{pst-grad} % For gradients
% \usepackage{pst-plot} % For axes
\scalebox{0.5} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-1.2792188)(31.8,1.2792188)
\psframe[linewidth=0.04,dimen=outer](31.8,1.1657813)(0.0,-1.0342188)
\psline[linewidth=0.04cm](5.6,1.1657813)(5.6,-1.0342188)
\rput(1.1,0.7 ){\LARGE Statische}
\rput(7.2,0.7 ){\LARGE Dynamishe}
\rput(1.1,0.1 ){\LARGE memory}
\rput(7.2,0.1 ){\LARGE memory}
\psline[linewidth=0.04cm](3.4,1.1657813)(3.4,-1.0342188)
\psline[linewidth=0.04cm](4.0,1.1657813)(4.0,-1.0342188)
\usefont{T1}{ptm}{m}{n}
\rput(4.416406,-1.5){\LARGE Pointer}
\psframe[linewidth=0.04,dimen=outer](18.2,1.1657813)(14.4,-1.0342188)

\rput(16,0.7 ){\LARGE Reservierte}
\rput(16,0.1 ){\LARGE Speicher}

\pscustom[linewidth=0.04]
{
\newpath
\moveto(4.,-2)
%\lineto(7.5,1.5)
\curveto(6,-3.)(10.5,-5.)(14.5,-1.5)
}
\end{pspicture} 
}
\vspace{0.6cm}
\caption{\label{abmem} Abteilung der Memory zur statischen, und dynamischen Teil.}
\end{figure}
Um Speicher dynamische zu reservieren wir können die Fuktionen aus Standardbibliothek 
verwenden. Zum Beispiel das $malloc$ Funktion. Alle Funktion in diesem Thema sind im $stdlib.h$
definiert. Der $malloc$ Funktion wird uns eine Pointer geben, mit dem wir die Speicher erreichen können.
Aber welchen Typ von Pointer will sie rückgeben. Wir brauchen annderen Typen jeden mal, wenn wir 
Speicher für anderen Typen reservieren wollen. Die Sprache bietet für dieses Fall 
der Pointer mit $void$ Typ. Natürlich wir können nicht ein Pointer von void Typ 
dereferenzieren, aber wir können ihn zu dem angemessenen Typ casten mit casting operator: (Typ *).
Nach jeder Reservierung müssen wir uns achten, ob es erfolgreich war, oder nicht. Wir müssen
prüfen ob der Wert vom Pointer nicht $NULL$ ist. Wir können von vielen Problemen vermeiden. 
Mit $malloc$ die reservierten Speoicherzellen werden nicht initializiert sein. Um das 
erreichen wir müssen $calloc$ Funktion verwenden.
\begin{myexampleblock}{Funktion definition \texttt{malloc}}
\begin{lstlisting}
void * malloc(size_t size);
\end{lstlisting}
\vspace{-0.7cm}
Reserviert Speicherzellen von größe $size$.
\begin{itemize}
\itemsep0.2pt
\item Rückgabewert: Wenn die reservierung erfolgreichs war, ein Pointer für den Anfang der 
reservierten Speicherzellen, anderfalls $NULL$.
\item Einggabeparamter: size: Größe von den begehrten Speicherzellen
\item Zum Beispiel:
\begin{lstlisting}
int *array=(int *)malloc(sizeof(int)*10);
\end{lstlisting}
\end{itemize}
\vspace{-0.7cm}
Achtung, wenn wir die reservierten Speicherzellen nicht mehr brauchen, müssen sie 
von uns freigegeben werden.
\end{myexampleblock}
Wenn wir in einem langen Programm immer mehr Speicherzellen reservieren, 
möglicherweise kurz können wir nicht mehr reservieren. Auf jedem Fall, wir müssen
die reservierten Speicherzellen so bald wie möglich wieder freigeben. Dafür steht
der Funktion $free$ zur Verfügung.
\begin{myexampleblock}{Funktion definition \texttt{free}}
\begin{lstlisting}
void free(void *memory);
\end{lstlisting}
\vspace{-0.7cm}
Freigib die Speicherzellen, die mit $malloc$ reservierten wurden.
\begin{itemize}
\item Einggabeparamter: Pointer für den Anfang der freigegebenen Speicherzellen
\item Zum Beispiel:
\begin{lstlisting}
free(array);
\end{lstlisting}
\end{itemize}
\vspace{-0.7cm}
\end{myexampleblock}

Wir können eindimensionale Vektoren entweder mit Pointers oder mit Arrays handeln.
Aber wie können wir mehrere dimensionale Objekte herstellen, was verstehen wir eigentlich 
unter 
mehrere dimensionale Objekte? Zum Beispiel wir sind ein zwei Dimenzion und wir haben 
Bewegungsvektoren $\vec{r}=\left(\begin{array}{c}x\\y\end{array}\right)$. Sie sind 
Vektoren (Eindimensionale Objekte), deren Koordinäten nur mit ein Zeichen vertreten werden
können. Zum Beispiel $\left(\vec{r}\right)_1=x$ und $\left(\vec{r}\right)_2=y$.
In diesem eine Lineare Operation, die aus einem Vektor ein neues herstellen, nennen
wir zwei dimenzionale Objekte. Zum Bespiel eine Drehung mit einem Winkel $\alpha$:
\begin{equation}
\left(\begin{array}{c}x^{,}\\y^{,}\end{array}\right)=
\left(\begin{array}{cc} \cos\left(\alpha\right) & \sin\left(\alpha\right) \\
                       -\sin\left(\alpha\right) & \cos\left(\alpha\right) 
\end{array}\right)
\left(\begin{array}{c}x\\y\end{array}\right)
\end{equation}
Das rotation kann durch eine Matrix dargestellt werden. Natürlich um diese Matrices
in C Sprache verwenden zu können, wir brauchen nur zwei dimensionale Arrays. Wir können
dies erreichen mit einem anderen eckigen Klammern, zum Bespiel 
\begin{lstlisting}
double rotate2d[2][2];
\end{lstlisting}
Aber wir haben gelernt, dass was wir mit einem Array machen können, können wir auch 
mit Pointers erledigen. In diesem Fall aber wir brauchen auch Pointers auf Pointers.
Wir zeigen in der Abbildung \ref{mem2d} was in diesem Fall passiert. Wir haben am Anfang 
eine Variable in statischen Speicherzelle mit Typ double Pointer auf Pointer.
Danach müssen wir Specherzellen reservieren für Pointers mit $malloc$. $malloc$ 
wird die Anfangadresse von den reservierten Speicherzellen rückgeben. Das wird der Wert
der Pointer auf Pointer Variable sein. Zum Ende wir müssen für jede Pointer Speicherzellen 
für zwei double Variable reservieren. Das ist alles. Wir zeigen auch das Quelltext zur diesen
Übung.
\begin{lstlisting}
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#define SPACEDIM 2 
int main(){
  double **array2d;
  int i,j;
  array2d=(double **)malloc(sizeof(double *)*SPACEDIM);
  for (i=0; i<SPACEDIM; ++i)
    array2d[i]=(double *)malloc(sizeof(double)*SPACEDIM); 
  array2d[0][0]= cos(M_PI/4.); /*Alternative *(*(array+0)+0) */
  array2d[0][1]= sin(M_PI/4.); /*Alternative *(*(array+0)+1) */
  array2d[1][0]=-sin(M_PI/4.); /*Alternative *(*(array+1)+0) */
  array2d[1][1]= cos(M_PI/4.); /*Alternative *(*(array+1)+1) */ 
  for (i=0; i<SPACEDIM; ++i){
    for (j=0; j<SPACEDIM; ++j)
      printf("%e ", array2d[i][j]);
    printf("\n");
  }
}
\end{lstlisting}
\begin{figure}[!ht]
% Generated with LaTeXDraw 2.0.8
% Tue Feb 28 15:43:57 CET 2017
% \usepackage[usenames,dvipsnames]{pstricks}
% \usepackage{epsfig}
% \usepackage{pst-grad} % For gradients
% \usepackage{pst-plot} % For axes
\center
\scalebox{0.75} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-5)(14.8,4.1)

\pscustom[linewidth=0.04]
{
\newpath
\moveto(3.2,1.)
%\lineto(7.5,1.5)
\curveto(3.2,1.5)(4.8,3.5)(6.7,2.2)
}


\psframe[linewidth=0.04,dimen=outer](3.0,0.8725)(0.0,-0.1275)
\rput(1.6, 1.3){Typ: double **}
\rput(1.6, 0.3){Wert:0x1deb430}
\rput(1.6,-0.7){Adresse: 0x7fff541bdbc8}


\pscustom[linewidth=0.04]
{
\newpath
\moveto(9.,2.1)
%\lineto(7.5,1.5)
\curveto(9.,2.5)(10.1,3.1)(11,3.8)
}

\psframe[linewidth=0.04,dimen=outer](8.8,1.8)(5.2,0.8)
\rput(6.8, 2.0){Typ: double *}
\rput(6.8, 1.4){Wert:0x1deb450}
\rput(6.8, 0.4){Adresse: 0x1deb430}

\pscustom[linewidth=0.04]
{
\newpath
\moveto(9.,-0.2)
%\lineto(7.5,1.5)
\curveto(9.,-0.2)(10.1,-0.4)(11,-0.9)
}

\psframe[linewidth=0.04,dimen=outer](8.8,-0.25)(5.2,-1.25)
\rput(6.8, -0.1){Typ: double *}
\rput(6.8, -0.7){Wert:0x1deb470}
\rput(6.8, -1.7){Adresse: 0x1deb438}




\psframe[linewidth=0.04,dimen=outer](14.8,3.9)(11.2,2.9)
\rput(13., 4.05){Typ: double }
\rput(13., 3.5){Wert: $\pi$/4}
\rput(13., 2.6){Adresse: 0x1deb450}

\psframe[linewidth=0.04,dimen=outer](14.8,1.7)(11.2,0.7)
\rput(13., 1.85){Typ: double }
\rput(13., 1.3){Wert: $\pi$/4}
\rput(13., 0.4){Adresse: 0x1deb458}

\psframe[linewidth=0.04,dimen=outer](14.8,-0.7)(11.2,-1.7)
\rput(13., -0.55){Typ: double }
\rput(13., -1.1){Wert: -$\pi$/4}
\rput(13., -2.){Adresse: 0x1deb470}

\psframe[linewidth=0.04,dimen=outer](14.8,-2.9)(11.2,-3.9)
\rput(13., -2.65){Typ: double }
\rput(13., -3.2){Wert: $\pi$/4}
\rput(13., -4.1){Adresse: 0x1deb478}


\rput(1.464063,-4.8){\large Pointer auf Pointer}
\rput(7.271094,-4.8){\large Pointers auf  double Variablen}
\rput(13.05875,-4.8){\large double Variablen}
\end{pspicture} 
}
\caption{\label{mem2d} Pointers auf Pointer in Betrien.}
\end{figure}
In der achten Zeile wir reservieren Speicherzellen für Pointers
und danach in einer Schleife reservieren wir Speicherzellen für
die aktuelle Fließkommazahlen. Für die indexierung wir können
entweder mehrere eckigen Klammern $(array2d[i][j)]$ oder
die Dereferenzierung operator $(*(*(array2d+i)+j))$ verwenden.
Sie sind in jeder Hinsicht gleichwertig. Von Zeile 15 bis 19 
wir stellen vor, wie mann eine zwei dimenzionale Objekt
durchführen kann. In diesem Fall wir 
drücken die Elementen aus in Spalten-Zeil matrixmode.

Zum ende, wir zeigen, wie mann diese Objekte im Funktion herstellen kann.
Im Funkcion wir müssen der Wert von $array2d$ ändern d.h wenn wir zurück
aus dem Funktion gekommen sind, $array2d$ muss ein neuer Wert haben.
Um diese Übung zu erledigen, wir müssen ihre Adresse übergeben und
die Funktion muss einer Pointer auf $**$ erhalten. Wir zeigen 
es ausdrücklich in den unteren Quelltext. Im Allgemeinen 
wenn wir den Wert von einem $n$ dimenzionalen Objekte in einem
Funktion ändern wollen, müssen wir ihre Adresse übergeben, und die Funktion soll
eine Pointer auf $n+1$ dimenzionale Object erhalten.
\begin{lstlisting}
#include<stdio.h>
#include<stdlib.h>
#define SPACEDIM
void create2darray( double *** p1 ){
  int i;
  (*p1)=(double **)malloc(sizeof(double *)*SPACEDIM);
  for (i=0; i<SPACEDIM; ++i)
    (*p1)[i]=(double *)malloc( sizeof(double)*SPACEDIM);
}
int main(){
  double **array2d;
  int i,j;
  create2darray(&array2d);
  array2d[i]=(double *)malloc(sizeof(double)*SPACEDIM);
  array2d[0][0]= cos(M_PI/4.); /*Alternative *(*(array+0)+0) */
  array2d[0][1]= sin(M_PI/4.); /*Alternative *(*(array+0)+1) */
  array2d[1][0]=-sin(M_PI/4.); /*Alternative *(*(array+1)+0) */
  array2d[1][1]= cos(M_PI/4.); /*Alternative *(*(array+1)+1) */
  for (i=0; i<SPACEDIM; ++i){
    for (j=0; j<SPACEDIM; ++j)
      printf("%e ", array2d[i][j]);
    printf("\n");
  }
}
\end{lstlisting}
\section{Complex Datatypen}
Wir haben gelernt, wie wir mehrere Objekte von dem gleichen Typ händeln
können. Aber often das ist nicht genug. Wenn in unserem Problem
wir zusammenhörende Variablen haben, müssen wir ihnen zusammen handeln
als ein Stukture. In der C Sprache wir können neuen Datentypen aus
den Elementaren herstellen, dafür müssen wir $struct$ Strichwort
verwenden.
\begin{myalertblock}{struct Typdefinierung}
\begin{lstlisting}
struct name
{
   Type1 typename1;
   Type2 typename2;
   Type3 typename3;
   ...
}
\end{lstlisting}
\vspace{-0.4cm}
Verwendung, definieren Variable aus $name$ Typ:
\begin{lstlisting}
struct name variablename;
\end{lstlisting}
\vspace{-0.4cm} 
Die Typen in einer Strukture können auch Strukture sein.
Sie müssen geschlossen sein, was bedeutet, dass ihre Größe
(wievielen Speicherzellen verwenden Sie) in der Kompilierung
bekannt sein muss.
\end{myalertblock}
Ein Strukture besteht aus Objekten von verschidenen Typen. 
Mann kann auch ein Objejt in einer Structure mit $Record$ 
oder $Feld$ bezeichnet.

Wir können mit dem Punktoperator (.) zu den eigenen Felden
griffen. In dem unteren kleinen Quelltext wir zeigen ein Beispiel
für Strukture Datatyp.
\begin{lstlisting}
#include<stdio.h>
struct Student { 
int matrikelnummer;
char *name;
char klasse[5];
}
int main(){
    struct Student erste, zweite;
    erste.matrikalnummer=99;
    erste.name="Martin Pfeindrich";
    erste.klasse="5a";
    zweite={101,"Andrea Tabarrios","6b"};
}
\end{lstlisting}
In diesem Beispiel wir haben das Student stukture definiert in der Zeilen zwischen 2-7.
Das musst außerhalb des $main$ Funktions sein, um alle andere Funktionen zugriffen zu können.
In der neuenten Zeile wir haben zwei Variable von Student Typ definiert. Sie sind 
nicht initializiert noch. In der zehnten Ziele wir griffen zu den Recorden in der
Student Strukture mit dem Punkt operator. Allgemeinen die Zuweisung hat der folgende Form:
\begin{lstlisting}
Variablename.structurenecodname = wert;
\end{lstlisting}
Natürlich die structurenrecordname oben kann also ein Struktured Typ sein, d.h wir können
Strukturen schachteln. Wir können auch nicht nur mit dem Punktoperator initializieren, sondern
auch mit einer Aufzählung der Werten getrennt durch die (,) Operator.

Natürlich wir können nicht alle Elementare operatoren auf Selbst
erstellte Strukturen verwenden. Wir können zwischen zwei Elementen zuweisung machen zum Beispiel.
In diesem Fall die Werten von alle Speicherzellen, die die Strukture aufbauen werden in der
anderen Strukturevariable copyieren. Wir können auch Arrays  Elementen von Strukturen typ, 
und deswegen die Dereferenzierung und die adresse Operator verwendet werden.

Strukuren sind hilfreich auch wenn ein Fuktion mehr ($n$) zusammenhörige Änderung machen soll. 
Anstatt $n$ Eingabeparameter zu verwenden, genügt es, einen zu verwenden. Im Standardbibliothek
C also hat Complex Stukture Datatypen. Zum Beispiel, die Funktions, die die Zeit verarbeiten.

\begin{myexampleblock}{Definition: \texttt{struct tm}}
\begin{lstlisting}
struct tm{
int tm_sec:  /*Sekundums im Minute*/
int tm_min;  /*Minutes im Uhr*/
int tm_hour; /*Uhr am Tag*/
int tm_mday; /*Tag im Monat*/
int tm_mon;  /*Monat im Jahr*/
int tm_year; /*Jahren seit 1900*/
int tm_wday; /*Tage seit Sonntag*/
int tm_yday; /*Tage seit Januar 1*/
int tm_isdst;/*Sommerzeit ist oder nicht*/
}
\end{lstlisting}
Das Definition befindet sich im Standardbibliothek Funktion time.h.
\end{myexampleblock}
\begin{myexampleblock}{Funktion:\texttt{time}}
\begin{lstlisting}
time_t time(time_t *t)
\end{lstlisting}
\vspace{-0.4cm}
Kehrt die Zeit in Sekundum seit (00:00:00, January 1, 1970) zurück.
Eingabeparameter ist die Adresse ein Variable von long int Typ, in der
das Ergebnis gespeichert wird, oder $NULL$ Pointer.
\end{myexampleblock}
\begin{myexampleblock}{Funktion:\texttt{localtime}}
\begin{lstlisting}
struct tm * localtime (time_t * timer);
\end{lstlisting}
\vspace{-0.4cm}
Eingabeparameter :Adresse einer Variable von long int Typ (often die Rückgabeparameter vom Fuktion $time$).
Mit den Werten von $timer$ füllt dieser Funktion die felder in der $tm$ Strukture aus, und kehrt ihn zurück.
\end{myexampleblock}
\begin{lstlisting}
#include <time.h>
#include <stdlib.h>
#include <stdio.h>
int main(void)
{
   time_t now;
   struct tm *local_date_time;
   char *tagarray[7]={"Sonntag","Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag"};
   now = time(NULL);
   local_date_time=localtime(&now);
   printf ("Jahr ist: %d\n", local_date_time->tm_year+1900);/*Auch (*local_date_time).tm_year+1900 ist ok*/
   printf ("Monat ist: %d\n", local_date_time->tm_mon);
   printf ("Tage ist: %s\n", tagarray[local_date_time->tm_wday]);
   printf ("Uhr ist: %d\n", local_date_time->tm_hour);
   printf ("Min ist: %d\n", local_date_time->tm_min);
   printf ("Sek ist: %d\n", local_date_time->tm_sec);
}
\end{lstlisting}
In diesem Beispiel wir drücken das aktuellen Datum auf Monitor aus. Zuerst rufen wir den $time$ Funktion
an damit wir  im $now$ das Datum als Sekunden in einem Long int Zahl haben. Danach graben wir von diesem Zahl 
verständnisvoll Informationen aus mit dem $localtime$ Funktion. Ihre Rückgabe ist eine Pointer auf $tm$ Strukture. 
Wir haben gelernt, wie wir zu den Strukture Elementen griffen können. Wir können auch Direkt vom Pointer
zu den Elementen griffen mit dem $->$ Operator. Auch in der Achten Zeile wir haben ein Variable mit komplizierten
Typ definiert als $tagarray$. Wie der Name schon sagt, das ist ein Array von Pointers auf "char". Wir verwenden
die Struktureelement $tm\_wday$, als ein Index für diesen Array in der dreizehnten Zeile.
\section{Datein verarbeiten}
In Unix wir identifizieren ein Datein mit seinem Name. Wir können Funktionen aus dem Standardbibliothek verwenden, um
detallierte Informationen zu erhalten. In diesem Fall die $C$ Sprache bietet uns den $stat$ Funktion und ihren Rückgabewert,
ein $stat$ Strukture. 
\begin{myexampleblock}{Definition: \texttt{struct stat}}
\begin{lstlisting}
struct tm{
  _dev_t st_dev:  /*Laufwerksnummer*/
  _ino_t st_ino;  /*Inode: eine grundlegende Datenstruktur zur Verwaltung von Dateisystemen mit unixartigen Betriebssystemen. */
  unsigned short st_mode; /*Modus, Berechtigungen*/
  short st_nlink; /**/
  short st_uid;   /*USER-ID*/
  short st_gid;   /*GROUP-ID*/
  _dev_t st_rdev: /*Laufwerksnummer*/
  _off_t st_size; /*Dateigroesse in Bytes */
  time_t st_atime; /*Datum des letzten Zugriffes*/
  time_t st_mtime; /*Datum des letzten Aenderung*/
  time_t st_ctime; /*Erstelldatum*/
}
\end{lstlisting}
\vspace{-0.4cm}
Das Definition befindet sich im Standardbibliothek sys/stat.h.
\end{myexampleblock}
\begin{myexampleblock}{Definition: \texttt{struct passwd}}
\begin{lstlisting}
struct passwd {
 char *pw_name; /*Anwaenders login Name*/
 uid_t pw_uid; /* UID id*/
 gid_t pw_gid; /* GID id*/
 char *pw_dir; /*Login Direktory*/
 ...
}; 
\end{lstlisting}
\vspace{-0.4cm}
Das Definition befindet sich im Standardbibliothek passwd.h
\end{myexampleblock}
\begin{myexampleblock}{Definition: \texttt{struct group}}
\begin{lstlisting}
struct group {
  char *gr_name;
  gid_t gr_gid;
  char **gr_mem;
  ...
};
\end{lstlisting}
\vspace{-0.4cm}
Das Definition befindet sich im grp.h
\end{myexampleblock}
\begin{myexampleblock}{Funktion: \texttt{stat}}
\begin{lstlisting}
int stat(char * path, struct stat * buf);
\end{lstlisting}
\vspace{-.4cm}
Information erhalten über das Datein bennant als $path$. Die Informations werden im $buf$ gespeichert.
Der Rückgabewert ist 0, wenn alles geklappt hat, und -1 bei einem Fehler.
\end{myexampleblock}
Bevor wir mit einem Datein arbeiten, müssen wir sicher sein, ob wir die entsprechende Rechte haben, um ihn zu 
erstellen oder einlesen. Die Felden uid und gid in der stat Strukture geben Informationen über die Besitzer des Dateins.
Der Supervisor hat immer $(0.0)$ als ($uid,gid$). Normalweise der erste Anwänder hat 1000 uid.
Für die weitere Anwänders das uid wird um eins erhöht. 
Wir können auch das uid mit einem Anwänder's Name verbunden. Dafür gibt es zum Bespiel der $getpwuid$ Funktion 
im Standardbibliothek. Die Anwänders in den unixartigen Betriebsystemen haben außerdem ihre login Name auch eine
Group Name. Wenn in einem Computer mehrere Programmierer arbeiten, Sie werden in Gruppen verteilen, um ihre
Arbeit leicht zu teilen. Wir können das $GID$ mit einem Name mithilfe des $getgrgid$ Funktions verbunden.
Es kann nötig sein zu prüfen, ob die Datein beschädigt ist, oder nicht. 
zum Bespiel, wir können überprüfen ihre Größe. Nehmen wir an, dass wir die folgende Datei (example.txt) haben
\begin{lstlisting}{example.txt}
Hello world
\end{lstlisting}
Wir haben die folgende C Code geschrieben, um Informationen über diesen Datei erhalten:
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <pwd.h>
#include <grp.h>
#include <sys/stat.h>
int main(int argc, char *argv[])
{
   struct stat *sb;
   struct passwd *pwuser;
   struct group *grpnam;
   int i;
   if (argc < 2)
   {
       printf("Usage: %s: file ...\n", argv[0]);
       exit(EXIT_FAILURE);
   }
   sb= (struct stat *)malloc(sizeof(struct stat));
   for ( i = 1; i < argc; i++){
      if (stat(argv[i], sb) == -1){
          exit(EXIT_FAILURE);
      }
      if ( (pwuser = getpwuid(sb->st_uid)) == NULL )
      {
          exit(EXIT_FAILURE);
      }
      if ( (grpnam = getgrgid(sb->st_gid)) == NULL )
      {
          exit(EXIT_FAILURE);
      }
      printf("%s:\n", argv[i]);
      printf("\tinode: %u\n", (int)sb->st_ino);
      printf("\towner: %u (%s)\n", sb->st_uid, pwuser->pw_name);
      printf("\tgroup: %u (%s)\n", sb->st_gid, grpnam->gr_name);
      printf("\tperms: %o\n", sb->st_mode & (S_IRWXU | S_IRWXG | S_IRWXO));
      printf("\tsize: %ld\n", sb->st_size);
      printf("\tatime: %s", ctime(&(sb->st_atime)));
      printf("\tmtime: %s", ctime(&(sb->st_mtime)));
      printf("\tctime: %s", ctime(&(sb->st_ctime)));
      printf("\n");
   }
   free(sb);
   return 0;
}
\end{lstlisting}
Diesen Beispiel gibt es viele Neueigkeiten für uns. Zum ersten Mal wir verwenden die Eingabeparameters unseres 
Programms. Zur Erinnerung, der Wert vom $argc$ erhaltet die Anzahl der Parameter, und im $argv$ (Array von Pointers auf
char Typ) sind die Parameter gespeichert. Standardmäßig das erste Parameter ist das Name des Programms, dann kommen
die Parameter, die wir hinzufügen haben. In der 13-ten Zeile prüfen wir die Anzahl der eingegebenen Parameter. Wenn
wir keinen Parameter eingegeben habe, beenden wir das Programm mit einer Gebrauchanweisung. Außerdem interpretieren 
jeden Parameter als Dateiname und erhalten ihre Eigenschaften mithilfe des stat Funktion. Es ist wichtig in der 18-ten
Zeile Speicher für sb reservieren. Der Funktion $stat$ geht davon aus, dass die Adresse, die sie bekommen habe, ist
schon reserviert. In diesem Beispiel wir verwenden auch der $getpwuid$ Funktion, mit dem wir die UID mit einem login 
Name verbunden. In unix Betriebsystemen wir können verschiedene Rechten für Anwänder, Gruppe von Anwändern, und für die
Anderen. Für einem Datein gibt es Rechte für schreiben, lesen und Ausführen. Die drei können wir darstellen mit 3 bits.
In dem 35 Zeile wir ziehen der Wert von diesen bits für der Anwänder, die Gruppe des Anwänders und für die Anderen heraus.
Die Ausgabe unseres Programms ist die folgende:
\begin{lstlisting}
./a.out example.txt
example.txt:
  inode: 11931732
  owner: 1000 (pittler)
  group: 1000 (pittler)
  perms: 664
  size: 12
  atime: Fri Mar  3 12:57:38 2017
  mtime: Fri Mar  3 12:57:31 2017
  ctime: Fri Mar  3 12:57:31 2017
\end{lstlisting}
Die Größe vom Datein kann überraschend sein, weil es nur aus 11 Zeichen besteht. Aber jeden Datein enthält die 
$EOF$(Ende des Dateins) Zeichen. Mit diesem Byte die Größe des Dateins stimmt.
\subsection{Das Stream Konzept}

Obwohl die Sprache keine eingebaute Methode für Ein und Ausgabe hat, in der Standardbibliothek befindet sich
mehrere wertvollen Ein und Ausgabe Funktionen. Ein wichtiges Konzept ist das $stream$. Das $stream$ ist ein Kanal, die
eine Verbindung zwischen die Datein und deine Programm macht. Beispielweise hier Datein kann  Tastatur, 
Monitor, oder Datein auf einem Kasetten bezeichnet. In jedem Fall wir haben das gleiche Kanal.
Diese Universalität macht Ein und Ausgabe einfach zu handhaben. Zu jeden Kanalen gehören ein Pointer von FILE Typ,
mit dem wir Sie verwenden können. Der Laufzeitsystem stellt automatisch für uns drei Kanale
\begin{enumerate}
\item stdin : Standard für Eingabe 
\item stdout : Standard für Ausgabe
\item stderr : Standard für Fehler
\end{enumerate} zur Verfügung. Wir haben schon das Standard Ein und Ausgabe kennengelernt. Zur errinerung hier gibt es
eine weitere Übung:
\begin{myexampleprogram}{Programme: \texttt{Eingabe nach Ausgabe Kopieren}}
\begin{lstlisting}
#include<stdio.h>
#include<stdlib.h>
int main(){
  char c;
  while( (c=getchar()) !=EOF)
   putchar(c);
}
\end{lstlisting}
\end{myexampleprogram}
\begin{myexampleblock}{Funktion: \texttt{getchar}}
\begin{lstlisting}
int getchar ( void );
\end{lstlisting}
\vspace{-0.4cm}
Lest ein Zeichen von der Standard Eingabe. Rückgabewert ist das eingelesene Zeichen, wenn die Einlesung erfolgreich war, außerdem
EOF.
\end{myexampleblock}
\begin{myexampleblock}{Funktion: \texttt{putchar}}
\begin{lstlisting}
int putchar (char c);
\end{lstlisting}
\vspace{-0.4cm}
Drückt den Zeichen $c$ aus. Der Rückgabewert ist ein int Wert, der von unsigned char konvertiert wurde.
\end{myexampleblock}
In diesem einfachen Beispiel wir lesen die Zeichen ein bis zum Ende des Dateins in der fünften Zeile.
Im Schleifenkern wir habe nur eine Anweisung, die der eingelesene Zeichen ausdrückt. Aber in diesem Beispiel
bei der Ausführung wir müssen den Datein mit dem $<$ Operator zur Standard Eingabe ziehen. Um direkt aus
einem Datein lesen zu können, wir müssen ein Kanal zum Datein eröffnen.
\begin{myexampleblock}{Funktion: \texttt{fopen}}
\begin{lstlisting}
FILE *fopen( const char *filename, char mode);
\end{lstlisting}
\vspace{-0.4cm}
Eröffnet ein Kanal zum Datein für Verarbeitung.
\begin{itemize} 
\itemsep0.5ex
\item "w": Datei zum Schreiben erzeugen, wenn es schon existiert, wird sie überschreiben
\item "r": Öffnen einer Datei ausschließlich zum Lesen
\item "{}a": Öffnen einer Datein zum Anfügen. Wenn is nicht existiert, wird sie erzeugen.
\item "w+" Öffnen zum Schreiben und Lesen, wenn es schon existiert, wird sie überschreiben.
\item "r+" Öffnen einer Datei zum Schreiben und Lesen.
\item "{}a+" Öffnen einer Datei zum Lesen und Anfügen.
\end{itemize}
\end{myexampleblock}  
In diesem Fall können wir das $fopen$ Funktion verwenden um einer Kanal zu eröffnen. Vordem
wir mit einem Datei das Arbeit anfangen, müssen wir wissen ob es ein Binärdatei oder ein Asciidatei
ist. Ein Asciidatei ist ein Sequenz von Zeichen beenden mit $EOF$. In einem Binärdatei, wir müssen vorhand
die Strukture des Inhalts von Datei wissen. Kann mann fragen, Warum wir bei allen Binärdateien verwenden?
Das Antwort liegt in der Genauigkeit und im Speicherplatz. Wenn wir eine 8 byte größe Fließkommazahl in 
ASCII speichern würde, brauchen wir $~40$-mal mehr speichern um die gleiche Genauigkeit zu erreichen. Zuerst 
werden wir einlesen aus Einfache Asciidatei.
\begin{myexampleblock}{Funktion: \texttt{fscanf}}
\begin{lstlisting}
int fscanf(FILE *kanal,char *formattierungtext, ....);
\end{lstlisting}
Formattierte Einlesung von einer Asciidatei, interpretiert von dem formattierungtext. Der Rückgabewert ist der
Anzahl der Elemente von Argumentliste erfolgreich gefüllt. Als Arguments, wir müssen nicht der Wert der Variable geben
sondern auch ihre Adresse. Mit dem formattierungtext können wir im einzelnen Wiese einlesen.
Die White-Space zeichen im Kanal wurden nicht gelesen (Zum Beispiel: Neue Zeile, Raumtaste, Tabulatorzeichen).

Die eingelesene Datei wurden nach den Folgenden Regeln Speichern. Die generelle Form ist:
$$\%Spezificierungszeichen$$

Die eingelesene Datei wurden nach den Folgenden Regeln Speichern. 

\begin{center}
\begin{tabular}{|cc|}
\hline
Specifizierungzeichen & Bedeutung \\\hline
$\%d$	&  Einlesen ein ganze Zahl in einer $in$ Variable \\
$\%ld$  &  Einlesen ein ganze Zahl in einer $long~int$ Variable \\
$\%f,\%e$   & Einlesen ein Fließkommazahl in einer $float$ Variable \\
$\%lf,\%le$  & Einlesen ein Fließkommazahl in einer $double$ Variable \\
$\%c$  & Einlesen ein Zeichen in einer $char$ Variable \\
$\%s$  & Einlesen eine Zeichenkette in einem Charakterarray.\\
\hline
\end{tabular}
\end{center}

Die anderen Zeichen im formattierungtext wurden eingelesen, aber nicht gespeichert. 
\end{myexampleblock}
Zum Beispiel wir möchten die Zahlen von diesem Asciidatei einlesen.
\begin{lstlisting}
1212
        1222
999             12212
888
\end{lstlisting}
Wir müssen nicht achten auf die ``white space'' Zeichen, wir können Sie einfach vergessen.
Im unteren Quelltext wir zeigen, wie es funkzioinert in der Praxis.
\begin{lstlisting}
#include<stdio.h>
#include<stdlib.h>
#include<errno.h>
int main(int argc, char *argv[]){
  FILE *in;
  int d;
  if (argc>2){
   fprintf(stderr,"Useage: ./read_int_ascii filename\n");
   exit(1);
  }
  in=fopen(argv[1], "r");
  if (in == NULL){
   fprintf(stderr, "Error opening the file %d\n", errno);
   exit(1);
  }
  while( fscanf(in, "%d", &d) == 1 ){
    printf("%d\n");
  }
  fclose(in);
}
\end{lstlisting}
Zuerst wir öffnen ein Kanal für einlesen mit dem $fopen$ Fuktion in der 11-ten Zeile. Wir müssen 
der Rückgabewert vom $fopen$ überprüfen um Fehler zu vermeiden. Wenn die Rückgabewert ist das 
$NULL$ Pointer wir haben irgendeine Fehler. Hier verwenden wir das $errno$ Systemumgebungsvariable.
Wenn die Standardbibliothek Funktionen Fehler zurückgeben, sie auch weisen den Typ des Fehlers aus mithilfe
der $errno$ Variable. Es gibt Tabellen, die für jede Wert von $errno$ Variable den Fehler zeigen.
Nachdem wir den Datei erfolgreich geöffnet haben, fangen wir das Einlesen an. Wir lesen 
ganze Zahlen bis zum Ende des Datein (Zeile 16). Nachdem Einlesen wir brauchen den Kanal nicht mehr. 
Zum ende muss die Kanal freigegeben werden (Zeile 19). Die Ausgabe nachhdem Ausführung siehst du unter.
\begin{lstlisting}
1212
1222
999
12212
 88
\end{lstlisting}
Das beweist, dass das Ergebnis unabhänging von den ``white space'' Zeichen ist. Jetzt wir können Einlesen, 
wir möchten auch neuen Datein erzeugen. Formattierte Ausgabe in einem Datei ist wie die Eingabe. Wir können 
der $fprintf$ Fuktion aus dem Standardbibliothek verwenden.
\begin{myexampleblock}{Funktion: \texttt{fprintf}}
\begin{lstlisting}
int fprintf(FILE *kanal,char *formattierungtext, ....);
\end{lstlisting}
Formattierte Ausgabe in einer Asciidatei, interpretiert von dem formattierungtext. Der Rückgabewert ist der
Anzahl der ausgegebenen Zeichen. Als Arguments, wir müssen der Wert der Variable geben
nicht ihre Adresse. Mit dem formattierungtext können wir im einzelnen Wiese ausdrücken.

Die ausgebende Datei wurden ähnlich wie im $fscanf$ verarbeiten. Die generelle Form ist:
$$\%Spezificierungszeichen$$
{
\begin{center}
\begin{tabular}{|cc|}
\hline
Specifizierungzeichen & Bedeutung \\\hline
$\%d$   &  Ausgeben ein ganze Zahl \\
$\%f,\%e$   & Ausgeben ein Fließkommazahl  \\
$\%c$  & Ausgeben ein Zeichen  \\
$\%s$  & Ausgeben eine Zeichenkette\\
\hline
\end{tabular}
\end{center}
}
Im $fprintf$ wir können mit $\%f$ entweder der Wert von einem $float$ oder $double$ Fließkommazahl
ausdrücken.
\end{myexampleblock}
Beispielweise, drücken wir das Quadrat der Zahlen von 0 bis 100 immer, sodass alle Zeilen werden
aus 6 Zeichen bestehen.
\begin{lstlisting}
#include<stdio.h>
#include<stdlib.h>
#include<errno.h>
int main(){
  FILE *out;
  int i;
  out=fopen("quadrats.txt", "w");
  if (out == NULL){
   fprintf(stderr, "Error opening the file %d\n", errno);
   exit(1);
  }
  for (i=1;i<=100;++i){
    fprintf(out,"%.6d\n",i*i);
  }
  fclose(out);
}
\end{lstlisting}
In diesem Fall wir öffnen der Datei zum Schreiben (Zeile 7). Wir drücken 
die Quadrats mit dem $fprintf$ Fuktion zum Kanal aus. In der C Sprache wir 
können einstellen, wieviele Ziechen wir in der Ausdrückung verwenden möchten. 
Mit der Anweisung $\%x.yd$ die Ausdrückung beginnt im $x$-ten Zeichen, und 
verwendet mindesten $y$ zeichen. Mit dem $\%.6d$ jede Quadrat wird ergänzt mit $0$
um 6 Zeichen zuverwenden. Die ersten Zeilen des Ergebnis befindest du unter:
\begin{lstlisting}
000001
000004
000009
000016
000025
000036
000049
000064
000081
\end{lstlisting}
Es macht sinn in einem Großen Projekt die Parameters in einem Asciidatei ausdrücken, aber
das Ergebnis muss in Binärdatei gespeichert werden. Dafür stellen wir hier vor, wie 
mann binäredatei in C handeln kann. Das großte Unterschied zwischen Binäre and Asciidatei
ist, dass wir der Binäredatei mit einem einfachen Editor nicht anschauen können. Wir müssen uns
errinern in welchen Form wieviele Datei wir in einem Binärdatei geschrieben haben. Für ein einfaches 
Einlesen oder Ausgaben wir können die Funktionen ($fread$ und $fwrite$) verwenden. Wenn wir nicht nur
Schreiben sondern auch Einlesen möchten, müssen wir der Kanal auch positionieren.  Beispielweise
wir möchten die Festpalette als Memory verwenden: zuerst schreiben wir etwas aus, danach möchten
wir diese Datei verwenden. In diesem Fall wir können der Kanal mit dem $rewind()$ oder $fseek()$ Funktion
positionieren.
\begin{myexampleblock}{Funktion: \texttt{fread}}
\begin{lstlisting}
size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );
\end{lstlisting}
\vspace{-0.4cm}
Lest aus einem Binärdatei. Der Rückgabewert ist die Größe der eingelesene Datei.\\
Die Parameters:
\begin{enumerate}
\item $ptr$: Anfangadresse, wo die eingelesene Datei gespeichert wird
\item $size$: Größe einer eingelesenen Einheit
\item $count$: Anzahl der eingelesenen Einheiten
\item $stream$: Pointer zum Kanal
\end{enumerate}
\end{myexampleblock}
\begin{myexampleblock}{Funktion: \texttt{fwrite}}
\begin{lstlisting}
size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream );
\end{lstlisting}
\vspace{-0.4cm}
Schreibt in einem Binärdatei. Rückgabewert ist die Größe, der ausgeschrienen
Datei.\\ Die Parameters:
\begin{itemize}
\item Quelladresse von den ausschreibenden Datei 
\item Größe einer ausschreibenden Einheit
\item Anzahl der ausschreibenden Einheiten
\item Pointer Zum Kanal
\end{itemize}
\end{myexampleblock}
\begin{myexampleblock}{Funktion: \texttt{rewind}}
\begin{lstlisting}
void rewind(FILE *stream)
\end{lstlisting}
\vspace{-0.4cm}
Positioniert der Kanal auf dem Anfang des Binärdateis.
\end{myexampleblock}
\begin{myexampleblock}{Funktion: \texttt{fseek}}
\begin{lstlisting}
int fseek(FILE *stream, long int offset, int whence)
\end{lstlisting}
\vspace{-0.4cm}
Positioniert der Kanal auf einem specific Position in dem 
Binärdatei. Rückgabewert ist 0, wenn die Positionierung erfolgreich war.
\begin{enumerate}
\item stream: Der Kanal
\item offset: Versatz
\item whence: Die Position, zur die Versatz hinzufügen wird
\end{enumerate}
\end{myexampleblock}
Unter wir geben ein Beispiel für die Verwendung der Funktions $fread$ und $fwrite$.
\begin{lstlisting}
#include<stdio.h>
#include<stdlib.h>
int main(){
   FILE *kanal;
   int *squares;
   int i;
   int n=100;
   kanal=fopen("temporarystorage", "w+");
   if (kanal == NULL){
     fprintf(stderr, "Error in opening the file\n");
     exit(1);
   }
   squares=(int *)malloc(sizeof(int)*n);
   if (squares == NULL){
     fprintf(stderr, "Error in allocating memory\n");
     exit(1);
   }
   for (i=0; i<n; ++i)
     squares[i]=(i+1)*(i+1);
   fwrite(squares, sizeof(int), n, kanal);
   for (i=0; i<n; ++i)
     squares[i]=0;
   rewind(kanal); 
   fread (squares, sizeof(int), n, kanal);
   for (i=0; i<n; ++i)
    printf("%d\n", squares[i]);
   fclose(kanal);
}   
\end{lstlisting}
Wir öffnen der Kanal nicht nur für Einlesen, sondern auch für Schreiben (Zeile 8). Achtung, wenn $temporarystorage$ 
Datei schon exisitiert, dann ihre Inhalt wird gelöscht. Wir reservieren Speicherzellen für 100 Variable von $int$ Typ (Zeile 13).
Danach wir speichern die Quadrats von den ersten hundert ganze Zahlen in diesem Array, und schreiben wir in den 
Binärdatei. Denn wir postionieren den Kanal wieder auf das Anfang des Datein um  die gespeichert Date einzulesen (Ziele 24).
In diesem Fall müssen wir Auch der Kanal freigeben.
\section{Verketette Liste, der Kellerspeicher und die Warteschlange}
Wir haben gelernt, wie wir die Memoryverwaltung verwenden können. Aber was passiert, wenn wir ein Element löschen wollten, oder
wir möchten nochein hinzufügen zwischen zwei schon existiert Elementen. In anderen Worten, wir möchten ein Dateistrukture, das
dynamisch erhöht, oder schrumpft. Das können wir ausführen mit einer Strukture, die die Adresse des nächsten Elements enthält.
Beispielweise in der C Sprache ein Struktureelement kann auch ein Pointer auf den nächsten Element sein.
\begin{lstlisting}
struct list{
  int element;
  struct list *nachste;
}
\end{lstlisting}
\begin{figure}[!ht]
% Generated with LaTeXDraw 2.0.8
% Sun Mar 05 19:02:52 CET 2017
% \usepackage[usenames,dvipsnames]{pstricks}
% \usepackage{epsfig}
% \usepackage{pst-grad} % For gradients
% \usepackage{pst-plot} % For axes
\scalebox{1} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,0.)(16.0,4.)
\psframe[linewidth=0.04,dimen=outer](3.,1)(0.0,3.0)
\rput(1.2, 2.5){element: 4}
\rput(1.2, 2.0){nachste:} 
\rput(1.2, 1.5){0x1b464c0}
\rput(1.5, 0.5){Adresse: 0x1b464a0} 

\psline[linewidth=0.04cm](3.5,2.)(4.5,2.)
\psline[linewidth=0.04cm](4.25,2.5)(4.5,2)
\psline[linewidth=0.04cm](4.25,1.5)(4.5,2)
\psframe[linewidth=0.04,dimen=outer](8.,1)(5.0,3.0)
\rput(6.2, 2.5){element: 6}
\rput(6.2, 2.0){nachste:}
\rput(6.2, 1.5){0x1b46480}
\rput(6.2, 0.5){0x1b464c0}
\psline[linewidth=0.04cm](8.5,2.)(9.5,2.)
\psline[linewidth=0.04cm](9.25,2.5)(9.5,2)
\psline[linewidth=0.04cm](9.25,1.5)(9.5,2)

\psframe[linewidth=0.04,dimen=outer](13.,1)(10.0,3.0)
\rput(11.2, 2.5){element: 6}
\rput(11.2, 2.0){nachste:}
\rput(11.2, 1.5){NULL}
\rput(11.2, 0.5){0x1b46480}
\psline[linewidth=0.04cm](13.,2.)(14.,2.)
\psline[linewidth=0.04cm](13.75,2.5)(14.,2)
\psline[linewidth=0.04cm](13.75,1.5)(14.,2)
\rput(15, 2.){\LARGE NULL}
\end{pspicture} 
}
\caption{Einmal Verketette Liste\label{verklist}}
\end{figure}
In der Abbildung \ref{verklist} wir zeigen, wie es in der Praxis
funkzioniert. Wir werden den NULL pointer für das Ende der verketetten
Liste verwenden. Viele wichtigen Datenstukturen können mit 
verketetten Listen darstellen. Beispielweise den Stapelspeicher.
In Assembly Programmiersprache beim Funktionanrufen die Parameters werden 
zum Stapelspeicher gestellt. Wenn wir kommen von einem Funktion zurück, 
wir nehmen ein Element vom Stapelspeicher aus. Das Grundprinzip im
Stapelspeicher ist: Den zuletzt gespeicherten Element werden wir zuerst
zurückgeben. Wir zeigen es in der Abbildung \ref{stapspeicher}.
\begin{figure}[!ht]
\begin{center}
% Generated with LaTeXDraw 2.0.8
% Sun Mar 05 20:17:29 CET 2017
% \usepackage[usenames,dvipsnames]{pstricks}
% \usepackage{epsfig}
% \usepackage{pst-grad} % For gradients
% \usepackage{pst-plot} % For axes
\scalebox{0.7} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-3)(12.0,3)
\psframe[linewidth=0.04,dimen=outer](3,3)(0.0,2)
\psframe[linewidth=0.04,dimen=outer](11.0,3)(8,2)
\pscustom[linewidth=0.04]
{
\newpath
\moveto(3.1,2.5)
%\lineto(7.5,1.5)
\curveto(3.3,2.5)(3.5,2.4)(4.5,1.7)
}
\rput(3.7, 2.8){\LARGE push}
\psline[linewidth=0.04cm](4.55,1.9)(4.5,1.7)
\psline[linewidth=0.04cm](4.4,1.6)(4.5,1.7)


\pscustom[linewidth=0.04]
{
\newpath
\moveto(7.5,2.5)
%\lineto(7.5,1.5)
\curveto(7.5,2.5)(6.8,2.5)(6.5,1.6)
}
\rput(6.7, 2.8){\LARGE pop}
\psline[linewidth=0.04cm](7.4,2.7)(7.5,2.5)
\psline[linewidth=0.04cm](7.4,2.3)(7.5,2.5)


\psframe[linewidth=0.04,dimen=outer](7,1.5)(4,0.5)
\psframe[linewidth=0.04,dimen=outer](7,0.2)(4,-0.8)
\psframe[linewidth=0.04,dimen=outer](7,-1.1)(4,-2.1)
\end{pspicture} 
}
\caption{Der Stapelspeicher\label{stapspeicher}}
\end{center}
\end{figure}

Wir werden jetzt implementieren diesen wichtigen Datenstruktur mit 
den verketetten Listen. Zuerst stellen wir der Datenstruktur, den wir verwenden
vor:
\begin{lstlisting}
typedef struct list {
   struct list* next;
   int data;
} list;
\end{lstlisting}
Das ist natürlich eine verketette Liste. Aber wir haben hier diesen Typ also definiert
mit dem Strichwort $typedef$.
\begin{myexampleblock}{Strichwort: \texttt{typedef}}
\begin{lstlisting}
typedef neuename altename;
\end{lstlisting}
\vspace{-0.4cm}
Stellt ein neues Name ($neuename$) für den Typ von $altename$ her.
\end{myexampleblock}
Der größte Vorteil in diesem Fall ist, dass wir den Strichwort $struct$ 
vor allen Variable definition verwenden müssen. Der Quelltext wird durchsichtiger
sein. Jetzt wir haben das Definition der Datenstrukture, wir können die Implementierung
anfangen. Zuerst besprechen wir, wie können wir eine neue Stapelelement herstellen.
Wie können wir eine neue Variable von Typ $list$ herstellen.
\begin{lstlisting}
list * get_a_list( int x ){
   list *q=(list *)malloc(sizeof(list));
   if (q == NULL){
     fprintf(stderr, "Error in Memory allocation\n");
     exit(1);
   }
   q->data=x;
   q->next=NULL;
   return q;
}
\end{lstlisting}
Der obene Codeteil gib eine $list$ Element zurück und hat die
speichernde ganze Zahl als Eingabeparameter. Dieser Teil ist ganz einfach.
Wir reservieren Speicherzellen für den neuen Listelement und zuweisen
den Eingabewert. Zum Ende wir müssen die nächste Element als ein NULL 
Pointer festlegen. Die nächste Teil ist das push() Funktion. Speichern 
ein Element im Stapelspeicher.
\begin{lstlisting}
void push( int x, list ** first){
   if ((*first) == NULL){
       (*first)=get_a_list(x);
       return;
   }
   list *temp=get_a_list(x);
   temp->next=(*first);
   (*first)=temp;
}
\end{lstlisting}
Wir müssen die Adresse von dem Pointer auf den Anfang des Speichers  und den speichernde 
Element abgeben. Wenn den List leer ist, wir legen die Anfangsadresse mit der adresse 
des  neuen Elements fest. In anderem Fall wir legen den next Pointer von dem neuen Element 
mit dem originalle Anfangsadresse und die neue Anfangsadresse wird die Adresse vom neuen Element 
sein. Darum müssen wir nicht die Anfangsadresse als Parameter abgeben, sondern ihre Adresse,
weil wir den Wert von ihm im Funktion ändern wollen. Den logischen nächsten Schritt
ist die implementierung des $pop$ Funktions. Der Rückgabewert muss den letzten gespeicherte
Element sein. Der Eingabeparameter muss den Anfangsadresse den Stapelspeicher sein.
\begin{lstlisting}
int pop( list **first){
   list *temp;
   int ret;
   if ((*first) == NULL){
     printf("Es gibt kein Element im Speicher\n");
     return 0;
   }
   ret=(*first)->data;
   temp=(*first)->next;
   free(*first);
   (*first)=temp;
   return ret;
}
\end{lstlisting}
Wenn das Stapelspeicher leer war, wir werden eine Nachricht ausdrücken. 
Im anderen Fall wir legen den Rückgabewert mit dem Wert von dem ersten 
Element fest. Wir müssen auch die ersten Element freigeben, und die neue
Anfangsadresse mit dem nächste der originalen festlegen.

Wir können auch prüfen die aktuellen Inhalt des Speichers. 
Dafür müssen wir einer Funktion, der dursch die Listelementen geht
schreiben.
\begin{lstlisting}
void print_list( list *first){
   list *temp=(first);
   if (temp == NULL)
      return;
   for (;;){
      printf("%d\t", temp->data);
      temp=temp->next;
      if (temp == NULL)
        break;
   }
   printf("\n");
}
\end{lstlisting}
Dieser Funktion zuerst prüft ob der Speicher leer ist. Wenn der
Speicher nicht leer ist, wir machen eine Schleife um durch die
Listelementen gehen. In jeden iteration wir springer zur 
nächsten Element (Zeile 7). Wenn wir am Ende des Speichers
sind, beenden wir die Schleife.

Es fehlt jetzt nur noch ein Gebrauchanweisung für unseren Stapelspeichern.
Dies wird der $main$ Funktion.
\begin{lstlisting}
int main(){
   list *erste=NULL;
   push(2, &erste);  print_list(erste);
   push(4, &erste);  print_list(erste);
   push(6, &erste);  print_list(erste);
   pop( &erste );    print_list(erste);
   push(8, &erste);  print_list(erste);
   pop( &erste );    print_list(erste);
}
\end{lstlisting}
Wir definieren zuerst einer Pointer um die 
Anfangsadresse des Speichers zu speichern (Zeile 2). Dann wir machen eine
Folgen aus push und pop Anweisungen, und im jeden Schritt wir drücken
den aktuellen Zustand des Speichers aus. Die Ausgebe siehst du unter.
\begin{lstlisting}
2	
4	2	
6	4	2	
4	2	
8	4	2	
4	2	
\end{lstlisting}
Wie du siehst, wenn wir die erste $pop$ Anweisung ausführen, wurde die letzte 
eingegebene Wert (6) aus dem Speicher gelöst. 

\begin{myexampleprogram}{ Programme: \texttt{Die Warteschlange}}	
\begin{lstlisting}
typedef struct queue {
   struct queue* next;
   int data;
} queue;
\end{lstlisting}
\begin{lstlisting}
queue * get_a_queue( int x ){
   queue *q=(queue *)malloc(sizeof(queue));
   q->data=x;
   q->next=NULL;
   return q;
}
\end{lstlisting}
\begin{lstlisting}
void queue_put( int x, queue ** first){
   if ((*first) == NULL){
       (*first)=get_a_queue(x);
       return;
   }
   queue *temp=get_a_queue(x);
   temp->next=(*first);
   (*first)=temp;
}
\end{lstlisting}
\begin{lstlisting}
int queue_rem( queue **first){
   int ret;
   queue *temp;
   if ((*first) == NULL){
     return -1;
   }
   if ((*first)->next == NULL){
     ret=(*first)->data;
     free((*first));
     (*first)=NULL;
     return ret;
   }
   temp=(*first);
   queue *prev;
   while ( temp->next != NULL){
      prev=temp;
      temp=temp->next;
   }
   prev->next=NULL;
   ret=temp->data;
   free(temp);
   return (ret);
}
\end{lstlisting}
\begin{lstlisting}
void free_queue( queue **first){
   if ((*first)== NULL)
     return;
   queue *temp=(*first);
   queue *temp2;
   for(;;){
     temp2=temp->next;
     free(temp);
     temp=temp2;
     if (temp == NULL)
       break;
   }
}
\end{lstlisting}
\begin{lstlisting}
void print_queue( queue *first ){
   queue *temp=(first);
   if (temp == NULL){
     printf("Wir haben keine Element in der Wertechlange\n");
     return;
   }
   for (;;){
     printf("%d\t", temp->data);
     temp=temp->next;
     if (temp == NULL)
       break;
   }
   printf("\n");
}
\end{lstlisting}
\begin{lstlisting}
int main(){
    queue *elso=NULL;
    int temp;
    queue_put(2, &elso);  print_queue(elso);
    queue_put(4, &elso);  print_queue(elso);
    queue_put(6, &elso);  print_queue(elso);
    temp=queue_rem( &elso ); printf("Ausgenommene Element: %d\n",temp); print_queue(elso);
    queue_put(8, &elso);  print_queue(elso);
    temp=queue_rem( &elso ); printf("Ausgenommene Element: %d\n",temp); print_queue(elso);
    free_queue( &elso );
}
\end{lstlisting}
\begin{lstlisting}{Output}
2	
4	2	
6	4	2	
Ausgenommene Element: 2
6	4	
8	6	4	
Ausgenommene Element: 4
8	6	
\end{lstlisting}
\end{myexampleprogram}
\begin{myexampleprogram}{Programme: \texttt{Haldensortierung}}
\begin{lstlisting}
typedef struct heap {
   int val;
   struct heap *left;
   struct heap *right;
   struct heap *parent;
} heap;
\end{lstlisting}
\begin{lstlisting}
heap *newheap( int x, heap *parent)
{
   heap *ret=(heap *)malloc(sizeof(heap));
   ret->left=NULL;
   ret->right=NULL;
   ret->parent=parent;
   ret->val=x;
   return ret;
}
\end{lstlisting}
\begin{lstlisting}
void heap_insert(heap** root, int x) {
   if(*root == NULL) {
     *root = newheap(x, NULL);
   }
   else {
     queue* q = newqueue(*root);
     heap* currentheap;

     while((currentheap=queue_rem(&q))!=NULL){

        if(currentheap->left == NULL) {
          currentheap->left  = newheap(x, currentheap);
          currentheap = currentheap->left;
        }
        else if(currentheap->right == NULL) {
          currentheap->right = newheap(x, currentheap);
          currentheap = currentheap->right;
        }
        else {
          queue_put(currentheap->left, &q);
          queue_put(currentheap->right,&q);
          continue;
        }
        while(currentheap->parent != NULL && currentheap->parent->val < currentheap->val) {
           int temp = currentheap->parent->val;
           currentheap->parent->val = currentheap->val;
           currentheap->val = temp;
           currentheap = currentheap->parent;
        }
        break;

     }
     free_queue(&q);
   }
   return;
}
\end{lstlisting}
\begin{lstlisting}
int heap_remove(heap** root) {
   int ret;
   if(*root != NULL) {
     queue* q = newqueue(*root);
     heap* previousheap;
     heap* currentheap;

     while ((currentheap=queue_rem(&q)) != NULL) {
       if (currentheap->left != NULL)
          queue_put(currentheap->left, &q);
       if (currentheap->right != NULL)
          queue_put(currentheap->right, &q);
       previousheap= currentheap;
     }
     currentheap = previousheap;
     free_queue(&q);

     if(currentheap->parent == NULL) {
       ret=currentheap->val;
       free(currentheap);
       *root = NULL;
       return ret;
     }
     else {
       ret=(*root)->val;
       (*root)->val = currentheap->val;
       currentheap = currentheap->parent;
       if(currentheap->right != NULL) {
          free(currentheap->right);
          currentheap->right = NULL;
       }
       else {
          free(currentheap->left);
          currentheap->left = NULL;
       }
       int a, b, c;
       currentheap = *root;
       while(1) {
         if(currentheap->left == NULL) {
           break;
         }
         else if(currentheap->right == NULL) {
           a = currentheap->val;
           b = currentheap->left->val;
           if(a < b) {
              currentheap->val = b;
              currentheap->left->val = a;
              currentheap = currentheap->left;
           }
           else {
             break;
           }
         }
         else {
           a = currentheap->val;
           b = currentheap->left->val;
           c = currentheap->right->val;
           if(a >= b && a >= c) {
             break;
           }
           else if(b > a && b >= c) {
             currentheap->left->val = a;
             currentheap->val = b;
             currentheap = currentheap->left;
           }
           else {
             currentheap->right->val = a;
             currentheap->val = c;
             currentheap = currentheap->right;
           }

         }
       }
       return ret;
     }
   }
   else
    return -1;
}
\end{lstlisting}
\end{myexampleprogram}
\subsubsection{Formattierte Eingabe und Ausgabe}
\begin{myexampleblock}{Function definition \texttt{printf}}
int printf(char * formattierung\_text, $\cdots$);
\begin{itemize}
\item Rückgabe Wert: Der Anzahl der ausgedrückten Zeichen
\item Parameters:
\begin{enumerate}
\item formattierung\_text: Eine Zeichenkette, beendet mit dem \'{}\\0\'{} Zeichen, specifiziert wie mann die Daten
audrücken will
\end{enumerate}
\end{itemize}
\end{myexampleblock}
\pagebreak


%as Körper, das C code kannst du oben sehen. Alle C programm besteht aus Funkcionen. Wir nennen function ein part of the code, was eine
%estimmte aufgabe erledigt.
%u wirst es gleich finden, dass du muss zuerst lernenDu musst zuerst den einladen, was jemanden
%eschrieben hat. Zum beispiel, zu computer printen du sollst stdio.h einladen. Sie
%ehören nicht zu den sprache . Danach kommt deine arbeite. Zuerst du sollst andenken was für ein ergebnis deine aufgabe haben soll und
%ie viele eingangsparameter deine programm hat. Du sollst denen es variablen deklarieren. Jetzt kommt die wichtigsten Teil des Program, die
%unktionen. Diese teil rechnet aus den eingangsparameter deine Ergebnis. Es gibt ein specielle function was jeden programm haben
%oll. Das nahme of diese funcktion ist main. Von diesem Punkt beginnt die Ausführung. Wir werden mehr um funckcionen später lernen. 

%Im fünften Linie illustrieren wir, dass das Name der Variable nicht mit einem Zahl beginnin darf. Eine practical Beratung ist initializerien
%alle Variables recht im Definition. 
%enn zwei operatoren gleichem Prioriät haben, dann zum ersten mal der linkste wird verarbeitet, and danach 
%on links nach rechts\footnote{Hier gibt es ausnahme, wenn die Reihenfolge ist umgekehrt. Siehst denn letzten Spalte im Tablellen \ref{priortab}}. 


\begin{lstlisting}{Einf\"ugesortieren in C: Körper }
#include<stdio.h>
void read_in_data( int n, int sort[], int unsort[], int argc, char *argv[]){
statements a1;
statements b1;
...
}
void einfugesortieren( int n, int sort[], int unsort[]){
statements a2;
statements b2;
...
}
void print_out_data( int n, sortiert){
statements a3;
statements b3;
...
}
int main( int argc, char *argv[])
{
  int n=4;
  int sortiert[n];
  int unsortiert[n];
  read_in_data(n, sortiert, unsortier, argc, argv);
  einfugesortieren(n,  sortiert, unsortiert);
  print_out_data( n, sortiert);

}
\end{lstlisting}
Das Körper, das C code kannst du oben sehen. Alle C programm besteht aus Funkcionen. Wir nennen function ein part of the code, was eine
bestimmte aufgabe erledigt. 
Du wirst es gleich finden, dass du muss zuerst lernenDu musst zuerst den einladen, was jemanden
geschrieben hat. Zum beispiel, zu computer printen du sollst stdio.h einladen. Sie
gehören nicht zu den sprache. Danach kommt deine arbeite. Zuerst du sollst andenken was für ein ergebnis deine aufgabe haben soll und
wie viele eingangsparameter deine programm hat. Du sollst denen es variablen deklarieren. Jetzt kommt die wichtigsten Teil des Program, die
Funktionen. Diese teil rechnet aus den eingangsparameter deine Ergebnis. Es gibt ein specielle function was jeden programm haben
soll. Das nahme of diese funcktion ist main. Von diesem Punkt beginnt die Ausführung. Wir werden mehr um funckcionen später lernen.
 

Zum beispiel in C sieht die obene Auflistung so aus:
\begin{lstlisting}{Einf\"ugesortieren in C}{
1: int n=4;
   int unsortiert[n],  sortiert[n];
2; sortiert[0]=2;
3; unsortiert[0]=9; 
   unsortiert[1]=5;
   unsortiert[2]=7;
4; for (int i=1; i<n-1;++i){
      sortiert[length]=unsortiert[i]
5-6;   for (int j=length-1; j>0; --j){
         if (sortiert[j+1]<sortiert[j]){
            int tmp=sortiert[j];
            sortiert[j]=sortiert[j+1];
            sortiert[j+1]=tmp;
         }
         else{
          break;
         }
      }
      length++;
   }
}
\end{lstlisting}
''for`` steht f\"ur Schleife und wir nutzten das "A" array 
Warum solltest du C programmier sprache lernen? Es gibt viele Antwort auf diese Frage. Zum Beispiel:
\begin{itemize}
\item C ist nicht kompliziert
\item C ist sehr effizient
\item C hat high level konstrukte
\end{itemize}
Aber M\"oglicherweise das beste Antwort ist das C Kenntnisse ist unbedingt in Forschungsrechnungen. Die meisten Programme,
der zum Stand der Technik geh\"oren sind C programme. In diesem Kurz wir werden diese Sprache kennenlernen. Zuerst 
wir zusammenfasseen was in der Sprache inbegriffen ist. Du wirst dich verwundern, das die einfachste funktion, was
nur etwas auf deinem Monitor zeigt, geh\"ort nicht zu der Sprache. Wir vorstellen das k\"orper einem durchschnittlichen
C program und erkl\"aren sein Teilen. 

Danach z\"ahlen wir die Komponenten der Sprache auf. Das wird beginnen mit der data Typen und Operationen, in denen wir 
die Typen nutzen k\"onnen. Wir werden alle elementare Data type lernen. Mit Variablen aus diesen Typen k\"onnen wir Operationen machen, 
die unsere Ergebnisse herstellen werden. Dann werden wir elementare Statements und Expressions einf\"uhren, mit denen 
wir kleinen Aufgaben l\"osen k\"onnen. 
  
Es is sehr wichtig, dass unsere Programm Parameter erhalten zu k\"onnen. Wir k\"onnen das erreichen durch Funkcionen.
Die Funkcionen arbeiten wie schwarze K\"asten. Sie stellen von den Eingangsparameter ein neues Wert her. Wir zeigen, 
wie man die Standart Eingabe und Ausgabe Bibliothek nutzten kann. Nachdem wir diese F\"ahigkeiten verstehen, werden wir etwas
komplizierte \"Ubungen schreiben.

Often gibt es Situationen in den wir mehr als Ein ergebnisse von einem Funktionen wollen. Um das erreichen
m\"ussen wir die Addressirung der Memorie kennen zu lernen. In diesem Punkt werden wir auch lernen, wie man 
strings verwendet kann.

In einem sch\"onen Programm wir nutzten das wenigstens Speicher. In diesem Punkt wir werden lernen, 
wie die Speicherverwaltung behandelt wird.

Im ersten Teil des Kurses wir haben die elemetare datatypen kennen gelernt. In diesem Punkt wir
werden lernen, wie mann eigenes Daten Structure herstellen kann. Überhaupt, Warum and Wenn müssen wir neue Structure herstellen.
Unser Programm mit eigenen Daten strukturen wird leichter lesen zu können. Das ist sehr wichtig. Typischer fehler der Angefangenen Programmern
ist, dass ihr Code ist sehr schwer zu lesen auch für Sie, und nach einem Monat Sie müssen die ganze Programm
wieder schreiben. Zum beispiel muss mann eigenes Datenstrukture nutzen, wenn man ein operations sehr often erledigen muss.
Zum bespiel in der Sorierung eines List, man kann die Daten in einem binären Suchbaum einschließen um die suchen schneller zu lassen.

\section{Der Körper des C programms}

\begin{lstlisting}{caption= Do nothing}
#include<stdio.h>
int main( int argv, char *argv[])
{
/* do nothing */
}
\end{lstlisting}
Welche Teile hat ein C programm. 
Du wirst es gleich finden, dass du muss zuerst lernenDu musst zuerst den einladen, was jemanden 
geschrieben hat. Zum beispiel, zu computer printen du sollst stdio.h einladen. Sie
gehören nicht zu den sprache . Danach kommt deine arbeite. Zuerst du sollst andenken was für ein ergebnis deine aufgabe haben soll und
wie viele eingangsparameter deine programm hat. Du sollst denen es variablen deklarieren. Jetzt kommt die wichtigsten Teil des Program, die
Funktionen. Diese teil rechnet aus den eingangsparameter deine Ergebnis. Es gibt ein specielle function was jeden programm haben
soll. Das nahme of diese funcktion ist main. Von diesem Punkt beginnt die Ausführung. Wir werden mehr um funckcionen später lernen.  
%\section{Was ist Programmieren}
%Es gibt ein Problem, Sie müssen die Lösung finden. What we call input variables? What are the output variables? Specific problem?
\section{Definitionen, Statements}
Die Variablen haben Wert und Typ. Warum ist das Typ der Variable wichtig? Es hängt vom Typ ab, was für ein Wert eine Variable haben
kann. Das Typ entscheid also die Grösse des Arbeitspeicher zu deine Variable. Mann kann nun solche Funkcionen und Operatoren nutzen, das 
genanue Datentype hat. Es gibt elementare data Typen mit dem wir spielen können. Sie sind
\begin{itemize}
\item char
\item int
\item float
\item double
\end{itemize}
Im char können wir eine character speichern(die bereich?). Größe, im können wir ein Ganzzeil spiechern von wert 0 bis 2**32-1 größe. 
Im fließkommazahl von bis speichern grösse.
\subsection{Mein erstes C programm}
von linein bis linien wir erklären Einfachste Programm der Welt "Hello World.c"
Ein bisschen schwerer aufgabe, sie müssen ausrechnen die Würzel einer quadratische Gleichung. 
\section{Aufgaben}
\subsection{Zufallszahlgenerator}
Zufällige nummer sind sehr wichtig für uns. In numerischen physik wir nutzten Zufallszahlen ganz often. Zum Beispiel 
in die einfachsten method für integration of mehreren variablen Funkctions müssen wir Monte Carlo algorithm nutzten. Die
enthalten statements, die vom Werte auf Zufällige variablen abhängt. In dieser Aufgabe wir müssen eine Zufallszahlgenerator
schreiben. Es gibt mehrere methode dazu, aber alle stammt aus linear Kongruenzen:
\begin{equation}
I_{j+1}=a I_{j} \left( \mathrm{mod} m\right).
\label{basics}
\end{equation}
Diesen Instruktion macht eine neue Zufallszahl ($I_{j+1}$)  aus einem original ($I_j$). Der qualität der Zufallszahl generator
hängt von dem eingangsparameters (a,m) ab. Eine gute Zufallszahlgenerator hat große period, die Zeit zwischen den beiden gleichen
Zufallszahl muss sehr groß sein. Park und Miller hat die folgenden parameter für a und m gewählt:
\begin{equation}
a=16807, m=2^{31}-1=2147483647. 
\end{equation}
Leider direkte implementation der Zufallszahlgenerator mit deisen parameters ist nicht möglich in C. Der grund ist
wir können nicht speichern Zahlen grossen als $m$. Zum glück gibt es eine möglichkeit das Problem umzugehen. 
Wir faktorizieren $m$:
\begin{equation}
m= aq + r; r= m \left(\mathrm{mod}a\right); q= \left[m/a\right]
\end{equation}
Damit können wir Gleichung \ref{basics} auch bewerten mit ($q,r$):
\begin{equation}
a I_j \left( \mathrm{mod} m\right)=  
\left\{ \begin{array}{rc}
a\left(I_j \mathrm{mod} q\right) -r \left[I_j/q\right] & \mathrm{wenn~es~}>0\mathrm{ist} \\ 
a\left(I_j \mathrm{mod} q\right) -r \left[I_j/q\right] + m & \mathrm{andernfalls} \\ 
\end{array}\right.
\label{algo}
\end{equation}
wo $r=2836,q=127773$ ist. Implementieren Sie das Zufallszahlgenerator nach eq.\ref{algo}. Ändern Sie die Algorithm
um die Zahlen zwischen 0 und 1 zu sein werden.
Es ist wichtig zu test unser Ergebnis. Wir müssen kontrollieren die Verteilung (Distribution) der Zufallszahlgenerator.
Wir möchten gleichmäßige vertailung zu erreichen. Wir werden eine Histogramms machen aus dem Zufallszahlen. Wir teilen 
das Interval in $n$ Teilen und zahlen wie oft die Zufallszahl in jedem Interval sinkt. Machen Sie ein Histogramm aus 
den Verfügbaren daten und prüfen wie gleichmäßig der Verteilung ist!
\section{Elementare operatoren}
\subsection{Binäre, Aritmethic operatoren}
+,-,*,/, \%, ++, -- 
\subsection{Gleichungen}
==,!=, >,<, >=,<=
\subsection{Bitwise}
\&,|,\^, ~, >>,<<
\subsection{Zuweisungsoperator}
=,+=,-=,|=,\&=,\^=,\%=,<<|,>>|,
\subsection{Aufgaben}
Programm rechnet die Wurzel, der gleichung
\section{statements}
\subsection{Schleifen}
Was ist wichtig, wenn wir ein Schleifen plan? Wir müssen nicht überschreiben eine existierte variable. Wir müssen keine
statements haben, was nicht von der Schleifenzahlnummer abhängt.
\subsection{If then else}
\subsection{case}
\subsection{Standard input, output}
\subsection{Conways Spiel des Lebens}
Wir habe eine quadrate Gitter. In alle Zell der Gitter eine zwei hältige variable. Es sagte uns, wenn der
kleine microbe im Zell, lebt oder nicht.
\section{Funkcionen}
\section{Addressierung}
\subsection{Stackel(LIFO)}
\subsection{Fifo}
\subsection{Umgekehrte Polnische Notation}
\section{Dynamische speicherverwaltung}
\section{Daten strukturen}
\subsection{Ketten listen}
\subsection{Bäumen}
\subsection{Recursive functionen, Schnell sortieren}
\end{document}
