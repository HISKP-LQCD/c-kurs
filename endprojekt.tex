\section{Endprojekt}


In unserem ersten großen Programme (Einfügesortieren) wir hatten
zwei verschachtelten Schleifen. Eine Schleife geht durch die Elementen
und der andere versucht die richtigen Position zu finden. Diese
innere Schleife im durchschnitt also skaliert mit dem Nummer der Elementen.
Beispielweise für eine total zufällige Eingabe der sortierende Element ist im 
durchschnitt kleiner als die Hälfte der schon sortierten Elementen. Darum 
wir verbrauchen  auch in der inneren Schleife Computerzeit der mit 
dem Nummer von elementen ($n$) skaliert. Deswegen ist das Einfügesortieren
ein $n^2$ Algorithmus.

Eine mögliche entwicklung ist die Haldensortierung. In diesem Projekt werden wir 
diese Algorithmus kennenlernen und implementieren. Die grundsätztliche Datentyp ist 
das $heap$.

\begin{myexampleblock}{Definition: \texttt{Heap}}
Es ist ein ausgeglichener Binärebaum. Es gibt nur eine Bedingung für die Elementen:
jeden Element muss kleiner sein, als ihre Elter.
\end{myexampleblock} 

In einem Heap jede Element hat nur ein Elter, und kann maximal zwei Kinder
haben. Der Strichwort ausgeglichen bedeuted das die Höhe des Heaps mit
dem logarithmus von $n$ skaliert muss. Bespielweise wir zeigen ein Heap
von der $[10,12,6,5,9,13,1,7]$ Reihenfolge auf Abbildung \ref{heapexample}.
\begin{center}
\begin{figure}[!ht]
\begin{center}
% Generated with LaTeXDraw 2.0.8
% Mon Mar 06 15:43:52 CET 2017
% \usepackage[usenames,dvipsnames]{pstricks}
% \usepackage{epsfig}
% \usepackage{pst-grad} % For gradients
% \usepackage{pst-plot} % For axes
\scalebox{0.7} % Change this value to rescale the drawing.
{
\begin{pspicture}(-5,-4)(5,5)
\pscircle[linewidth=0.04,dimen=outer](0,4){.5}
\rput(0, 4){13}
\psline[linewidth=0.04cm](-0.5,3.33333)(-1,2.6666)
\psline[linewidth=0.04cm](-.7,2.9)(-1,2.6666)
\psline[linewidth=0.04cm](-.8,3.2)(-1,2.6666)

\pscircle[linewidth=0.04,dimen=outer](-1.5,2){.5}
\rput(-1.5, 2){10}
\psline[linewidth=0.04cm](0.5,3.33333)(1,2.6666)
\psline[linewidth=0.04cm](.7,2.9)(1,2.6666)
\psline[linewidth=0.04cm](.8,3.2)(1,2.6666)

\pscircle[linewidth=0.04,dimen=outer]( 1.5,2){.5}
\rput( 1.5, 2){12}

\psline[linewidth=0.04cm](-2.3,0.933333)(-1.9,1.466666)
\psline[linewidth=0.04cm](-2.35,1.2)(-2.3,0.933333)
\psline[linewidth=0.04cm](-2.0,1.0)(-2.3,0.933333)

\pscircle[linewidth=0.04,dimen=outer](-2.7,0.4){.5}
\psline[linewidth=0.04cm](-.8,0.933333)(-1.2,1.466666)
\psline[linewidth=0.04cm](-0.75,1.2)(-.8,0.933333)
\psline[linewidth=0.04cm](-1.1,1.0)(-.8,0.933333)

\rput(-2.7, 0.4){7}
\psline[linewidth=0.04cm](2.3,0.933333)(1.9,1.466666)
\psline[linewidth=0.04cm](2.35,1.2)(2.3,0.933333)
\psline[linewidth=0.04cm](2.0,1.0)(2.3,0.933333)

\psline[linewidth=0.04cm](.8,0.933333)(1.2,1.466666)
\psline[linewidth=0.04cm](0.75,1.2)(.8,0.933333)
\psline[linewidth=0.04cm](1.1,1.0)(.8,0.933333)


\pscircle[linewidth=0.04,dimen=outer](-0.8,0.4){.5}
\rput(-0.8, 0.4){9}
\pscircle[linewidth=0.04,dimen=outer](2.7,0.4){.5}
\rput(2.7, .4){1}
\pscircle[linewidth=0.04,dimen=outer](0.8,0.4){.5}
\rput(0.8, 0.4){6}

\psline[linewidth=0.04cm](-3.4,-0.533333333333333)(-3.1,-0.133333333333333)
\psline[linewidth=0.04cm](-3.,-.3)(-3.4,-0.533333333333333)
\psline[linewidth=0.04cm](-3.3,-.2)(-3.4,-0.533333333333333)

\pscircle[linewidth=0.04,dimen=outer](-3.75,-1){.5}
\rput(-3.75, -1){5}


\end{pspicture} 
}
\end{center}
\caption{Ein Heap von der $[10,12,6,5,9,13,1,7]$ Reihenfolge.\label{heapexample}}
\end{figure}
\end{center}
Wie du siehst, grundsätztlich es gibt keine Beziehung zwischen Elementen von der 
gleichen Höhe des Bäumes. Es gibt nur ein Regel: Das Kind muss kleiner sein, als ihres
Elter. Jetzt zeigen wir, wie es im Haldensortierung verwendet werden.
Er kann in folgen Schritten formuliert werden:
\begin{itemize}
\item Stellen wir ein $heap$ aus den Reihenfolge der Zahlen her
\item Nun verschieben wir jeweils das erste Element aus, und das wird mit dem letzten Element 
ersetzt.
\item Das $heap$ Eigenschaft muss wiederhergestellt werden.
\end{itemize}

Wir verwenden verketetten Liste für die Darstellung des $heap$-s. Jedes Element muss
ein Pointer für ihre Elter, und zwei Pointer für ihre rechten und linken Nachfolger haben.
\begin{lstlisting}
typedef struct heap {
    int val;
    struct heap *left; /* Verweis auf linken Nachfolger  */
    struct heap *right; /* Verweis auf rechten Nachfolger */
    struct heap *parent; /* Verweis auf den Vorgaenger */
} heap;
\end{lstlisting}
Der $parent$ Pointer ist ein NULL pointer für die Wurzel des Bäumes. Die Blätters, die keinen
Kinder haben, haben NULL als right und left Pointers.

Jetzt zeigen wir wie mann ein Heap aus einem Reihenfolge von Zahlen herstellen kann. Zuerst
müssen wir den ersten freien Platz finden, dann fügen wir das Element hier ein. Danach es kann sein, dass 
das $heap$ Eigenschaft nicht wahr ist. Darum müssen wir das $heap$ Eigenschaft überprüfen und wenn
es notwendig ist, tauschen wir den aktuellen Wert mit dem Wert von ihrem Elter bis das $heap$ Eigenschaft 
wahr wird.
\begin{figure}[!ht]
\begin{center}
% Generated with LaTeXDraw 2.0.8
% Sun Mar 05 20:17:29 CET 2017
% \usepackage[usenames,dvipsnames]{pstricks}
% \usepackage{epsfig}
% \usepackage{pst-grad} % For gradients
% \usepackage{pst-plot} % For axes
\scalebox{0.7} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-4)(12.0,3)
\psframe[linewidth=0.04,dimen=outer](3,3)(0.0,2)
\psframe[linewidth=0.04,dimen=outer](11.0,-2.2)(8,-3.2)
\pscustom[linewidth=0.04]
{
\newpath
\moveto(3.1,2.5)
%\lineto(7.5,1.5)
\curveto(3.3,2.5)(3.5,2.4)(4.5,1.7)
}
\rput(4.7, 2.8){\LARGE queue\_put}
\psline[linewidth=0.04cm](4.55,1.9)(4.5,1.7)
\psline[linewidth=0.04cm](4.4,1.6)(4.5,1.7)


\pscustom[linewidth=0.04]
{
\newpath
\moveto(7.2,-1.6)
%\lineto(7.5,1.5)
\curveto(7.2,-1.6)(8,-1.2)(9.5,-2.1)
}
\rput(9, -1.){\LARGE queue\_rem}
\psline[linewidth=0.04cm](9.15,-2.2)(9.5,-2.1)
\psline[linewidth=0.04cm](9.2,-1.8)(9.5,-2.1)


\psframe[linewidth=0.04,dimen=outer](7,1.5)(4,0.5)
\psframe[linewidth=0.04,dimen=outer](7,0.2)(4,-0.8)
\psframe[linewidth=0.04,dimen=outer](7,-1.1)(4,-2.1)
\end{pspicture}
}
\caption{Die Warteschlange\label{warteschlange}}
\end{center}
\end{figure}

Die wichtigsten Schritte sind:
\begin{enumerate}
\item Freie Platz finden
\item $heap$ Eigenschaft wiederherstellen
\end{enumerate}
Zuerst möchten wir den ersten freien Platz finden. Lass uns annehmen
das Folgende Beispiel. Eine Familie möchte ein Ticket für ein Konzert kaufen.
Aber es gibt nur eine Karte, und die Eltern dürfen nicht gehen, sie müssen sich 
um ihre Kinder kümmern. Zuerst der Kopf der Familie geht zur Ticketschalter
um das Ticket zu kaufen, und wenn er/sien  kein Kind hat, hat er Glück und
kann zum Konzert gehen. Aber wenn er Kind hat, er ist sehr Höflich, und 
geb die Möchkligkeit für ihre Kinder zum Konzert zu gehen, in anderen Wörte, er
stellt ihre Kinder zur Warteschlange. Weil das Kind alles tun könnte. Dies wird 
weitergehen bis der aktuellen Käufer keine Kind hat. Dieses Beispiel ist ähnlich 
wie unsere Probleme: den ersten freien Platz zu finden. Nachdem Beispiel ist es 
klar, dass wir eine Datenstrukture ähnlich wie die Warteschlange verwenden müssen. 
In der Abbildung \ref{warteschlange} wir zeigen wie die Warteschlange
funktioniert. Das großte Unterschied zwischen Stapelspeicher und Werteschlange ist,
dass im Werteschlange das erste gekommene Element zuerst auskommen kann. 
So die Umsetzung ist ähnlich wie im Stapelspeicher. Die Untershiede sind
\begin{enumerate}
\item Das Typ der gespeicherte Variable
\item Das pop() Funktion muss das letzte Element ausgeben
\end{enumerate}

Deises Endprojekt wird mehr aus 100 Zeilen Code bestehen.
Um die Durchsichtigkeit unseres Programm zu verteidigen müssen
wir die verschieden Teilen im getrennte Datei schreiben und
das headerdatei verwenden. Beispielweise, das ist ganz ähnlich wie der 
$printf$ Funktion. Im headerdatei wir müssen die Typendefinition
und die Funktiondeklarationen speichern. Achtung, die Typ deklaration
müssen in einem Verschiedenen Datei sein, weil es Querverweise
gibt. Beispielweise zeigen wir hier das Quelltext und die Headerdatein
für die Warteschlange:

\begin{myexampleprogram}{ Programme: \texttt{Die Warteschlange}}	
\begin{lstlisting}{heapqueue.h}
typedef struct heap {
    int val;
    struct heap *left;
    struct heap *right;
    struct heap *parent;
} heap;
typedef struct queue {
    struct queue *next;
    heap *element;
} queue;
\end{lstlisting}
\begin{lstlisting}{queue.h}
queue *newqueue(heap *data);
void queue_put(heap *data, queue **first);
heap *queue_rem(queue **first);
void print_queue(queue *first);
void free_queue(queue **first);
\end{lstlisting}

\begin{lstlisting}{queue.c}
#include "heapqueue.h"
#include <stdio.h>
#include <stdlib.h>
queue *newqueue(heap *data) {
    queue *q = (queue *)malloc(sizeof(queue));
    q->element = data;
    q->next = NULL;
    return q;
}
void queue_put(heap *data, queue **first) {
    if ((*first) == NULL) {
        (*first) = newqueue(data);
        return;
    }
    queue *temp = newqueue(data);
    temp->next = (*first);
    (*first) = temp;
}
heap *queue_rem(queue **first) {
    queue *temp;
    heap *ret;
    if ((*first) == NULL) {
        return NULL;
    }
    if ((*first)->next == NULL) {
        ret = (*first)->element;
        free((*first));
        (*first) = NULL;
        return ret;
    }
    temp = (*first);
    queue *prev;
    while (temp->next != NULL) {
        prev = temp;
        temp = temp->next;
    }
    prev->next = NULL;
    ret = temp->element;
    free(temp);
    return (ret);
}
void print_queue(queue *first) {
    queue *temp = (first);
    if (temp == NULL) {
        return;
    }
    for (;;) {
        printf("%d\t", temp->element->val);
        temp = temp->next;
        if (temp == NULL)
            break;
    }
    printf("\n");
}
void free_queue(queue **first) {
    if ((*first) == NULL)
        return;
    queue *temp = (*first);
    queue *temp2;
    for (;;) {
        temp2 = temp->next;
        free(temp);
        temp = temp2;
        if (temp == NULL)
            break;
    }
}
\end{lstlisting}
\end{myexampleprogram}
Das Datei $heapqueue.h$ wird die Typdefinitionen enthalten. Wir müssen
diese Headerdatei im Codetext für Warteschlange beilegen, um der Kompiler
den Typ $heap$ verstehen zu können. Natürlich wir müssen ein eigenen 
Headerdatei für die Warteschlange erzeugen, weil die Funktionen 
werden in einem anderen Datei ($heap.c$) verwenden. Das Unterschied
zwischen Stapelspeicher und Warteschlange siehst du im $queue.c$ Zeile 33-36.
In diesem Teil wir suchen für das letzte (freigegebene) Element in
der Warteschlange.

Jetzt wir müssen das $heap$ Eigenschaft überprüfen. Das ist ganz einfach, 
wir ziehen das eingegebenen Element oben bis das $heap$ Eigenschaft wahr wird.
Wir zeigen hier das in der Praxis:
\begin{lstlisting}
while (current_heap->parent != NULL &&
       current_heap->parent->val < current_heap->val) {
    SWAP(current_heap->parent->val, current_heap->val);
    current_heap = current_heap->parent;
}
\end{lstlisting} 
In der dritten Zeile wir tauschen die Werte um, und danach machen
wir ein Schritt oben mit der Zeige. Wir wiederholen es bis
das $heap$ Eigenschaft wahr wird. Jetzt wir können die zwei Teilen
zusammenstellen um ein Code für einschließen ins $heap$ bekommen.

Wenn wir den Platz gefunden haben, prüfen wir das $heap$ Eigenschaft über
(Zeile 24-26). Dann wir sind fertig, die Warteschlange wird freigegeben und
wir beenden die Schleife mit Hilfe des Strichworts $break$.
\begin{lstlisting}
void heap_insert(heap **root, int x) {
    if (*root == NULL) {
        *root = newheap(x, NULL);
    } else {
        queue *q = newqueue(*root);
        heap *currentheap;

        while ((currentheap = queue_rem(&q)) != NULL) {
            if (currentheap->left == NULL) {
                currentheap->left = newheap(x, currentheap);
                currentheap = currentheap->left;
            } else if (currentheap->right == NULL) {
                currentheap->right = newheap(x, currentheap);
                currentheap = currentheap->right;
            } else {
                queue_put(currentheap->left, &q);
                queue_put(currentheap->right, &q);
                continue;
            }
            while (currentheap->parent != NULL &&
                   currentheap->parent->val < currentheap->val) {
                SWAP(current_heap->parent->val, current_heap->val);
                currentheap = currentheap->parent;
            }
            break;
        }
        free_queue(&q);
    }
    return;
}
\end{lstlisting}
\begin{myexampleblock}{Strichwörter: \texttt{break} und \texttt{continue}}
\begin{itemize}
\item break: Beenden eine Schleife, oder ein Selektion im $switch$.
\item continue: Springen in einer Schleife zu dem nächsten Iteration
\end{itemize}
\end{myexampleblock}
In diesem Codeteil wir haben der Funktion $newheap$ verwendet. Dieser Funktion
erzeugt ein neues $heap$ Element und hat zwei Eingabeparameter: ein für den neuen 
Wert, und ein Zeiger für ihre Elter. Die aktuellen Quelltext für diese Funktion 
siehst du unter:
\begin{lstlisting}
heap *newheap(int x, heap *parent) {
    heap *ret = (heap *)malloc(sizeof(heap));
    ret->left = NULL;
    ret->right = NULL;
    ret->parent = parent;
    ret->val = x;
    return ret;
}
\end{lstlisting}
Wenn das $heap$ leer ist, das Programm ist ganz einfach. Wir einschließen ein neues 
Element als die neue Wurzel (Zeile 3). Anderfalls wir suchen für den ersten freien Platz
(Siehe die Diskussion oben). Wir schließen die Wurzel in einem Warteschlange, und 
machen eine Schleife bis die Warteschlange leer wird. Wenn wir ein Element
ohne zwei Kinder von der Warteschlange ausgenehmen haben, wird sind fertig, wir
haben den Platz gefunden. Anderfalls wir schließen ihre Kinder in der Warteschlange
ein und springen auf den nächsten Iteration mit Hilfe des Stichwort $continue$.
\begin{myexampleprogram}{Programme: \texttt{Haldensortierung}}
\begin{lstlisting}
typedef struct heap {
    int val;
    struct heap *left;
    struct heap *right;
    struct heap *parent;
} heap;
\end{lstlisting}
\begin{lstlisting}
heap *newheap(int x, heap *parent) {
    heap *ret = (heap *)malloc(sizeof(heap));
    ret->left = NULL;
    ret->right = NULL;
    ret->parent = parent;
    ret->val = x;
    return ret;
}
\end{lstlisting}
\begin{lstlisting}
void heap_insert(heap **root, int x) {
    if (*root == NULL) {
        *root = newheap(x, NULL);
    } else {
        queue *q = newqueue(*root);
        heap *currentheap;

        while ((currentheap = queue_rem(&q)) != NULL) {
            if (currentheap->left == NULL) {
                currentheap->left = newheap(x, currentheap);
                currentheap = currentheap->left;
            } else if (currentheap->right == NULL) {
                currentheap->right = newheap(x, currentheap);
                currentheap = currentheap->right;
            } else {
                queue_put(currentheap->left, &q);
                queue_put(currentheap->right, &q);
                continue;
            }
            while (currentheap->parent != NULL &&
                   currentheap->parent->val < currentheap->val) {
                int temp = currentheap->parent->val;
                currentheap->parent->val = currentheap->val;
                currentheap->val = temp;
                currentheap = currentheap->parent;
            }
            break;
        }
        free_queue(&q);
    }
    return;
}
\end{lstlisting}
\begin{lstlisting}
int heap_remove(heap **root) {
    int ret;
    if (*root != NULL) {
        queue *q = newqueue(*root);
        heap *previousheap;
        heap *currentheap;

        while ((currentheap = queue_rem(&q)) != NULL) {
            if (currentheap->left != NULL)
                queue_put(currentheap->left, &q);
            if (currentheap->right != NULL)
                queue_put(currentheap->right, &q);
            previousheap = currentheap;
        }
        currentheap = previousheap;
        free_queue(&q);

        if (currentheap->parent == NULL) {
            ret = currentheap->val;
            free(currentheap);
            *root = NULL;
            return ret;
        } else {
            ret = (*root)->val;
            (*root)->val = currentheap->val;
            currentheap = currentheap->parent;
            if (currentheap->right != NULL) {
                free(currentheap->right);
                currentheap->right = NULL;
            } else {
                free(currentheap->left);
                currentheap->left = NULL;
            }
            int a, b, c;
            currentheap = *root;
            while (1) {
                if (currentheap->left == NULL) {
                    break;
                } else if (currentheap->right == NULL) {
                    a = currentheap->val;
                    b = currentheap->left->val;
                    if (a < b) {
                        currentheap->val = b;
                        currentheap->left->val = a;
                        currentheap = currentheap->left;
                    } else {
                        break;
                    }
                } else {
                    a = currentheap->val;
                    b = currentheap->left->val;
                    c = currentheap->right->val;
                    if (a >= b && a >= c) {
                        break;
                    } else if (b > a && b >= c) {
                        currentheap->left->val = a;
                        currentheap->val = b;
                        currentheap = currentheap->left;
                    } else {
                        currentheap->right->val = a;
                        currentheap->val = c;
                        currentheap = currentheap->right;
                    }
                }
            }
            return ret;
        }
    } else
        return -1;
}
\end{lstlisting}
\end{myexampleprogram}
\subsubsection{Formattierte Eingabe und Ausgabe}
\begin{myexampleblock}{Function definition \texttt{printf}}
int printf(char * formattierung\_text, $\cdots$);
\begin{itemize}
\item Rückgabe Wert: Der Anzahl der ausgedrückten Zeichen
\item Parameters:
\begin{enumerate}
\item formattierung\_text: Eine Zeichenkette, beendet mit dem \'{}\\0\'{} Zeichen, specifiziert wie mann die Daten
audrücken will
\end{enumerate}
\end{itemize}
\end{myexampleblock}
\pagebreak
