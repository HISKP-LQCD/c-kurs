\section{Dynamische Speicherverwaltung}

Wir haben einen Sortieralgorithmus geschrieben. Das ist toll, aber wir können
unsere Programme in einigen Richtungen verbessern:

\begin{enumerate}
    \item
        In allen Fallen wir verwenden die \texttt{int} Variable \texttt{MAXNUM}
        um die Arraylänge festzulegen. Es kann auch wenig sein (siehe unsere
        Nachricht in der \texttt{read} Funktion), aber es kann auch zu viel
        sein. Beispielweise wenn wir nur 100 Elemente haben, verschwenden wir
        99\% der erforderlichen Speicherzellen. Wir können dies mithilfe der
        dynamischen Speicherverwaltung verbessern.
    \item
        Obwohl der Algorithmus vom Einfügesortieren sehr einfach zu verstehen
        ist, es ist nicht der schnellste. Wenn wir $n$ Elemente sortieren
        wollen, skaliert die Zeit für die Sortierung quadratisch mit $n$. Wir
        können eigene Datentypen herstellen und damit besser Algorithmen
        implementieren, um unseres Programm schneller zu machen.

        % FIXME Was haben die Datentypen mit der Skalierung zu tun?
    \item
        Wir können auch das Teil der Eingabe verbessern. So könnten wir zum
        Beispiel direkt aus einer Datei einlesen.

    \item
        Um das Programmieren übersichtlicher zu machen, sollten wir
        zusammengehörende Teile, die mehr als ungefähr 100 Zeilen haben, in
        eigene C-Dateien auslagern. Dafür werden wir dann den Linker nutzen
        müssen.
\end{enumerate}

Zuerst werden wir kennenlernen, wie wir auf dynamischen Speicher zugreifen
können. Wir können den Speicher in zwei Teile teilen:

\begin{description}
    \item[Statischer Speicher]
        Diesen Teil haben wir schon kennengelernt. Wenn wir eine Variable
        definieren, weisen wir ihr Speicherzellen von diesem Platz zu. Es kann
        immer mit ihrem Name zugegriffen werden. Ihre Lebensdauer und
        Sichtbarkeit hängt von ihrem Platz in dem Quelltext ab. Wenn wir eine
        Variable in einem Block (geschweifte Klammern) definiert haben, können
        wir sie nur innerhalb dieses Blocks verwenden.

    \item[Dynamischer Speicher]
        Diese Art Speicher müssen wir reservieren (es ist nicht automatisch,
        wie im Fall des statischen Speichers). Speicher dieser Art wird zur
        Verfügung stehen, bis wir ihn explizit freigeben. Das bedeutet, dass
        dessen Lebensdauer nur von uns abhängt. Außerdem ist er für alle
        Programmteile sichtbar, die die Adresse haben. Dass bedeutet, dass der
        Name der Variablen nicht wichtig ist (wir können ihn auch ändern) und
        (auch) nur mit der Adresse zugegriffen werden kann.
\end{description}

\begin{myexampleblock}{Block}
Ein Block ist eine eine Abfolge von sequenziellen Anweisungen, die
zwischen geschweiften Klammern sind.
\end{myexampleblock}

\begin{figure}[!ht]
% Generated with LaTeXDraw 2.0.8
% Tue Feb 28 11:46:41 CET 2017
% \usepackage[usenames,dvipsnames]{pstricks}
% \usepackage{epsfig}
% \usepackage{pst-grad} % For gradients
% \usepackage{pst-plot} % For axes
\scalebox{0.5} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-1.2792188)(31.8,1.2792188)
\psframe[linewidth=0.04,dimen=outer](31.8,1.1657813)(0.0,-1.0342188)
\psline[linewidth=0.04cm](5.6,1.1657813)(5.6,-1.0342188)
\rput(1.1,0.7 ){\LARGE Statische}
\rput(7.2,0.7 ){\LARGE Dynamishe}
\rput(1.1,0.1 ){\LARGE Memory}
\rput(7.2,0.1 ){\LARGE Memory}
\psline[linewidth=0.04cm](3.4,1.1657813)(3.4,-1.0342188)
\psline[linewidth=0.04cm](4.0,1.1657813)(4.0,-1.0342188)
\usefont{T1}{ptm}{m}{n}
\rput(4.416406,-1.5){\LARGE Pointer}
\psframe[linewidth=0.04,dimen=outer](18.2,1.1657813)(14.4,-1.0342188)

\rput(16,0.7 ){\LARGE Reservierte}
\rput(16,0.1 ){\LARGE Speicher}

\pscustom[linewidth=0.04]
{
\newpath
\moveto(4.,-2)
%\lineto(7.5,1.5)
\curveto(6,-3.)(10.5,-5.)(14.5,-1.5)
}
\psline[linewidth=0.04cm](14.1,-1.6)(14.5,-1.5)
\psline[linewidth=0.04cm](14.3,-2.0)(14.5,-1.5)

\end{pspicture} 
}
\vspace{0.6cm}
\caption{\label{abmem} Aufteilung des Speichers in statischen und dynamischen Teil.}
\end{figure}

Um Speicher dynamisch zu reservieren, können wir die Funktionen aus der
Standardbibliothek verwenden. Beispielsweise die \texttt{malloc} Funktion. Alle
Funktionen zu diesem Thema sind im Header \texttt{stdlib.h} definiert. Die
\texttt{malloc} Funktion wird uns einen Pointer geben, mit dem wir den Speicher
erreichen können. Aber welchen Typ von Pointer wird sie zurückgeben? Je nach
Typ der Variablen, die wir speichern wollen, brauchen wir einen anderen
Zeigertyp. Die Sprache bietet für diesen Fall Pointer mit \texttt{void} Typ.
Wir können ein Pointer von \texttt{void} Typ nicht dereferenzieren, da nicht
klar ist, welchen Art von Daten die Bytes im Speicher repräsentieren sollen.
Wir können ihn aber zu dem angemessenen Typ \emph{casten} mit dem \emph{casting
operator}: \texttt{(Typ *)}. Weist man einen Pointer vom Typ \texttt{void *}
einer Variable vom Typ \texttt{int *} zu, erhält man einen impliziten Cast.

Nach jeder Reservierung müssen wir überprüfen, ob die Reservierung erfolgreich
war. Wir müssen prüfen, ob der Wert des Pointers ungleich \texttt{NULL} ist. Wenn dieser Fall eintritt, konnte kein Speicher reserviert werden. Die Behandlung des Fehlers hängt von der Situation ab. Möchten wir einen sehr großen Bereich reservieren, der die Kapazität des Arbeitsspeichers übersteigt, können wir das Problem eventuell beheben. Kann unserer Algorithmus auch mit weniger Speicher auskommen, können wir dann erneut versuchen, mit weniger Speicher weiterzuarbeiten. In den meisten Fällen ist es aber sinnvoll, das Programm dann abzubrechen. Wenn schon kleine Mengen Speicher nicht mehr reserviert werden können, stehen wir mit dem Rücken an der Wand. Wir können nur noch Aufräumen und das Programm beenden.

Die mit \texttt{malloc} reservierten Speicherzellen werden nicht initialisiert
sein. Um das zu erreichen können wir die \texttt{calloc} Funktion verwenden.

\begin{myexampleblock}{Funktionsdefinition \texttt{malloc}}
\begin{lstlisting}
void *malloc(size_t size);
\end{lstlisting}
\vspace{-0.7cm}
Reserviert Speicherzellen von Größe \texttt{size}.
\begin{itemize}
\itemsep0.2pt
\item Rückgabewert: Wenn die Reservierung erfolgreich war, ein Pointer für den Anfang der 
reservierten Speicherzellen, andernfalls \texttt{NULL}.
\item Eingabeparamter: \texttt{size}: Größe des angeforderten Speichers
\item Beispielweise:
\begin{lstlisting}
int *array = malloc(sizeof(*array) * 10);
\end{lstlisting}
\end{itemize}

Achtung! Wenn wir die reservierten Speicherzellen nicht mehr brauchen, müssen
Sie von uns freigegeben werden.
\end{myexampleblock}

Alternativ zu obigem Beispiel wäre auch folgendes möglich:

\begin{lstlisting}
int *array = malloc(sizeof(int) * 10);
\end{lstlisting}

Der Unterschied ist das Argument von \texttt{sizeof}. Der Vorteil der oberen Methode ist, dass man immer den gleichen Datentyp für \texttt{*array} und \texttt{sizeof} nimmt. Es kommt immer wieder mal vor, dass man den Datentyp nachträglich ändert, jedoch nur den Typ der Variablen ändert und das Argument von \texttt{sizeof} vergisst. Die obige Schreibweise verhindert diese Fehlerklasse.

Wenn in einem lange laufenden Programm immer mehr Speicherzellen reserviert werden, ist irgendwann kein Speicher mehr frei. Das Betriebssystem kann unserem Programm keinen Speicher mehr zur Verfügung stellen. Irgendwann gibt \texttt{malloc} dann nur noch \texttt{NULL} zurück. Daher muss jeder Speicher wieder freigegeben werden, wenn er nicht mehr gebraucht wird. Dies wird mit der Funktion \texttt{free} gemacht.

\begin{myexampleblock}{Funktionsdefinition \texttt{free}}
\begin{lstlisting}
void free(void *memory);
\end{lstlisting}
\vspace{-0.7cm}
Freigib die Speicherzellen, die mit \texttt{malloc} reservierten wurden.
\begin{itemize}
\item Einggabeparamter: Pointer für den Anfang der freigegebenen Speicherzellen
\item Zum Beispiel:
\begin{lstlisting}
free(array);
\end{lstlisting}
\end{itemize}
\vspace{-0.7cm}
\end{myexampleblock}

Wir können eindimensionale Vektoren entweder mit Pointer oder mit Arrays darstellen.
Aber wie können wir mehrdimensionale Objekte herstellen und was verstehen wir eigentlich 
unter mehrere dimensionalen Objekte? Lasst uns annehmen, dass wir Vektoren in zwei Dimensionen haben,
beispielsweise Bewegungsvektoren $\vec{r}=\left(\begin{array}{c}x\\y\end{array}\right)$. Sie sind 
Vektoren (eindimensionale Objekte), deren Koordinaten nur mit einem Index angegeben werden
können. In unserem Beispiel sind sie $\left(\vec{r}\right)_1=x$ und $\left(\vec{r}\right)_2=y$.
Eine lineare Operation, die aus einem Vektor ein neues herstellen, nennen
wir zwei dimensionales Objekt. Zum Beispiel eine Drehung mit einem Winkel $\alpha$:
\begin{equation}
\left(\begin{array}{c}x^{,}\\y^{,}\end{array}\right)=
\left(\begin{array}{cc} \cos\left(\alpha\right) & \sin\left(\alpha\right) \\
                       -\sin\left(\alpha\right) & \cos\left(\alpha\right) 
\end{array}\right)
\left(\begin{array}{c}x\\y\end{array}\right)
\end{equation}
Die Rotation kann durch eine Matrix dargestellt werden. Um diese Matrizen
in C verwenden zu können, brauchen wir zweidimensionale Arrays. Wir können
dies mit einem weiteren Paar eckigen Klammern erreichen, zum Beispiel 
\begin{lstlisting}
double rotate2d[2][2];
\end{lstlisting}

In anderen Worten: Wir brauchen Arrays von Arrays. Aber wir haben gelernt, dass
was wir mit einem Array machen können, können wir auch mit Pointern erledigen.
In diesem Fall aber brauchen wir auch Pointer auf Pointer. Wir zeigen in der
Abbildung~\ref{mem2d} was in diesem Fall passiert. Wir haben am Anfang eine
Variable in einer statischen Speicherzelle mit Typ \texttt{double} Pointer auf
Pointer. Danach müssen wir Speicherzellen reservieren für Pointer mit
\texttt{malloc}. Wir reservieren Speicher für die Elementen im mittleren Teil
der Abbildung~\ref{mem2d}. \texttt{malloc} wird die Anfangsadresse von den
reservierten Speicherzellen zurückgeben. Das wird der Wert der Pointer auf
Pointer Variable sein. Zum Ende müssen wir für jeden Pointer Speicherzellen für
zwei \texttt{double} Variablen reservieren. Das ist alles. Folgend ist der
Quelltext zur diesen Übung:

\begin{lstlisting}
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#define SPACEDIM 2
int main() {
    double **array2d;
    int i, j;
    array2d = (double **)malloc(sizeof(double *) * SPACEDIM);
    for (i = 0; i < SPACEDIM; ++i)
        array2d[i] = (double *)malloc(sizeof(double) * SPACEDIM);
    array2d[0][0] = cos(M_PI / 4.);  /* Alternative *(*(array+0)+0) */
    array2d[0][1] = sin(M_PI / 4.);  /* Alternative *(*(array+0)+1) */
    array2d[1][0] = -sin(M_PI / 4.); /* Alternative *(*(array+1)+0) */
    array2d[1][1] = cos(M_PI / 4.);  /* Alternative *(*(array+1)+1) */
    for (i = 0; i < SPACEDIM; ++i) {
        for (j = 0; j < SPACEDIM; ++j)
            printf("%e ", array2d[i][j]);
        printf("\n");
    }
}
\end{lstlisting}
\begin{figure}[!ht]
% Generated with LaTeXDraw 2.0.8
% Tue Feb 28 15:43:57 CET 2017
% \usepackage[usenames,dvipsnames]{pstricks}
% \usepackage{epsfig}
% \usepackage{pst-grad} % For gradients
% \usepackage{pst-plot} % For axes
\center
\scalebox{0.75} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-5)(14.8,4.1)

\pscustom[linewidth=0.04]
{
\newpath
\moveto(3.2,1.)
%\lineto(7.5,1.5)
\curveto(3.2,1.5)(4.8,3.5)(6.7,2.2)
}
\psline[linewidth=0.04cm](6.5,2.6)(6.7,2.2)
\psline[linewidth=0.04cm](6.3,2.3)(6.7,2.2)



\psframe[linewidth=0.04,dimen=outer](3.0,0.8725)(0.0,-0.1275)
\rput(1.6, 1.3){Typ: double **}
\rput(1.6, 0.3){Wert:0x1deb430}
\rput(1.6,-0.7){Adresse: 0x7fff541bdbc8}


\pscustom[linewidth=0.04]
{
\newpath
\moveto(9.,2.1)
%\lineto(7.5,1.5)
\curveto(9.,2.5)(10.1,3.1)(11,3.8)
}
\psline[linewidth=0.04cm](10.6,3.7)(11,3.8)
\psline[linewidth=0.04cm](10.6,3.2)(11,3.8)


\psframe[linewidth=0.04,dimen=outer](8.8,1.8)(5.2,0.8)
\rput(6.8, 2.0){Typ: double *}
\rput(6.8, 1.4){Wert:0x1deb450}
\rput(6.8, 0.4){Adresse: 0x1deb430}

\pscustom[linewidth=0.04]
{
\newpath
\moveto(9.,-0.2)
%\lineto(7.5,1.5)
\curveto(9.,-0.2)(10.1,-0.4)(11,-0.9)
}
\psline[linewidth=0.04cm](10.5,-0.5)(11,-0.9)
\psline[linewidth=0.04cm](10.3,-0.7)(11,-0.9)

\psframe[linewidth=0.04,dimen=outer](8.8,-0.25)(5.2,-1.25)
\rput(6.8, -0.1){Typ: double *}
\rput(6.8, -0.7){Wert:0x1deb470}
\rput(6.8, -1.7){Adresse: 0x1deb438}




\psframe[linewidth=0.04,dimen=outer](14.8,3.9)(11.2,2.9)
\rput(13., 4.05){Typ: double }
\rput(13., 3.5){Wert: $\pi$/4}
\rput(13., 2.6){Adresse: 0x1deb450}

\psframe[linewidth=0.04,dimen=outer](14.8,1.7)(11.2,0.7)
\rput(13., 1.85){Typ: double }
\rput(13., 1.3){Wert: $\pi$/4}
\rput(13., 0.4){Adresse: 0x1deb458}

\psframe[linewidth=0.04,dimen=outer](14.8,-0.7)(11.2,-1.7)
\rput(13., -0.55){Typ: double }
\rput(13., -1.1){Wert: -$\pi$/4}
\rput(13., -2.){Adresse: 0x1deb470}

\psframe[linewidth=0.04,dimen=outer](14.8,-2.9)(11.2,-3.9)
\rput(13., -2.65){Typ: double }
\rput(13., -3.2){Wert: $\pi$/4}
\rput(13., -4.1){Adresse: 0x1deb478}


\rput(1.464063,-4.8){\large Pointer auf Pointer}
\rput(7.271094,-4.8){\large Pointers auf  double Variablen}
\rput(13.05875,-4.8){\large double Variablen}
\end{pspicture} 
}
\caption{\label{mem2d} Pointers auf Pointer}
\end{figure}

In der achten Zeile reservieren wir Speicherzellen für Pointer
und danach in einer Schleife reservieren wir Speicherzellen für
die Fließkommazahlen. Für die Indexierung wir können
entweder mehrere eckigen Klammern \texttt{(array2d[i][j])} oder
den Dereferenzierungsoperator \texttt{(*(*(array2d+i)+j))} verwenden.
Sie sind in jeder Hinsicht gleichwertig. Von Zeile 15 bis 19 
stellen wir vor, wie man ein zweidimensionales Objekt
auf dem Bildschirm ausgeben kann. In diesem Fall drücken 
wir die Elementen im Spalten-Zeilen Modus aus.

Zum Ende zeigen wir, wie man diese Objekte in Funktion herstellen kann. In der
Funktion müssen wir den Wert von \texttt{array2d} ändern d.\,h. wenn wir zurück
aus dem Funktion gekommen sind, muss \texttt{array2d} einen neuen Wert haben.
Um diese Übung zu erledigen, müssen wir ihre Adresse übergeben und die Funktion
muss einer Pointer auf \texttt{**} erhalten. Wir zeigen es ausdrücklich in den
unteren Quelltext. Im Allgemeinen wenn wir den Wert von einem $n$ dimensionalen
Objekte in einer Funktion ändern wollen, müssen wir deren Adresse übergeben,
und die Funktion soll eine Pointer auf $n+1$ dimensionales Objekt erhalten.

\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#define SPACEDIM
void create2darray(double ***p1) {
    int i;
    (*p1) = (double **)malloc(sizeof(double *) * SPACEDIM);
    for (i = 0; i < SPACEDIM; ++i)
        (*p1)[i] = (double *)malloc(sizeof(double) * SPACEDIM);
}
int main() {
    double **array2d;
    int i, j;
    create2darray(&array2d);
    array2d[i] = (double *)malloc(sizeof(double) * SPACEDIM);
    array2d[0][0] = cos(M_PI / 4.); /*Alternative *(*(array+0)+0) */
    array2d[0][1] = sin(M_PI / 4.); /*Alternative *(*(array+0)+1) */
    array2d[1][0] = -sin(M_PI / 4.); /*Alternative *(*(array+1)+0) */
    array2d[1][1] = cos(M_PI / 4.); /*Alternative *(*(array+1)+1) */
    for (i = 0; i < SPACEDIM; ++i) {
        for (j = 0; j < SPACEDIM; ++j)
            printf("%e ", array2d[i][j]);
        printf("\n");
    }
}
\end{lstlisting}
