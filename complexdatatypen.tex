\section{Complex Datatypen}

Je nach Problemstellung ist es manchmal sehr hilfreich, Datenstrukturen selbst erzeugen zu können.
Ein einfaches mathematisches Beispiel ist eine Datentyp für komplexe Zahlen.
Eine komplexe Zahl muss dabei eine Real- und Imaginärteil haben.

Genau für solche Fälle stellt C die Möglichkeit zur Verfügung, zusammengesetzte Datentypen zu definieren.
Das entsprechende Schlüsselwort ist \verb|struct|.
Solche zusammengesetzten Datentypen in C kann man sich wie Kontainer vorstellen.
Die allgemeine Benutzung von \verb|struct| ist wie folgt:
\begin{myalertblock}{Deklaration eines struct}
  \begin{lstlisting}
    struct name
    {
      Type1 name1;
      Type2 name2;
      Type3 name3;
      ...
    };
  \end{lstlisting}
  \vspace{-0.4cm}
  Die Verwendung als Typ für eine Variable:
  \begin{lstlisting}
    struct name variablename;
  \end{lstlisting}
  \vspace{-0.4cm} 
\end{myalertblock}
Ein solcher Kontainer für komplexe Zahlen könnte also wie folgt aussehen:
\begin{lstlisting}
  struct cmplx {
    double re, im;
  };
\end{lstlisting}
mit zwei \verb|double| Elementen für den Real- und den Imaginärteil. 
Der Zugriff auf die einzelnen Elemente erfolgt über den Namen des \verb|struct| und den Namen des Elements, getrennt durch einen Punkt.
In unserem Beispiel für komplexe Zahlen also 
\begin{lstlisting}
  #include<stdio.h>

  struct cmplx {
    double re, im;
  };
  int main() {
    struct cmplx z;
    z.re = 1.0;
    z.im = 3.4;
    printf("z hat Realteil %e und Imaginaerteil %e\n", z.re, z.im);
    return(0);
  }
\end{lstlisting}
Also, allgemein gesprochen greift man auf die Elemente über 
\begin{lstlisting}
  structname.elementname = wert;
\end{lstlisting}
zu.
Elemente können selbst wieder ein \verb|struct| sein.
Einen Unterschied gibt es beim Zugriff auf Elemente, wenn man einen Zeiger auf einen \verb|struct| benutzt.
Dort kann man direkt mit dem Pfeil Operator \verb|->| auf die Elemente zugreifen, also etwas
\begin{lstlisting}
  #include<stdio.h>

  struct cmplx {
    double re, im;
  };
  int main() {
    struct cmplx z;
    struct cmplx * v = &z;
    v->re = 1.0;
    v->im = 3.4;
    printf("z hat Realteil %e und Imaginaerteil %e\n", v->re, v->im);
    return(0);
  }
\end{lstlisting}
Elemente eines \verb|struct| können natürlich auch Zeiger sein.
Allerdings muss dann Speicher außerhalb der Deklaration stattfinden.

Die Verwendung von \verb|struct| ist sehr hilfreich, wenn beispielsweise eine Liste von logisch zusammengehörigen Daten bearbeiten soll, also etwa den Real- und Imaginärteil.
Es muss dann nicht mehr jedes Element einzeln übergeben werden, sondern nur noch einmal der Kontainer.
Der Zusammenhang der einzelnen Elemente bleibt damit erhalten.

Ein Beispiel aus der C Standardbibliothek \verb|time.h| ist das \verb|struct tm| für Datum und Zeit:
\begin{lstlisting}
  struct tm{
    int tm_sec;   // Sekunde
    int tm_min;   // Minute
    int tm_hour;  // Stunde
    int tm_mday;  // Tag
    int tm_mon;   // Monat
    int tm_year;  // Jahr
    int tm_wday;  // Wochetag
    int tm_yday;  // Tag im Jahr
    int tm_isdst; // Sommerzeit oder nicht
  };
\end{lstlisting}
Damit kann über die Funktion
\begin{myexampleblock}{Funktion: \texttt{time}}
  \begin{lstlisting}
    time_t time(time_t *t)
  \end{lstlisting}
  \vspace{-0.4cm}
  \verb|time| gibt die Zeit in Sekunden seit 1970-01-01 00:00:00 +0000 (UTC) zurück.
  Falls \verb|t| nicht \verb|NULL| ist, wird das Ergebnis zusätzlich in \verb|t| gespeichert.
  \verb|time_t| ist vom Typ \verb|long int|.
\end{myexampleblock}
und die Funktion
\begin{myexampleblock}{Funktion: \texttt{localtime}}
  \begin{lstlisting}
    struct tm * localtime (time_t * timer);
  \end{lstlisting}
  \vspace{-0.4cm}
  Eingabeparameter: Zeiger auf eine Variable vom Typ \verb|time_t|.
  Rückgabeparameter: Zeiger auf ein \verb|struct tm|.
\end{myexampleblock}
die beide in \verb|time.h| deklariert sind.
Folgendes Beispiel illustriert deren Benutzung:
\begin{lstlisting}
  #include <stdlib.h>
  #include <stdio.h>
  #include <time.h>
  
  int main() {
    time_t now;
    struct tm *local_date_time;
    char *tagarray[7]={"Sonntag","Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag"};
    now = time(NULL);
    local_date_time = localtime(&now);

    printf ("Jahr: %d\n", local_date_time->tm_year+1900);
    printf ("Monat: %d\n", local_date_time->tm_mon);
    printf ("Tag: %s\n", tagarray[local_date_time->tm_wday]);
    printf ("Stunde: %d\n", local_date_time->tm_hour);
    printf ("Minute: %d\n", local_date_time->tm_min);
    printf ("Sekunde: %d\n", local_date_time->tm_sec);
    return(0);
  }
\end{lstlisting}
Es gibt das aktuelle Datum und die aktuelle Zeit aus.
Dabei wird zunächst die Funktion \verb|time| aufgerufen, und desse Rückgabewert dann an die Funktion \verb|localtime| übergeben.
In beiden Funktionsaufrufen mussten wir nicht mit den $9$ Elementen von \verb|struct tm| hantieren, sondern konnten bequem den Kontainer übergeben.
Da \verb|local_date_time| ein Zeiger ist, greifen wir auf dessen Elemente wieder mit dem \verb|->| Operator zu.
