\section{Verketette Liste, der Kellerspeicher}
Wir haben gelernt, wie wir die Speicherverwaltung verwenden können. Aber was passiert, wenn wir ein Element löschen wollen, oder
nochein zwischen zwei schon existierten Elementen hinzufügen möchten. In anderen Wörten, wir möchten ein Dateistrukture, das
dynamisch erhöht, oder schrumpft. Das können wir ausführen mit einer Strukture, die die Adresse des nächsten Elements enthält.
Mann kann dieses Strukture als verkettete Liste bezeichnet. Beispielweise in der \texttt{C} Sprache ein Struktureelement kann 
auch ein Zeiger auf demselben Element sein. Es gibt nur eine Bedingung für ein Feld im Strukture: Ihre Größe musst beim Kompilierung 
bekannt sein. Der Zeiger auf demselben Element erfüllt deise Bedingung. Beispielweise im \texttt{C} eine mögliche verwirlichung der
verketteten Liste zeigen wir unter:
\begin{lstlisting}
struct list{
  int element;
  struct list *naechste;
}
\end{lstlisting}
\begin{figure}[!ht]
% Generated with LaTeXDraw 2.0.8
% Sun Mar 05 19:02:52 CET 2017
% \usepackage[usenames,dvipsnames]{pstricks}
% \usepackage{epsfig}
% \usepackage{pst-grad} % For gradients
% \usepackage{pst-plot} % For axes
\scalebox{1} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,0.)(16.0,4.)
\psframe[linewidth=0.04,dimen=outer](3.,1)(0.0,3.0)
\rput(1.2, 2.5){\texttt{element: 4}}
\rput(1.2, 2.0){\texttt{naechste}:} 
\rput(1.2, 1.5){\texttt{0x1b464c0}}
\rput(1.5, 0.5){\texttt{Adresse: 0x1b464a0}} 

\psline[linewidth=0.04cm](3.5,2.)(4.5,2.)
\psline[linewidth=0.04cm](4.25,2.5)(4.5,2)
\psline[linewidth=0.04cm](4.25,1.5)(4.5,2)
\psframe[linewidth=0.04,dimen=outer](8.,1)(5.0,3.0)
\rput(6.2, 2.5){\texttt{element: 6}}
\rput(6.2, 2.0){\texttt{naechste:}}
\rput(6.2, 1.5){\texttt{0x1b46480}}
\rput(6.2, 0.5){\texttt{0x1b464c0}}
\psline[linewidth=0.04cm](8.5,2.)(9.5,2.)
\psline[linewidth=0.04cm](9.25,2.5)(9.5,2)
\psline[linewidth=0.04cm](9.25,1.5)(9.5,2)

\psframe[linewidth=0.04,dimen=outer](13.,1)(10.0,3.0)
\rput(11.2, 2.5){\texttt{element: 8}}
\rput(11.2, 2.0){\texttt{naechste:}}
\rput(11.2, 1.5){\texttt{NULL}}
\rput(11.2, 0.5){\texttt{0x1b46480}}
\psline[linewidth=0.04cm](13.,2.)(14.,2.)
\psline[linewidth=0.04cm](13.75,2.5)(14.,2)
\psline[linewidth=0.04cm](13.75,1.5)(14.,2)
\rput(15, 2.){\texttt{\LARGE NULL}}
\end{pspicture} 
}
\caption{Einmal Verketette Liste\label{verklist}}
\end{figure}
In der Abbildung \ref{verklist} wir zeigen, wie es in der Praxis
funkzioniert. Wir werden den \texttt{NULL} pointer für das Ende der verketteten
Liste verwenden. Es gibt mehrere Möglichkeiten um eine verkettete Liste herstellen.
Beispielwiese wir können auch ein Zeiger für das vorherigen Element verwenden um die Liste
auch in der andere Richtung durchgehen zu können. Mann kann das auch als
doppelt verkettete Liste bezeichnet. Viele wichtigen Datenstukturen können mit 
verketteten Listen darstellen. Beispielweise den Stapelspeicher.
Der Stapelspeicher ist ein Speicher, der nur zwei operationen hat:
\begin{itemize}
\item \texttt{push()}: Speicher ein Element im Stapelspeicher
\item \texttt{pop()} : Gib das zuletzt gespeicherte Element Zurück
\end{itemize}
Wir zeigen es in der Abbildung \ref{stapspeicher}. Die wichtigste Verwendungsmöglichkeiten
ist im \texttt{Assembly} Programmiersprache. In diesem Sprache beim Funktionanrufen die Parameters werden 
zum Stapelspeicher gestellt. Wenn wir von einem Funktion zurückkommen, 
wir nehmen ein Element vom Stapelspeicher aus als Rückgabewert. Das Grundprinzip im
Stapelspeicher ist: Den zuletzt gespeicherten Element werden wir zuerst
zurückgeben. Es ist ein \texttt{LIFO} Speichertyp: \texttt{L}ast \texttt{I}n \texttt{F}irst \texttt{O}ut.
\begin{figure}[!ht]
\begin{center}
% Generated with LaTeXDraw 2.0.8
% Sun Mar 05 20:17:29 CET 2017
% \usepackage[usenames,dvipsnames]{pstricks}
% \usepackage{epsfig}
% \usepackage{pst-grad} % For gradients
% \usepackage{pst-plot} % For axes
\scalebox{0.7} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-3)(12.0,3)
\psframe[linewidth=0.04,dimen=outer](3,3)(0.0,2)
\psframe[linewidth=0.04,dimen=outer](11.0,3)(8,2)
\pscustom[linewidth=0.04]
{
\newpath
\moveto(3.1,2.5)
%\lineto(7.5,1.5)
\curveto(3.3,2.5)(3.5,2.4)(4.5,1.7)
}
\rput(3.7, 2.8){\LARGE push}
\psline[linewidth=0.04cm](4.55,1.9)(4.5,1.7)
\psline[linewidth=0.04cm](4.4,1.6)(4.5,1.7)


\pscustom[linewidth=0.04]
{
\newpath
\moveto(7.5,2.5)
%\lineto(7.5,1.5)
\curveto(7.5,2.5)(6.8,2.5)(6.5,1.6)
}
\rput(6.7, 2.8){\LARGE pop}
\psline[linewidth=0.04cm](7.4,2.7)(7.5,2.5)
\psline[linewidth=0.04cm](7.4,2.3)(7.5,2.5)


\psframe[linewidth=0.04,dimen=outer](7,1.5)(4,0.5)
\psframe[linewidth=0.04,dimen=outer](7,0.2)(4,-0.8)
\psframe[linewidth=0.04,dimen=outer](7,-1.1)(4,-2.1)
\end{pspicture} 
}
\caption{Der Stapelspeicher\label{stapspeicher}}
\end{center}
\end{figure}

Wir werden jetzt implementieren diesen wichtigen Datenstruktur mit 
den verketteten Listen. Zuerst stellen wir der Datenstruktur vor:
\begin{lstlisting}
typedef struct list {
   struct list* next;
   int data;
} list;
\end{lstlisting}
Das ist natürlich eine verkettete Liste. Aber wir haben hier diesen Typ also definiert
mit dem Strichwort \texttt{typedef}.
\begin{myexampleblock}{Strichwort: \texttt{typedef}}
\begin{lstlisting}
typedef neuename altename;
\end{lstlisting}
\vspace{-0.4cm}
Stellt ein neues Name (\texttt{neuename}) für den Typ von \texttt{altename} her.
\end{myexampleblock}
Der größte Vorteil in diesem Fall ist, dass wir den Strichwort \texttt{struct} 
vor allen Variable definition verwenden müssen. Der \texttt{typedef} ändert nur
den Datenstrukture um in dem Codetext leichter zuzugriffen. Der Quelltext wird auch
durchsichtiger sein. Jetzt wir haben das Definition der Datenstrukture, wir können die 
Implementierung anfangen. Zuerst besprechen wir, wie können wir eine neue Stapelelement herstellen.
Wir müssen die zwei Operation \texttt{pop} und \texttt{push} als Funktion verwirklichen.
Natürlich dazu müssen wir andere (kleiner) Funktionen verwenden.
Beispielweise wir müssen eine neue Variable von Typ \texttt{list} herstellen mit dem Funktion 
\texttt{newlist} (Den Quelltext siehst du unter).
\begin{lstlisting}
list * newlist( int x ){
   list *q=(list *)malloc(sizeof(list));
   if (q == NULL){
     fprintf(stderr, "Error in Memory allocation\n");
     exit(1);
   }
   q->data=x;
   q->next=NULL;
   return q;
}
\end{lstlisting}
Der obene Codeteil gib eine \texttt{list} Element zurück und hat die
speichernde ganze Zahl als Eingabeparameter. Dieser Teil ist ganz einfach.
Wir reservieren Speicherzellen für das neue Listelement und zuweisen
den Eingabewert. Zum Ende wir müssen die nächste Element als ein \texttt{NULL} 
Zeiger festlegen. Die nächste Teil ist das \texttt{push()} Funktion. Das wird
ein neues Element zum Stapelspeichern hinzufügen.
\begin{lstlisting}
void push( int x, list ** first){
   if ((*first) == NULL){
       (*first)=newlist(x);
       return;
   }
   list *temp=newlist(x);
   temp->next=(*first);
   (*first)=temp;
}
\end{lstlisting}
Wir müssen die Adresse vom Zeiger auf das Anfangsadresse des Speichers und den speichernde 
Element als Parameter eingeben. Wenn der Stapelspeicher leer ist, wir legen die Anfangsadresse 
mit der Adresse des neuen Elements fest. In anderem Fall wir legen den nächste Zeiger von dem neuen 
Element mit dem originalle Anfangsadresse und die neue Anfangsadresse wird die Adresse vom neuen Element 
sein. Darum müssen wir nicht die Anfangsadresse als Parameter abgeben, sondern ihre Adresse,
weil wir den Wert von ihm im Funktion ändern wollen. Den logischen nächsten Schritt
ist die implementierung des \texttt{pop} Funktions. Der Rückgabewert muss den letzten gespeicherte
Element sein. Natürlich nachdem \texttt{pop} der Stapelspeicher muss ein Spatelspeicher sein. Das bedeuted
dass wir die Hierarchie beibehalten müssen. Nachdem \texttt{pop} der Knopf der Speicher (ersten Element in Folge)
muss das vorheriges zweiten sein. Darum hier wir auch müssen die Adresse vom Zeiger auf das ersten Element
als parameter eingeben. Unter kannst du die Verwirklichung im \texttt{C} sehen.
\begin{lstlisting}
int pop( list **first){
   list *temp;
   int ret;
   if ((*first) == NULL){
     printf("Es gibt kein Element im Speicher\n");
     return 0;
   }
   ret=(*first)->data;
   temp=(*first)->next;
   free(*first);
   (*first)=temp;
   return ret;
}
\end{lstlisting}
Wenn das Stapelspeicher leer war, wir werden eine Nachricht ausdrücken. 
Im anderen Fall wir legen den Rückgabewert mit dem Wert von dem ersten 
Element fest. Wir müssen auch die ersten Element freigeben, und die neue
Anfangsadresse mit dem nächste der originalen festlegen.

Wir können auch prüfen die aktuellen Inhalt des Speichers. 
Dafür müssen wir einer Funktion, der dursch die Listelementen geht
schreiben.
\begin{lstlisting}
void print_list( list *first){
   list *temp=(first);
   if (temp == NULL)
      return;
   for (;;){
      printf("%d\t", temp->data);
      temp=temp->next;
      if (temp == NULL)
        break;
   }
   printf("\n");
}
\end{lstlisting}
Dieser Funktion zuerst prüft ob der Speicher leer ist. Wenn der
Speicher nicht leer ist, wir machen eine Schleife um durch die
Listelementen gehen. In jeden iteration wir springer zur 
nächsten Element (Zeile 7). Wenn wir am Ende des Speichers
sind, beenden wir die Schleife.

Es fehlt jetzt nur noch ein Gebrauchanweisung für unseren Stapelspeichern.
Dies wird der $main$ Funktion.
\begin{lstlisting}
int main(){
   list *erste=NULL;
   push(2, &erste);  print_list(erste);
   push(4, &erste);  print_list(erste);
   push(6, &erste);  print_list(erste);
   pop( &erste );    print_list(erste);
   push(8, &erste);  print_list(erste);
   pop( &erste );    print_list(erste);
}
\end{lstlisting}
Wir definieren zuerst einer Pointer um die 
Anfangsadresse des Speichers zu speichern (Zeile 2). Dann wir machen eine
Folgen aus push und pop Anweisungen, und im jeden Schritt wir drücken
den aktuellen Zustand des Speichers aus. Die Ausgebe siehst du unter.
\begin{lstlisting}
2	
4	2	
6	4	2	
4	2	
8	4	2	
4	2	
\end{lstlisting}
Wie du siehst, wenn wir die erste $pop$ Anweisung ausführen, wurde die letzte 
eingegebene Wert (6) aus dem Speicher gelöst. 

