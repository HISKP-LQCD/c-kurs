\documentclass[xcolor=dvipsnames]{beamer}

\geometry{paperwidth=140mm,paperheight=105mm}

\input{slidespreamble}

\newcounter{lecturecounter}
\setcounter{lecturecounter}{1}

\author[B. Kostrzewa]{Bartosz Kostrzewa, Ferenc Pittler, Martin Ueding, Carsten Urbach}
\title{C-Kurs Physik, 2017}
\institute[HISKP]{HISKP, Rheinische Friedrich-Wilhelms-Universität Bonn}
% \titlegraphic{\roundbox{\includegraphics[height=2cm]{UniBonn_CRC110_ETMC_INFN}}}
\date[April 2017]{April 2017}

\begin{document}

% \frame{}
\begin{frame}
 \titlepage
\end{frame}

\begin{frame}{Administrativa}
  \begin{itemize}
  \item{Vorlesung 03.04-13.04, 10-12 Uhr, \textbf{PI HS1}}
  \begin{itemize}
    \item{06.04: \textbf{HS HISKP} }
  \end{itemize}
  \vspace{0.2cm}
  \item{Bartosz Kostrzewa, bartosz\_kostrzewa@fastmail.com, Raum 3.009 HISKP}
  \begin{itemize}
    \item{Sprechzeiten: Täglich 17:00-17:45 Uhr}
  \end{itemize}
  \vspace{0.2cm}
  \item{Tutoren}
  \begin{itemize}
    \item{Martin~Ueding, Simon~Schlepphorst, 
         \\Ferenc~Pittler, Marcel~Nitsch, Florian~Tauber} 
  \end{itemize}
  \vspace{0.2cm}
  \item{Tutorien finden statt: täglich 13:00-17:00}
  \begin{itemize}
    \item{Astro CIP Pool (Raum 0.007) [AifA, Auf dem Hügel 71]}
    \item{HISKP SR1 [HISKP, Nußallee 14-16]}
    \begin{itemize}
      \item{\textbf{ $\mathbf{18}$ Personen $\rightarrow$ Astro, $\quad\mathbf{N-18}$ $\rightarrow$ SR1} }
    \end{itemize}
  \end{itemize}
  \vspace{0.2cm}
  \item{Das Skript dient als Referenz und sollte zumindest während der Tutorien befragt werden!}
  \vspace{0.2cm}
  \item{Fundamentale Ungleichung der Programmierung (FUP!): \\ \textbf{Praxis $\mathbf{\gg}$ Vorlesungen} $\rightarrow$ besuchen Sie die Übungen, sonst bringt die Vorlesung nichts!}
  \item{Folien und Übungszettel: \textcolor{blue}{\url{http://goo.gl/xhJN08}}}
  \end{itemize}
\end{frame}

\begin{frame}{Lernziele}
\begin{itemize}
  \item{Algorithmen verstehen und entwickeln}
  \item{Algorithmen in Quelltext übertragen}
  \vspace{0.3cm}
  \item{Erstes Kennenlernen der sogennanten \emph{imperativen} Programmierung}
  \item{Kennenlernen der Daten- und Kontrollstrukturen von C99}
  \vspace{0.3cm}
  \item{Praktischer Einsatz des C-Compilers zur Übersetzung des Quelltextes in ausführbaren Maschinencode}
  \item{Erstellen eigener C-Programme in den Tutorien}
  \begin{itemize}
    \item{einfache Beispielprogrammen $\rightarrow$ kompliziertere Programme aus merheren Quelltextdateien}
    \item{Verwendung externer Bilbiotheken}
  \end{itemize}
  \vspace{0.3cm}
  \item{Vorbereitung auf \emph{physik441: Computerphysik} (SoSe 2017), \emph{physics760: Computational Physics} (WiSe 2017/2018), etwaige Bachelor- und Masterarbeiten}
\end{itemize} 
\end{frame}

\begin{frame}{Anwendung: Plasmaphysik / Fusion}
  \centering
  Wellenstein 7-x Stellerator\\ \vspace{0.2cm}
  \includegraphics[width=0.9\textwidth]{graphics/stellerator.jpg}\\
  {\small Quelle: \url{http://www.sciencemag.org/news/2015/10/bizarre-reactor-might-save-nuclear-fusion} }
\end{frame}

\begin{frame}{Anwendung: Kosmologie / Astrophysik}
  \centering
  Simulation der Galaxie M74 über 13 Milliarden Jahre\\ \vspace{0.2cm}
  \includegraphics[width=0.9\textwidth]{graphics/m74_simulation.png}\\
  {\small Quelle: \url{http://www.hpc-ch.org/first-realistic-simulation-of-the-formation-of-the-milky-way-computed-at-cscs/} }  
\end{frame}

\begin{frame}{Anwendung: Hochenergiephysik - LHC}
  \centering
  Kollision im ATLAS-Experiment\\ \vspace{0.2cm}
  \includegraphics[width=0.9\textwidth]{graphics/atlas_event.png}\\
  {\small Quelle: \url{ https://cds.cern.ch/record/2113241 } }
\end{frame}

\begin{frame}{Anwendung: Hochenergiephysik / Gitter-QCD}
  \centering
  Simulation der Quantenchromodynamik auf Hochgeschwindigkeitsrechnern\\ \vspace{0.2cm}
  \begin{columns}
  \column{0.49\textwidth}
    \includegraphics[width=0.8\textwidth]{graphics/LQCD2.jpg} \\
  \column{0.49\textwidth}
    \includegraphics[width=0.8\textwidth]{graphics/juqueen.jpg} \\
  \end{columns}
  \vspace{0.3cm}
  {\small Quellen: \url{http://lpc-clermont.in2p3.fr/IMG/theorie/LQCD2.jpg} \\
                   \url{http://www.fz-juelich.de/ias/jsc/EN/Expertise/Supercomputers/JUQUEEN/JUQUEEN_node.html} }
\end{frame}

\begin{frame}{Anwendung: Biophysik / Biochemie - Molekulardynamik}
  \centering
  Simulation des NMDA Proteins und Rezeptors im menschlichen Gehirn\\ \vspace{0.2cm}
  \includegraphics[width=0.4\textwidth]{graphics/glutamate.jpg}\\
  {\small Quelle: \url{http://computation.llnl.gov/glutamate-receptor-molecular-dynamics-simulation} }
\end{frame}

\begin{frame}{Die Programmiersprache C}{Vorlesung \arabic{lecturecounter}}
  \centering
  \includegraphics[height=7cm]{graphics/The_C_Programming_Language_cover}
\end{frame}

\begin{frame}{Algorithmus: Einfügensortieren Pseudocode}{Vorlesung \arabic{lecturecounter}}
  \include{algos/einfuegensortieren}
\end{frame}

\begin{frame}[fragile]{Die Struktur eines C-Programms}{Vorlesung \arabic{lecturecounter}}
Das einfache Programm
\begin{lstlisting}
#include <stdio.h>
int main(void){
  printf("Hallo, Welt!\n");
  return 0;
}
\end{lstlisting}
können wir in einer Textdatei \verb|hallo_welt.c| abspeichern und mit dem C-Compiler in ein ausführbares Programm übersetzen
\begin{verbatim}
$ gcc -Wall -Wpedantic -std=c99 -o hallo_welt hallo_welt.c
\end{verbatim}
und es dann ausführen
\begin{verbatim}
$ ./hallo_welt
Hallo, Welt!
$ _
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{Variablen deklarieren und definieren}{Vorlesung \arabic{lecturecounter}}
 Eine Variable wird in C mit:
\begin{lstlisting}
DATENTYP NAME;        // deklariert
NAME = WERT;          // definiert
DATENYP NAME = WERT;  // deklariert und definiert
\end{lstlisting}
 \begin{block}{Blöcke und Sichbarkeitsbereich (\emph{scope})}
 In C werden Programmblöcke mit $\lbrace$ und $\rbrace$ umklammert.
 Ein Block fasst mehrere Ausdrücke (\emph{statements}) zu einem Ausdruck zusammen.
 Eine Variablendeklaration gilt innerhalb eines Blocks und seiner Unterblöcke.
 \end{block}
\begin{lstlisting}
DATENTYP1 VAR1 = WERT1;         // Aeusserster Block
{
  DATENTYP2 VAR2 = WERT2;
  // hier gelten sowohl VAR1 als auch VAR2
  {
    DATENTYP3 VAR3 = WERT3;
    // hier gelten alle drei Variablen
  } // ab hier gilt VAR3 nicht mehr
} // jetzt gilt auch VAR2 nicht mehr
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Einrückung und Kommentare}{Vorlesung \arabic{lecturecounter}}
\begin{lstlisting}
DATENTYP1 VAR1 = WERT1;         // Aeusserster Block
{
  DATENTYP2 VAR2 = WERT2;
  // hier gelten sowohl VAR1 als auch VAR2
  {
    DATENTYP3 VAR3 = WERT3;
    // hier gelten alle drei Variablen
  } // ab hier gilt VAR3 nicht mehr
} // jetzt gilt auch VAR2 nicht mehr
\end{lstlisting}
\begin{block}{}
  Ein wichtiger Aspekt, der zur Lesbarkeit eines Quelltextes beiträgt, ist eine konsistente Einrückung der Programmblöcke. Man hätte auch folgendes schreiben können.
\end{block}
\begin{lstlisting}
DATENTYP1 VAR1=WERT1;{DATENTYP2 VAR2=WERT2;{DATENTYP3 VAR3=WERT3;}}
\end{lstlisting}
\begin{block}{}
An nicht-trivialen Stellen des Programmcodes ist es zudem wichtig, dass man Kommentare einfügt, um sich und anderen zu erklären, was da geschieht. 
\end{block}
\end{frame}

\begin{frame}[fragile]{Bedingte Ausführung: \texttt{if / else} Statement}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
  Das \texttt{if / else} statement erlaubt es, den Programmfluss abhängig vom momentanen Zustand zu steuern.
\end{block}
Input: $x, y, z$
\begin{lstlisting}
if( x > 0 ){
  // x groesser 0
} else if ( x == 0 && y <= 1 ) {
  // x gleich 0 UND y kleiner-gleich 1
  if( (z + 3) == y ){
    // z+3 gleich y
  }
} else if ( x == 0 && y > 1 ) {
  // x gleich 0 UND y groesser 1
} else if ( x < 0 ) {
  // Falls x kleiner 0
}
if( z > 0 || (y % 2 == 0) ){
  // z groesser 0 ODER y gerade
}
\end{lstlisting}
\textbf{Unter welchen Umständen wird keine Anweisung ausgeführt?}
\end{frame}

\begin{frame}[fragile]{Schleifen: \texttt{while} \& \texttt{do-while} (1/2)}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
  Iterative Verfahren sind ein zentraler Bestandteil vieler Algorithmen.
  Schleifen wiederholen Anweisungen, bis eine gewählte Bedingung erreicht ist.
\end{block}
Die \texttt{while}- und \texttt{do-while}-Schleifen sind die einfachsten Schleifentypen in C und haben folgende Struktur:
\vspace{0.2cm}
\begin{columns}
\column{0.49\textwidth}
\begin{lstlisting}
while( LOGISCHER AUSDRUCK ){
  BEFEHLE
}  
\end{lstlisting}
\begin{enumerate}
  \item[(1)]{ \texttt{AUSDRUCK} auf Wahrheit prüfen }
  \begin{itemize}
    \item[wahr]{ \texttt{BEFEHLE} ausführen }
    \begin{itemize}
      \item[$\drsh$]{Zurück zu (1)}
    \end{itemize}
    \item[unwahr]{ Schleife beenden }
  \end{itemize}
\end{enumerate}

\column{0.49\textwidth}
\begin{lstlisting}
do {
  BEFEHLE
} while( LOGISCHER AUSDRUCK ); 
\end{lstlisting}
\begin{enumerate}
  \item[(0)]{ \texttt{BEFEHLE} ausführen }
  \item[(1)]{ \texttt{AUSDRUCK} auf Wahrheit prüfen }
  \begin{itemize}
    \item[wahr]{ zurück zu (0) }
    \item[unwahr]{ Schleife beenden }
  \end{itemize}
\end{enumerate}

\end{columns}

\end{frame}

\begin{frame}[fragile]{Schleifen: \texttt{while} \texttt{do-while} (2/2)}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
Wir wollen folgende unendliche Summe berechnen:
\begin{equation*}
  S=\sum_{n=0}^\infty x^n, \quad |x| < 1
\end{equation*}
\end{block}

\begin{lstlisting}
const double x = 0.8;         // x ist eine Konstante
double S = 0.0;               // x^0 = 1.0
double xn = 1.0;              // x^0 = 1.0
while( xn > 1.0e-12 ){        // Test auf x^n > 1,0 * 10^{-12}
  S = S + xn;
  xn = xn * x;                // x^n
}
\end{lstlisting}
\begin{lstlisting}
do {
  S += xn;
  xn *= x;
while( xn > 1.0e-12 );
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Schleifen: \texttt{for} (1/2)}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
  In C hat eine \texttt{for}-Schleife Kontrollelemente im Schleifenkopf, ideal um mit einer Zählvariable zu arbeiten (aber auch andere Konstrukte sind möglich).
\end{block}
\begin{lstlisting}
for( INITIALISIERUNG; LOGISCHER AUSDRUCK; SCHRITT ){
  BEFEHLE
}
\end{lstlisting}
\begin{enumerate}
  \item[(0)]{\texttt{INITIALISIERUNG} wird ausgeführt}
  \begin{enumerate}
    \item[(1)]{\texttt{LOGISCHER AUSDRUCK} wird auf Wahrheit geprüft}
    \begin{enumerate}
      \item[wahr]{Weiter zu (2)}
      \item[unwahr]{Schleife beenden}
    \end{enumerate}
    \item[(2)]{\texttt{BEFEHLE} werden ausgeführt}
    \item[(3)]{\texttt{SCHRITT} wird ausgeführt}
    \item[$\Rightarrow$]{Zurück zu (1)}
  \end{enumerate}
\end{enumerate}
\end{frame}

\begin{frame}[fragile]{Schleifen: \texttt{for} (2/2)}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
Die Berechnung der Summe $\sum_{n=0}^{\infty} \, x^n$, könnte man, z.B. so implementieren:
\end{block}
\begin{lstlisting}
const double x = 0.8;
double S = 0.0;
double xn = 1.0;
for( unsigned int n = 0; n < 1000; ++n ){  // max. 1000 Iterationen
  S = S + xn;
  if( xn < 1.0e-12 ){
    break;                        // aus der Schleife ausbrechen
  }                               // selbst wenn n < 1000
  xn = xn * x;
}
\end{lstlisting}

\begin{block}{}
Oder aber auch so:
\end{block}
\begin{lstlisting}
const double x = 0.8;
double S = 0.0;
for( double xn = 1.0; xn > 1.0e-12; xn *= x){
  S += xn;
}
\end{lstlisting}
\end{frame}

\stepcounter{lecturecounter}

\begin{frame}{Fragen zu Vorlesung 1}
  In der letzten Vorlesung:
  \begin{itemize}
    \item{Rechnerarchitektur}
    \item{Dualsystem}
    \item{Fließkommazahlen}
    \item{(sehr knappe) Einführung in Algorithmen und Pseudocode}
    \item{Erstes C-Programm}
    \item{Kompilieren und Ausführen}
    \item{Datentypen}
    \item{Operatoren}
    \item{Kontrollstrukturen}
    \begin{itemize}
      \item{\texttt{if / else if / else}}
      \item{Schleifen}
      \begin{itemize}
        \item{\texttt{do-while}, \texttt{while}}
        \item{\texttt{for}}
      \end{itemize}
    \end{itemize}
  \end{itemize}
  \textbf{Heute:} Biete: mehr Demos. Suche: mehr kritische Fragen, fallen Sie mir ins Wort, bitte! Auch die Tutoren!
\end{frame}

\begin{frame}{Wieso eigentlich C?}{Vorlesung 1 Addendum}
  In den nächsten beiden Tagen wird Ihnen vielleicht klar werden, dass einige Aspekte von C doch komplizierter sind, als man glaubt. Wieso also C nutzen und nicht Python?
  \vspace{0.3cm}
  \begin{itemize}
    \item{C und C++ schaffen einen Spagat zwischen Nähe an der Hardware und einer relativ einfachen Sprachsyntax.}
    \begin{itemize}
      \item{Wissenschaftliche Software muss oft so schnell wie möglich sein.}
      \item{Effiziente Programmierung und gute Compiler machen dies in C und C++ möglich.}
    \end{itemize}
    \vspace{0.4cm}
    \item{In der Wissenschaft gibt es unglaublich viel Software die ursprünglich in C geschrieben wurde oder immer noch geschrieben wird. In Bacheror- Master- oder Doktorarbeiten, werden Sie damit in Kontakt kommen und müssen die ``hässlichen'' Grundlagen ein Mal gesehen haben.}
    \vspace{0.4cm}
    \item{Andere Sprachen machen ``unter der Motorhaube'' nichts anderes als C. Zu verstehen, was genau der Rechner da tun muss, hilft zu verstehen, wieso einige Dinge ineffizient sein könnten.}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Textausgabe Mini-Intro}{Vorlesung \arabic{lecturecounter}}
  \begin{block}{\texttt{printf} und die Formatspezifikation}
    \texttt{printf} ist eine Funktion zur \emph{formatierten} Textausgabe in der Konsole.
    Um verschiedene Datentypen auszugeben, muss man Platzhalter nutzen.
  \end{block}
  \begin{center}
  \begin{tabular}{lr}
    \hline
    \texttt{Platzhalter} & Bedeutung \\\hline
    \texttt{\%d}        &  \texttt{int} \\
    \texttt{\%ld}  &  \texttt{long int} \\
    \texttt{\%lld} &  \texttt{long long int} \\
    \texttt{\%ud}  &  \texttt{unsigned int} \\
    \texttt{\%llu} &  \texttt{long long unsigned int} \\
    \texttt{\%f,\%e}   & \texttt{float} \\
    \texttt{\%lf,\%le}  & \texttt{double} \\
    \hline
  \end{tabular}
  \end{center}  
  \begin{block}{}
    $\Rightarrow$ Mal ausprobieren! (\verb|test_printf.c|)
  \end{block}
\end{frame}

\begin{frame}[fragile]{Funktionen}{Vorlesung \arabic{lecturecounter}}
  \begin{block}{}
    C-Programme bestehen im Wesentlichen aus Funktionsdefinitionen und Funktionsaufrufen, sowie eingebauten und eigenen Datentypen. Ein komplexes C-Programm ruft viele Funktionen auf, welche wiederum Funktionen aufrufen.
  \end{block}
  \centering
  \includegraphics[height=7cm]{graphics/call_graph}
\end{frame}

\begin{frame}[fragile]{Funktionen: Definition}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
In der letzten Vorlesung hatten wir ein Programm entwickelt um eine Annäherung an die unendliche Summe
\begin{equation*}
  S=\sum_{n=0}^\infty x^n, \quad |x| < 1
\end{equation*}
zu bestimmen.
\end{block}
\begin{lstlisting}
const double x = 0.8;
double S = 0.0;
double xn = 1.0;
for( unsigned int n = 0; n < 1000; ++n ){  // max. 1000 Iterationen
  S = S + xn;
  if( xn < 1.0e-12 ){
    break;                        // aus der Schleife ausbrechen
  }                               // selbst wenn n < 1000
  xn = xn * x;
}
\end{lstlisting}
\textbf{Wir wollen nun mit einer Funktion die Berechnung auslagern und verallgemeinern.} (\verb|sum_xn_funktion.c|)
\end{frame}

\begin{frame}[fragile]{Funktionen: Funktionskopf und Signatur}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
  Eine Funktion wird dem Compiler bekannt gemacht, indem ihr Name und die Datentypen ihrer Argumente festgelegt werden. $\Rightarrow$ \emph{Funktionsdeklaration}
\end{block}

\begin{lstlisting}
RUECKGABETYP FUNKTIONSNAME( ARGUMENT1_TYP ARG1, ARGUMENT2_TYP ARG2,
                            ARGUMENT3_TYP ARG3 );
\end{lstlisting}
\begin{block}{Signatur}
  {\footnotesize \verb| (FUNKTIONSNAME) ( ARGUMENT1_TYP, ARGUMENT2_TYP, ARGUMENT3_TYP ) | }
\end{block}

\begin{block}{}
  Wichtig: Bei der Unterscheidung zweier Funktionen gleichen Namens, wird der Typ des Rückgabewerts \emph{nicht} berücksichtigt!
\end{block}
\begin{lstlisting}
double teilen( double zaehler, double nenner ){ [...] }
float  teilen( double zaehler, double nenner ){ [...] } // Fehler!
float  teilen( float  zaehler, float  nenner ){ [...] } // OK
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Funktionen: Funktionsaufruf und Rückgabewert}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
Hat eine Funktion einen Rückgabewert, so kann man diesen beim Aufruf einer Variable zuweisen:
\begin{lstlisting}
double result = teilen( 8.0, 3.2 );  
\end{lstlisting}
\end{block}
\begin{block}{}
Man kann den Rückgabewert aber auch einer anderen Funktion als Argument übergeben:
\begin{lstlisting}
addieren( teilen(8.0, 3.2), 4.5 );
\end{lstlisting}
\begin{itemize}
  \item{Was macht dieser Code?} 
\end{itemize}
\end{block}
\begin{block}{}
Oder aber man ignoriert den Rückgabewert, wie wir es bei \texttt{printf([...])} getan haben (Gesamtzahl der geschriebenen Zeichen).
\end{block}
\end{frame}

\begin{frame}[fragile]{Funktionen: Deklaration und Definition}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
  Die \emph{Funktionsdeklaration} informiert den Compiler über die Existenz und Signatur einer Funktion
\begin{lstlisting}
double power( const double, const int );
\end{lstlisting}
\end{block}
\begin{block}{}
  Die \emph{Funktionsdefinition} beschreibt erst, wie diese Funktion ihre Aufgabe erfüllt.
\end{block}
Funktionsdeklarationen führen einerseits zu lesbarerem Code, finden aber andererseits Verwendung in der \emph{modularen Programmierung}, die wir in den nächsten Tagen kennenlernen werden.

\textbf{Erstmal ein Beispiel.} (\verb|funktion_deklaration.c|)
\end{frame}

\begin{frame}[fragile]{Funktionen: Rekursion}{Vorlesung \arabic{lecturecounter}}
  \begin{block}{Rekursion}
    Eine Funktion, die sich selbst aufruft, nennt man \emph{rekursiv}. Rekursion kann man oft nutzen, um Aufgaben auf fast magische Art und Weise zu lösen. Leider birgt Rekursion auch viele Gefahren.
  \end{block}
\begin{lstlisting}
TYP rekursion( TYP arg ){
  if( [...] ){ // Ziel erreicht!
    return arg;
  } else {
    return rekursion( arg ); // noch einmal tiefer verschachteln!
  }
}
\end{lstlisting}
   \textbf{Versuchen wir mal, unsere Summe rekursiv auszurechnen!} (\verb|sum_xn_rekursiv.c|)
\end{frame}
 
\begin{frame}[fragile]{\texttt{gdb} und \texttt{valgrind}}
\begin{block}{}
  Nanu, was ist denn da schiefgegangen? Ein Debugger, ist ein Programm, mit dem man Fehler in anderen Programmen versuchen kann nachzuvollziehen.
\end{block}
\begin{block}{Debugging-Symbole mit einbinden und Programm in \texttt{gdb} ausführen}
\begin{verbatim}
$ gcc -Wall -Wpedantic -g -ggdb -o sum_xn_rekursiv_DEBUG \
  sum_xn_rekursiv.c
$ gdb ./sum_xn_rekursiv_DEBUG
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1
(gdb) run
\end{verbatim}
\end{block}

\begin{block}{\texttt{valgrind}}
Ein weiteres nützliches Programm ist \texttt{valgrind}. Es ist eigentlich kein Debugger im eigentlichen Sinne, ist aber spezialisiert darauf, Speicherfehler zu erkennen.
\begin{verbatim}
$ valgrind ./sum_xn_rekursiv_DEBUG
\end{verbatim}
\end{block}
\end{frame}

\begin{frame}[fragile]{Statische Arrays}{Vorlesung \arabic{lecturecounter}}
  \begin{block}{}
    Oft brauchen wir viele Daten des gleichen Datentyps. Diese kann man praktisch in \emph{Arrays} abspeichern.
  \end{block}

\begin{lstlisting}
DATENTYP NAME[ANZAHL];
\end{lstlisting}
Hierbei muss, selbst in C99, \texttt{ANZAHL} fast immer eine numerische Konstante sein!

\begin{lstlisting}
double a[3];  // Array mit 3 double deklarieren

double b[3] = {1.0, 2.3, 9.9};  /* Array mit 3 double deklarieren
                                   und initialisieren */

double c[4] = {4.5, 7.3}; /* Die ersten beiden Elemente mit 
                             4.5 und 7.3 initialisieren,
                             alle anderen werden mit 0.0 
                             initialisiert */
                                   
a[1] = 0.0001; // 0.0001 im zweiten Element von v abspeichern
\end{lstlisting}
\textbf{$\Rightarrow$ Wir möchten nun für unsere Annäherung an die unendliche Summe alle Terme abspeichern und ausgeben!} (\verb|sum_xn_alleterme.c|)
\end{frame}

\begin{frame}[fragile]{Mini-Intro: Texteingabe}{Vorlesung \arabic{lecturecounter}}
\begin{block}{Der Adressoperator \texttt{\&}}
  Für jede Variable, jedes Datentyps, gibt \texttt{\&} die Speicheradresse der Variable zurück. (Um genauer zu sein, ist der Rückgabewert ein Zeiger auf ein Objekt des ensprechenden Datentyps)
\end{block}
\begin{block}{Eingabe mit \texttt{scanf}}
  Die Funktion \texttt{scanf} kann als umgekehrtes \texttt{printf} verstanden werden.
\end{block}
\begin{lstlisting}
int ganzzahl; double dezimalzahl;
scanf("%d %f",&ganzzahl, &dezimalzahl);
\end{lstlisting}
\textbf{Probieren wir mal, ob wir so unser Summenprogramm weiter verallgemeinern können.} (\verb|test_scanf.c| und \verb|sum_xn_eingabe.c|)
\end{frame}

\begin{frame}[fragile]{Preview: Zeiger auf Daten}{Vorlesung \arabic{lecturecounter}}
\begin{block}{Zeigervariablen}
  Eine Zeigervariable speichert die Adresse einer Variable für einen bestimmten Datenyp.
\end{block}
\begin{block}{Dereferenzierungsoperator \texttt{*}}
  Dieser Operator gibt Zugriff zu den Daten, auf die der Zeiger zeigt.
\end{block}
$\Rightarrow$ \textbf{Tafelbild +} (\texttt{zeiger\_preview.c})
\end{frame}


\end{document}