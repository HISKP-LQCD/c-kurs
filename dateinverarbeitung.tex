\section{Datein verarbeiten}
In Unix wir identifizieren ein Datein mit seinem Name. Wir können Funktionen aus dem Standardbibliothek verwenden, um
detallierte Informationen über ihnen zu erhalten. In diesem Fall die \texttt{C} Sprache bietet uns den \texttt{stat} Funktion 
und ihren Rückgabewert die \texttt{stat} Strukture. 
\begin{myexampleblock}{Definition: \texttt{struct stat}}
\begin{lstlisting}
struct tm{
  _dev_t st_dev:   /*Laufwerksnummer*/
  _ino_t st_ino;   /*Inode: eine grundlegende Datenstruktur zur Verwaltung von Dateisystemen mit unixartigen Betriebssystemen. */
  unsigned short st_mode; /*Modus, Berechtigungen*/
  short st_nlink;  /*Anzahl der Referenzen auf dem Datei*/
  short st_uid;    /*USER-ID*/
  short st_gid;    /*GROUP-ID*/
  _dev_t st_rdev:  /*Laufwerksnummer*/
  _off_t st_size;  /*Dateigroesse in Bytes */
  time_t st_atime; /*Datum des letzten Zugriffes*/
  time_t st_mtime; /*Datum des letzten Aenderung*/
  time_t st_ctime; /*Erstelldatum*/
}
\end{lstlisting}
\vspace{-0.4cm}
Das Definition befindet sich im Standardbibliothek \texttt{sys/stat.h}.
\end{myexampleblock}
\begin{myexampleblock}{Definition: \texttt{struct passwd}}
\begin{lstlisting}
struct passwd {
 char *pw_name; /*Anwaenders login Name*/
 uid_t pw_uid; /* UID id*/
 gid_t pw_gid; /* GID id*/
 char *pw_dir; /*Login Direktory*/
 ...
}; 
\end{lstlisting}
\vspace{-0.4cm}
Das Definition befindet sich im Standardbibliothek \texttt{passwd.h}.
Die Punkten stehen für Elementen, die uns nicht interessiert.
\end{myexampleblock}
\begin{myexampleblock}{Definition: \texttt{struct group}}
\begin{lstlisting}
struct group {
  char *gr_name;
  gid_t gr_gid;
  char **gr_mem;
  ...
};
\end{lstlisting}
\vspace{-0.4cm}
Das Definition befindet sich im Standardbibliothek \texttt{grp.h}.
Die Punkten stehen für Elementen, die uns nicht interessiert.
\end{myexampleblock}
\begin{myexampleblock}{Funktion: \texttt{stat}}
\begin{lstlisting}
int stat(char * path, struct stat * buf);
\end{lstlisting}
\vspace{-.4cm}
Information erhalten über das Datein bennant als $path$. Die Informations werden im $buf$ gespeichert.
Der Rückgabewert ist 0, wenn alles geklappt hat, und -1 bei einem Fehler.
\end{myexampleblock}
Bevor wir mit einem Datein arbeiten, müssen wir sicher sein, ob wir die entsprechende Rechte haben, um ihn zu 
erstellen oder einzulesen. Die Felden \texttt{uid} und \texttt{gid} in der \texttt{stat} Strukture geben Informationen 
über die Besitzer des Dateins. Der Supervisor hat immer \texttt{(0,0)} als \texttt{(uid,gid)}. Normalweise der erste Anwänder 
hat 1000 \texttt{uid}. Für die weitere Anwänders das \texttt{uid} wird um eins erhöht. 
Wir können auch das \texttt{uid} mit einem Anwänder's Name verbunden. Dafür gibt es zum Bespiel der \texttt{getpwuid} 
Funktion im Standardbibliothek. Die Anwänders in den unixartigen Betriebsystemen haben ihre login Name und gehören
auch zu einer Gruppe. Wenn in einem Computer mehrere Programmierer arbeiten, Sie können ihre Arbeit leicht teilen. 
Wir können das \texttt{gid} mit einem Name mit Hilfe von \texttt{getgrgid} Funktion verbunden.
Es kann nötig sein zu prüfen, ob die Datein beschädigt ist, oder nicht.  Bespielweise, wir können ihre Größe
überprüfen. Lass uns annehmen, dass wir die folgende Datei (example.txt) haben
\begin{lstlisting}{example.txt}
Hello world
\end{lstlisting}
Wir haben die folgende \texttt{C} Code geschrieben, um Informationen über diesen Datei erhalten:
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <pwd.h>
#include <grp.h>
#include <sys/stat.h>
int main(int argc, char *argv[])
{
   struct stat *sb;
   struct passwd *pwuser;
   struct group *grpnam;
   int i;
   if (argc < 2)
   {
       printf("Usage: %s: file ...\n", argv[0]);
       exit(EXIT_FAILURE);
   }
   sb= (struct stat *)malloc(sizeof(struct stat));
   if (sb == NULL){
      printf("Memory allocation failure\n");
      exit(1);
   }
   for ( i = 1; i < argc; i++){
      if (stat(argv[i], sb) == -1){
          exit(EXIT_FAILURE);
      }
      if ( (pwuser = getpwuid(sb->st_uid)) == NULL )
      {
          exit(EXIT_FAILURE);
      }
      if ( (grpnam = getgrgid(sb->st_gid)) == NULL )
      {
          exit(EXIT_FAILURE);
      }
      printf("%s:\n", argv[i]);
      printf("\tinode: %u\n", (int)sb->st_ino);
      printf("\towner: %u (%s)\n", sb->st_uid, pwuser->pw_name);
      printf("\tgroup: %u (%s)\n", sb->st_gid, grpnam->gr_name);
      printf("\tperms: %o\n", sb->st_mode & (S_IRWXU | S_IRWXG | S_IRWXO));
      printf("\tsize: %ld\n", sb->st_size);
      printf("\tatime: %s", ctime(&(sb->st_atime)));
      printf("\tmtime: %s", ctime(&(sb->st_mtime)));
      printf("\tctime: %s", ctime(&(sb->st_ctime)));
      printf("\n");
   }
   free(sb);
   return 0;
}
\end{lstlisting}
Dieses Beispiel gibt  viele Neueigkeiten für uns. Zum ersten Mal verwenden wir die Eingabeparameters unseres 
Programms. Zur Erinnerung, der Wert vom \texttt{argc} erhaltet die Anzahl der Parameter, und im \texttt{argv[]} 
(Array von Zeiger auf \texttt{char} Typ) sind die Parameter gespeichert. Standardmäßig das erste Parameter ist das 
Name des Programms, dann kommen die Parameter, die wir hinzufügen haben. In der 13-ten Zeile prüfen wir die Anzahl 
der eingegebenen Parameter. Wenn wir keinen Parameter eingegeben haben, beenden wir das Programm mit einer Gebrauchanweisung.
Für die Anwänders das ist ein große Hilfe. Standartmäßig die Unix Programmen ausführen mit dem \texttt{--help} werden
ähnliche Gebrauchanweisungen zur Verfügung stellen.
In dem Programm wir verwenden jeden Parameter als ein Dateiname und erhalten ihre Eigenschaften mit Hilfe des \texttt{stat} 
Funktion. Es ist wichtig in der 18-ten Zeile Speicher für \texttt{sb} reservieren. Der Funktion \texttt{stat} geht davon aus, 
dass die Adresse, die sie bekommen habe, ist schon reserviert. In diesem Beispiel wir verwenden auch der \texttt{getpwuid} Funktion, 
mit dem wir die \texttt{uid} mit einem login Name verbunden. In unix Betriebsystemen wir können verschiedene Rechten für 
\begin{enumerate}
\item Besitzer, 
\item Gruppe vom Besitzer
\item Die Anderen
\end{enumerate}
geb en. Für ein Datei gibt es Rechte für Schreiben (\texttt{w}), Lesen(\texttt{r}) und Ausführen(\texttt{x}). Aus der Kommandozeile
können wir die Rechten mit \texttt{ls -la} überprüfen. Beispielweise:\\
\begin{verb}
>$ ls -la example.txt
\end{verb}\\
\begin{verb}
-rw-rw-r-- 1 pittler pittler 26 Maer  4 18:36 example.txt
\end{verb}\\
Das bedeutet, dass der Besitzer von \texttt{example.txt} ist der Anwänder von Name \texttt{pittler} aus der \texttt{pittler} Gruppe.
Der Besitzer und ihre Gruppe hat Recht für Lesen und auch Schreiben, die Anderen haben Rechte nur für Lesen.
In unserem Code wir determinieren die Rechten für die drei Oben Kategorie im Zeile 35. Jede Rechte wird ein 3\texttt{bit} binären
Zahl sein. Die Rechte für Lesen gehört zum höchsten \texttt{bit}, und die Rechte von Ausführen gehört zum niedrigsten \texttt{bit}. 
Beispielweise in unserer Ausgabe(Siehst du unter) \texttt{perms: 6} bedeutet Rechte für Schreiben und Lesen.
\begin{lstlisting}
./a.out example.txt
example.txt:
  inode: 11931732
  owner: 1000 (pittler)
  group: 1000 (pittler)
  perms: 664
  size: 12
  atime: Fri Mar  3 12:57:38 2017
  mtime: Fri Mar  3 12:57:31 2017
  ctime: Fri Mar  3 12:57:31 2017
\end{lstlisting}
Die Größe vom Datein kann überraschend sein, weil es nur aus 11 Zeichen besteht. Aber jeden Datein enthält die 
$EOF$(Ende des Dateins) Zeichen. Mit diesem Byte die Größe des Dateins stimmt.
\subsection{Das Stream Konzept}

Obwohl die Sprache keine eingebaute Methode für Ein und Ausgabe hat, in der Standardbibliothek befindet sich
mehrere wertvollen Ein und Ausgabe Funktionen. Ein wichtiges Konzept ist das \texttt{stream}. Das \texttt{stream} ist ein Kanal, die
eine Verbindung zwischen die Datein und deine Programm macht. Beispielweise hier Datein kann nicht nur eine physikalische Dateiobjekt
aus der Festpalette bezeichnet, sondern auch Datei aus Tastatur, Monitor, oder Datein auf einem Kasetten. In jedem Fall wir haben das 
gleiche Kanal. Diese Universalität macht Ein und Ausgabe einfach zu handhaben. Zu jeden Kanalen gehören ein Zeiger von \texttt{FILE} Typ,
mit dem wir Sie verwenden können. Der Laufzeitsystem stellt automatisch für uns drei Kanale
\begin{enumerate}
\item \texttt{stdin} : Standard für Eingabe (Wir haben schon verwendem mit \texttt{scanf}) 
\item \texttt{stdout} : Standard für Ausgabe (Wir haben schon verwenden mit \texttt{printf})
\item \texttt{stderr} : Standard für Fehlernachrichten
\end{enumerate} zur Verfügung. Wir haben schon das Standard Ein und Ausgabe kennengelernt. Zur errinerung hier gibt es
eine weitere Übung:
\begin{myexampleprogram}{Programme: \texttt{Eingabe nach Ausgabe Kopieren}}
\begin{lstlisting}
#include<stdio.h>
#include<stdlib.h>
int main(){
  char c;
  while( (c=getchar()) !=EOF)
   putchar(c);
}
\end{lstlisting}
\end{myexampleprogram}
\begin{myexampleblock}{Funktion: \texttt{getchar}}
\begin{lstlisting}
int getchar ( void );
\end{lstlisting}
\vspace{-0.4cm}
Lest ein Zeichen von der Standard Eingabe. Rückgabewert ist das eingelesene Zeichen, wenn die Einlesung erfolgreich war, außerdem
EOF.
\end{myexampleblock}
\begin{myexampleblock}{Funktion: \texttt{putchar}}
\begin{lstlisting}
int putchar (char c);
\end{lstlisting}
\vspace{-0.4cm}
Drückt den Zeichen $c$ aus. Der Rückgabewert ist ein int Wert, der von unsigned char konvertiert wurde.
\end{myexampleblock}
In diesem einfachen Beispiel wir lesen die Zeichen ein bis zum Ende des Dateins in der fünften Zeile.
Im Schleifenkern wir haben nur eine Anweisung, die der eingelesenen Zeichen ausdrückt. Aber in diesem Beispiel
bei der Ausführung wir müssen den Datein mit dem \texttt{<} Operator zur Standard Eingabe ziehen. Um direkt aus
einem Datein lesen zu können, wir müssen ein Kanal zum Datein eröffnen.
\begin{myexampleblock}{Funktion: \texttt{fopen}}
\begin{lstlisting}
FILE *fopen( const char *filename, char mode);
\end{lstlisting}
\vspace{-0.4cm}
Eröffnet ein Kanal zum Datein für Verarbeitung.
\begin{itemize} 
\itemsep0.5ex
\item \texttt{"w"}: Datei zum Schreiben erzeugen, wenn es schon existiert, wird sie überschreiben
\item \texttt{"r"}: Öffnen einer Datei ausschließlich zum Lesen
\item \texttt{"{}a"}: Öffnen einer Datein zum Anfügen. Wenn is nicht existiert, wird sie erzeugen.
\item \texttt{"w+"} Öffnen zum Schreiben und Lesen, wenn es schon existiert, wird sie überschreiben.
\item \texttt{"r+"} Öffnen einer Datei zum Schreiben und Lesen.
\item \texttt{"{}a+"} Öffnen einer Datei zum Lesen und Anfügen.
\end{itemize}
\end{myexampleblock}  
\begin{myexampleblock}{Funktion:\texttt{fclose}}
\begin{lstlisting}
int fclose(FILE *stream);
\end{lstlisting}
\vspace{-0.4cm}
Dieser Funktion wird der Kanal \texttt{stream} freigegeben. Der Rückgabewert ist \texttt{0}, wenn es
erfolgreich war und \texttt{EOF} wenn nicht.
\end{myexampleblock}
In diesem Fall können wir das \texttt{fopen} Funktion verwenden um einer Kanal zu eröffnen. Vordem
wir mit einem Datei das Arbeit anfangen, müssen wir wissen ob es ein Binärdatei oder ein Asciidatei
ist. Ein Asciidatei ist ein Sequenz von Zeichen beenden mit \texttt{EOF}. In einem Binärdatei, wir müssen vorhand
die Strukture des Inhalts von Datei wissen. Kann mann fragen, Warum wir bei allen Binärdateien verwenden wollen?
Das Antwort liegt in der Genauigkeit und im Speicherplatz. Wenn wir eine 8 \texttt{byte} größe Fließkommazahl in 
ASCII speichern würde, brauchen wir $~40$-mal mehr speichern um die gleiche Genauigkeit zu erreichen. Zuerst 
werden wir einlesen aus Einfache Asciidatei.
\begin{myexampleblock}{Funktion: \texttt{fscanf}}
\begin{lstlisting}
int fscanf(FILE *kanal,char *formattierungtext, ....);
\end{lstlisting}
\vspace{-0.4cm}
Formattierte Einlesung von einer Asciidatei, interpretiert von dem formattierungtext. Der Rückgabewert ist der
Anzahl der Argumenten die erfolgreich gefüllt waren. Als Arguments, wir müssen nicht der Wert der Variable geben
sondern auch ihre Adresse. Mit dem formattierungtext können wir im individuellen Weise Einlesen.
Die White-Space zeichen im Kanal wurden nicht gelesen (Beispielweise: Neue Zeile, Raumtaste, Tabulatorzeichen).

Die eingelesenen Datei wurden nach den Folgenden Regeln Speichern. Die generelle Form ist:
\texttt{\%Spezificierungszeichen}

Die eingelesene Datei wurden nach den Folgenden Regeln Speichern. 

\begin{center}
\begin{tabular}{|cc|}
\hline
\texttt{Specifizierungzeichen} & Bedeutung \\\hline
\texttt{\%d}	&  Einlesen ein ganze Zahl in einer $in$ Variable \\
\texttt{\%ld}  &  Einlesen ein ganze Zahl in einer $long~int$ Variable \\
\texttt{\%f,\%e}   & Einlesen ein Fließkommazahl in einer $float$ Variable \\
\texttt{\%lf,\%le}  & Einlesen ein Fließkommazahl in einer $double$ Variable \\
\texttt{\%c}  & Einlesen ein Zeichen in einer $char$ Variable \\
\texttt{\%s}  & Einlesen eine Zeichenkette in einem Charakterarray.\\
\hline
\end{tabular}
\end{center}

Die anderen Zeichen im formattierungtext wurden eingelesen, aber nicht gespeichert. 
\end{myexampleblock}
Zum Beispiel wir möchten die Zahlen von diesem Asciidatei einlesen.
\begin{lstlisting}
1212
        1222
999             12212
888
\end{lstlisting}
Wir müssen nicht achten auf die ``white space'' Zeichen, wir können Sie einfach vergessen.
Im unteren Quelltext wir zeigen, wie es in der Praxis funktioniert.
\begin{lstlisting}
#include<stdio.h>
#include<stdlib.h>
#include<errno.h>
int main(int argc, char *argv[]){
  FILE *in;
  int d;
  if (argc>2){
   fprintf(stderr,"Useage: ./read_int_ascii filename\n");
   exit(1);
  }
  in=fopen(argv[1], "r");
  if (in == NULL){
   fprintf(stderr, "Error opening the file %d\n", errno);
   exit(1);
  }
  while( fscanf(in, "%d", &d) == 1 ){
    printf("%d\n");
  }
  if (fclose(in) != 0){
    printf("Error closing the File\n");
    exit(1);
  }
}
\end{lstlisting}
Zuerst wir öffnen ein Kanal für einlesen mit dem \texttt{fopen} Fuktion in der 11-ten Zeile. Wir müssen 
der Rückgabewert vom \texttt{fopen} überprüfen um Fehler zu vermeiden. Wenn die Rückgabewert ist das 
\texttt{NULL} Zeiger wir haben irgendeine Fehler. Hier verwenden wir das \texttt{errno} Systemumgebungsvariable
um Informationen über den Fehler zu erhalten. Wenn die Standardbibliothek Funktionen Fehler zurückgeben, sie auch 
weisen den Typ des Fehlers aus mit Hilfe der \texttt{errno} Variable. Es gibt Tabellen, die für jede Wert von 
\texttt{errno} Variable den passierten Fehler zeigen. Nachdem wir den Datei erfolgreich geöffnet haben, fangen wir 
das Einlesen an. Wir lesen ganze Zahlen bis zum Ende des Datein (Zeile 16). Nachdem Einlesen wir brauchen den Kanal 
nicht mehr. Zum ende muss die Kanal freigegeben werden (Zeile 19). Die Ausgabe nachhdem Ausführung siehst du unter.
\begin{lstlisting}
1212
1222
999
12212
88
\end{lstlisting}
Das beweist, dass das Ergebnis unabhänging von den ``white space'' Zeichen ist. Jetzt wir können Einlesen, 
wir möchten auch neuen Datein aus unserem Programm erzeugen. Formattierte Ausgabe in einem Datei ist ähnlich 
wie die Eingabe. Wir können der \texttt{fprintf} Funktion aus dem Standardbibliothek verwenden um Daten 
auszuschreiben.
\begin{myexampleblock}{Funktion: \texttt{fprintf}}
\begin{lstlisting}
int fprintf(FILE *kanal,char *formattierungtext, ....);
\end{lstlisting}
\vspace{-0.4cm}
Formattierte Ausgabe in einer Asciidatei, interpretiert von dem formattierungtext. Der Rückgabewert ist der
Anzahl der ausgeschriebenen Zeichen. Als Arguments, wir müssen der Wert der Variable geben
nicht ihre Adresse. Mit dem formattierungtext können wir im einzelnen Wiese ausdrücken.

Die ausgebende Datei wurden ähnlich wie im \texttt{fscanf} verarbeiten. Die generelle Form ist:\\
\texttt{\%Spezificierungszeichen}
{
\begin{center}
\begin{tabular}{|cc|}
\hline
Specifizierungzeichen & Bedeutung \\\hline
\texttt{\%d}   &  Ausgeben ein ganze Zahl \\
\texttt{\%f,\%e}   & Ausgeben ein Fließkommazahl  \\
\texttt{\%c}  & Ausgeben ein Zeichen  \\
\texttt{\%s}  & Ausgeben eine Zeichenkette\\
\hline
\end{tabular}
\end{center}
}
Im \texttt{fprintf} wir können mit \texttt{\%f} entweder der Wert von einem \texttt{float} oder \texttt{double} Fließkommazahl
ausdrücken.
\end{myexampleblock}
Beispielweise, drücken wir das Quadrat der Zahlen von 0 bis 100 immer, sodass alle Zeilen werden
aus 6 Zeichen bestehen.
\begin{lstlisting}
#include<stdio.h>
#include<stdlib.h>
#include<errno.h>
int main(){
  FILE *out;
  int i;
  out=fopen("quadrats.txt", "w");
  if (out == NULL){
   fprintf(stderr, "Error opening the file %d\n", errno);
   exit(1);
  }
  for (i=1;i<=100;++i){
    fprintf(out,"%.6d\n",i*i);
  }
  if (fclose(out) != 0){
    printf("Error in closing the File\n");
    exit(1);
  }
}
\end{lstlisting}
In diesem Fall wir öffnen der Datei zum Schreiben (Zeile 7). Wir drücken 
die Quadrats mit dem \texttt{fprintf} Funktion zum Kanal aus. In der \texttt{C} Sprache wir 
können einstellen, wieviele Ziechen wir in der Ausdrückung verwenden möchten. 
Mit der Anweisung \texttt{\%x.yd} die Ausdrückung beginnt im \texttt{x}-ten Zeichen, und 
verwendet mindesten \texttt{y} zeichen. Mit dem \texttt{\%.6d} jede Quadrat wird ergänzt mit 
\texttt{0} um 6 Zeichen zuverwenden. Die ersten Zeilen des Ergebnis befindest du unter:
\begin{lstlisting}
000001
000004
000009
000016
000025
000036
000049
000064
000081
\end{lstlisting}
Es macht sinn in einem großen Projekt die Parameters in einem Asciidatei ausdrücken, aber
das Ergebnis muss in Binärdatei gespeichert werden. Dafür stellen wir hier vor, wie 
mann binäredatei in \texttt{C} handeln kann. Das großte Unterschied zwischen Binäre and Asciidatei
ist, dass wir der Binäredatei mit einem einfachen Editor nicht anschauen können. Wir müssen uns
errinern in welchen Form wieviele Datei wir in einem Binärdatei geschrieben haben. Für ein einfaches 
Einlesen oder Ausgaben wir können die Funktionen \texttt{fread} und \texttt{fwrite} verwenden. Wenn wir nicht nur
Schreiben sondern auch Einlesen möchten, müssen wir der Kanal auch positionieren.  Beispielweise
wir möchten die Festpalette als Memory verwenden: zuerst schreiben wir etwas aus, danach möchten
wir diese Datei verwenden. In diesem Fall wir können der Kanal mit dem \texttt{rewind()} oder \texttt{fseek()}
Funktion positionieren.
\begin{myexampleblock}{Funktion: \texttt{fread}}
\begin{lstlisting}
size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );
\end{lstlisting}
\vspace{-0.4cm}
Lest aus einem Binärdatei. Der Rückgabewert ist die Größe der eingelesenen Datei.\\
Die Parameters:
\begin{enumerate}
\item \texttt{ptr}: Anfangsadresse, wo die eingelesene Datei gespeichert wird
\item \texttt{size}: Größe einer einlesenden Einheit
\item \texttt{count}: Anzahl der einlesenden Einheiten
\item \texttt{stream}: Zeiger zum Kanal
\end{enumerate}
\end{myexampleblock}
\begin{myexampleblock}{Funktion: \texttt{fwrite}}
\begin{lstlisting}
size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream );
\end{lstlisting}
\vspace{-0.4cm}
Schreibt in einem Binärdatei. Rückgabewert ist die Größe, der ausgeschriebenen
Datei.\\ Die Parameters:
\begin{itemize}
\item \texttt{ptr}: Quelladresse von den ausschreibenden Datei 
\item \texttt{size}: Größe einer ausschreibenden Einheit
\item \texttt{count}: Anzahl der ausschreibenden Einheiten
\item \texttt{stream}: Zeiger Zum Kanal
\end{itemize}
\end{myexampleblock}
\begin{myexampleblock}{Funktion: \texttt{rewind}}
\begin{lstlisting}
void rewind(FILE *stream)
\end{lstlisting}
\vspace{-0.4cm}
Positioniert der Kanal auf dem Anfang des Binärdateis.
Es hat nur ein Parameter: \texttt{stream}: Zeiger zum Kanal.
\end{myexampleblock}
\begin{myexampleblock}{Funktion: \texttt{fseek}}
\begin{lstlisting}
int fseek(FILE *stream, long int offset, int whence)
\end{lstlisting}
\vspace{-0.4cm}
Positioniert der Kanal auf einem Spezifisch Position in dem 
Binärdatei. Rückgabewert ist \texttt{0}, wenn die Positionierung erfolgreich war. Die Parameters:
\begin{enumerate}
\item \texttt{stream}: Zeiger zum Kanal
\item \texttt{offset}: Versatz, Verschiebung
\item \texttt{whence}: Die Position, zur die Verschiebung hinzufügen wird
\end{enumerate}
\end{myexampleblock}
Unter wir geben ein Beispiel für die Verwendung der Funktions $fread$ und $fwrite$.
\begin{lstlisting}
#include<stdio.h>
#include<stdlib.h>
int main(){
   FILE *kanal;
   int *squares;
   int i;
   int n=100;
   kanal=fopen("temporarystorage", "w+");
   if (kanal == NULL){
     fprintf(stderr, "Error in opening the file\n");
     exit(1);
   }
   squares=(int *)malloc(sizeof(int)*n);
   if (squares == NULL){
     fprintf(stderr, "Error in allocating memory\n");
     exit(1);
   }
   for (i=0; i<n; ++i)
     squares[i]=(i+1)*(i+1);
   fwrite(squares, sizeof(int), n, kanal);
   for (i=0; i<n; ++i)
     squares[i]=0;
   rewind(kanal); 
   fread (squares, sizeof(int), n, kanal);
   for (i=0; i<n; ++i)
    printf("%d\n", squares[i]);
   fclose(kanal);
}   
\end{lstlisting}
Wir öffnen der Kanal nicht nur für Einlesen, sondern auch für Schreiben (Zeile 8). Achtung, wenn $temporarystorage$ 
Datei schon exisitiert, dann ihre Inhalt wird gelöscht. Wir reservieren Speicherzellen für 100 Variable von $int$ Typ (Zeile 13).
Danach wir speichern die Quadrats von den ersten hundert ganze Zahlen in diesem Array, und schreiben wir in den 
Binärdatei. Denn wir postionieren den Kanal wieder auf das Anfang des Datein um  die gespeichert Date einzulesen (Ziele 24).
In diesem Fall müssen wir Auch der Kanal freigeben.
